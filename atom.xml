<?xml version="1.0" encoding="utf-8" standalone="no"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://nshen.net/</id>
  <link href="http://nshen.net/"/>
  <link href="http://nshen.net/atom.xml" rel="self"/>
  <title>N神的研究所</title>
  <updated>2021-12-24T01:21:00.430Z</updated>
  <entry>
    <title>我注册一个新的VPS之后要做的事</title>
    <id>http://nshen.net/article/2020-03-01/new-vps</id>
    <link href="http://nshen.net/article/2020-03-01/new-vps"/>
    <updated>2020-03-01T03:01:00.000Z</updated>
    <content>&lt;blockquote&gt;
&lt;p&gt;装 VPS 这件事我做过无数次了，今天需要重装时我都把该干啥，有啥命令又忘得一干二净了，折腾了好久。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;信息大爆炸，大脑不堪负荷，学过的东西一段时间不用就一点印象都没有。我觉得人类大脑也应跟着时代进化，让大脑专注处理信息，把存储功能移到大脑外部，也就是多写文档，多画思维导图，记不住干脆不要记，需要用的时候再找到文档加载进大脑就好了。如果早像今天这样记录一下，几个月后重装时候就可以直接加载进我的大脑，快速完成任务了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一个普通用户，我的流程：&lt;/p&gt;
&lt;h3 id="-"&gt;安装&lt;/h3&gt;
&lt;p&gt;首先我选择的系统是 &lt;code&gt;ubuntu 18.04&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装后，注册商一般会给 &lt;code&gt;root&lt;/code&gt; 密码，用root账号连上去&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;ssh root@my-server-ip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入密码回车&lt;/p&gt;
&lt;h3 id="-"&gt;更新系统&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;apt update
apt upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有些服务商只能装&lt;code&gt;ubuntu 16&lt;/code&gt;，需要自己升到18，不然没法开&lt;code&gt;bbr&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;apt-get dist-upgrade # ubuntu16升18需要这条
do-release-upgrade # 开始升级
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-vim"&gt;安装vim&lt;/h4&gt;
&lt;p&gt;vim是值得花时间一学的技术，我不是vim信徒，也不太会配置那些乱七八糟的插件，但近两年一直用 &lt;code&gt;vscodevim&lt;/code&gt; 插件写代码，常拿鼠标的手腕都不疼了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apt install vim&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="ubuntu-18-bbr"&gt;ubuntu 18 开启 bbr&lt;/h3&gt;
&lt;p&gt;开启bbr后，网速会更快 ，具体是为什么不知道，网上查的&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;echo &amp;quot;net.core.default_qdisc=fq&amp;quot; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &amp;quot;net.ipv4.tcp_congestion_control=bbr&amp;quot; &amp;gt;&amp;gt; /etc/sysctl.conf
sysctl -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sysctl net.ipv4.tcp_available_congestion_control
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示以下即已开启：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.tcp_available_congestion_control = bbr cubic reno&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看BBR是否启动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lsmod | grep bbr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;显示以下即启动成功：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tcp_bbr                20480  14&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="-"&gt;添加新用户&lt;/h3&gt;
&lt;p&gt;不能每次都用root登录，应添加新用户，最好跟本地计算机相同用户名，这样就可以省略每次输入用户名了&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;adduser nshen  # 自动创建对应的组，并设置密码
passwd nshen # 重设密码
usermod -aG sudo nshen # 添加到sudo用户组，就可以使用sudo命令了
exit # 退出登录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新连接ssh，如果跟本机同名则可以直接 &lt;code&gt;ssh ip&lt;/code&gt; 输入密码就行了&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;whoami #我是谁
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="copy-public-key"&gt;copy public key&lt;/h4&gt;
&lt;p&gt;把本地&lt;code&gt;public key&lt;/code&gt;上传到服务器后，每次ssh会匹配我本机的&lt;code&gt;private key&lt;/code&gt;，这样就不用每次输入密码那么麻烦了&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;exit # 回到本地
ssh-copy-id -i /home/nshen/.ssh/id_rsa nshen@my-server-ip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后一路yes，再次ssh连接就不需要输入密码了&lt;/p&gt;
&lt;h3 id="-ssh-"&gt;改ssh设置&lt;/h3&gt;
&lt;p&gt;这步&lt;strong&gt;可选&lt;/strong&gt;，可以禁止root登录，或更改ssh端口，让系统更安全&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim /etc/ssh/sshd_config&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;找到这两行&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;PermitRootLogin yes
Port 22
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如遇到ssh连接总自己断开，可以&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;# 添加
ClientAliveInterval 30
ClientAliveCountMax 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="docker-ce"&gt;Docker CE&lt;/h3&gt;
&lt;p&gt;Docker的出现对我这种新手来说最大的好处就是可以不怕把系统搞坏，需要什么软件的时候直接查docker的版本安装就好了。&lt;/p&gt;
&lt;p&gt;Docker 首页好像很难找到免费版本的链接了，要搜 &lt;code&gt;docker-ce&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/"&gt;https://docs.docker.com/install/linux/docker-ce/ubuntu/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最简单的安装方式是脚本安装&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加用户到docker组&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sudo usermod -aG docker nshen
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="docker-compose"&gt;docker compose&lt;/h4&gt;
&lt;p&gt;官网: &lt;a href="https://docs.docker.com/compose/install/"&gt;https://docs.docker.com/compose/install/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最简单脚本安装&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sudo curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version #是否安装成功
docker-compose version 1.25.4, build 1110ad01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试一下&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;mkdir -p ~/fig/shadowsocks/
cd ~/fig/shadowsocks/
curl -sSLO https://github.com/shadowsocks/shadowsocks-libev/raw/master/docker/alpine/docker-compose.yml
vim docker-compose.yml # 配置参数
sudo docker-compose up -d # 启动
sudo docker-compose ps # 查看状态
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>敏捷革命，终结996的工作方式</title>
    <id>http://nshen.net/article/2020-01-29/scrum</id>
    <link href="http://nshen.net/article/2020-01-29/scrum"/>
    <updated>2020-01-29T18:37:00.000Z</updated>
    <content>&lt;p&gt;作为一个中年宅男，我总想把有限生命用来多看些东西，多写些代码，只与电脑打交道，避免与人打交道，对团队管理方式什么的基本不懂，总觉得&lt;strong&gt;管理别人&lt;/strong&gt;就是&lt;strong&gt;浪费自己&lt;/strong&gt;的时间，我更喜欢在别人的管理（关爱）下，毫无顾虑的写代码。 不过最近从朋友口中听到了敏捷开发的概念，就从京东凑单了一本&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/scrum/scrum.jpg" alt="scrum"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《敏捷革命：提升个人创造力与企业效率的全新协作模式》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这本书里有一个研究是说，一个厉害程序员的效率可能是一个差的程序员效率的&lt;strong&gt;10 倍&lt;/strong&gt;，但一个好的团队与一个差的团队之间的效率差距可以达到 &lt;strong&gt;2000 倍&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;也就是说即使把团队里所有的程序员都换成最牛逼的，也只能提升10倍效率，但如果可以把团队合作改进一点点的话，则在效率上会有非常大的提升。&lt;/p&gt;
&lt;p&gt;虽然我本身对团队管理方法相关的东西不感冒，但回想过去10多年的程序员生涯里，我加入过很多团队，有高大上的外企，也有小黑屋式黑作坊，遇到过特别好的领导，也见过非常蠢的。见识过各种各样的管理方式，可惜始终没有机会加入一个特别高效的敏捷团队。&lt;/p&gt;
&lt;p&gt;其实也不意外，目前全中国最有钱的公司如阿里腾讯，他们理应有最厉害的管理人才，可是也在奉行996的管理方式，以办公楼半夜还灯火通明为荣。先不说996是好是坏，在生理上，一个人一天的精力是有限的，强行把这个精力拉长到12小时，就注定是低效率的。作为硬件的身体撑12小时一般人还是可以的，但让大脑这个软件连续工作12小时是不现实的，这种低效率的开发方式与敏捷开发是相悖的。这本书第五章里有一节的标题就是&lt;code&gt;工时越长，效率越低&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;...工作时间太长的人会开始犯错，正如我们先前提到的那样，改正错误可能会比创造新成绩花费更多的时间。工作超出负荷的员工比较不容易集中注意力，而且会影响别人也跟着分心，不久之后他们就会开始做出错误的决策。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我之前实验过番茄工作法，番茄工作法要求在工作时完全投入，测试下来，我每天平均能完成10个番茄钟已经谢天谢地非常满意了，不管那天在电脑前坐多久，我自己统计的每天有效工作大概都在10个番茄钟以内，一般只有8个。现在看到书中这个图，跟我认知也差不多，单纯的增加工作时长，并不能完成更多的工作量，反而会更少。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/scrum/scrum2.jpg" alt="工时减半，产出倍增"&gt;&lt;/p&gt;
&lt;p&gt;就像本书原版书名《The Art of Doing Twice the Work in Half the Time》（《事半功倍的艺术》）一样，我觉得所有的管理者都应该仔细学习学习敏捷开发方法，努力提高效率，把工时减半，避免进入无限延长工作时间的误区中。这本书中有大量转为使用敏捷开发而使项目成功的例子参考。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Scrum 方法要求参与者摒弃哪中只衡量工时的思维，因为工时只代表着一种成本。相反，我们应该更多的关注产出。为什么要关注一个人用多久才完成一项任务呢？只要关注完成任务的速度和质量就足够了，这才是唯一重要的事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那什么是敏捷开发呢？&lt;/p&gt;
&lt;p&gt;敏捷开发其实很简单，在 youtube 上搜一下 &lt;code&gt;scrum&lt;/code&gt; 关键字，会有一个7分钟和一个10分钟解释敏捷开发的视频，已经把敏捷开发解释的很明白了。&lt;/p&gt;
&lt;p&gt;敏捷开发是相对于传统&lt;strong&gt;瀑布流式开发&lt;/strong&gt;而提出的，瀑布流式开发是指预先把项目整体规划好，然后根据一步一步开发的模式。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/scrum/waterfall.png" alt="waterfall"&gt;&lt;/p&gt;
&lt;p&gt;而敏捷开发是免去了人类不擅长的规划步骤，先做出一个最小可用版本，然后不断重复增量迭代的开发方式，下图中每一列就是一次迭代&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/scrum/scrum.png" alt="scrum"&gt;&lt;/p&gt;
&lt;p&gt;每一次迭代起名叫做一个冲刺（&lt;code&gt;sprint&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/scrum/sprints.png" alt="sprints"&gt;&lt;/p&gt;
&lt;p&gt;一个冲刺（&lt;code&gt;sprint&lt;/code&gt;） 是一个短期的里程碑，通常在 1 ~ 4 周内。&lt;/p&gt;
&lt;p&gt;在一个敏捷开发项目里，有3个角色&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产品负责人&lt;/li&gt;
&lt;li&gt;敏捷大师&lt;/li&gt;
&lt;li&gt;团队&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="/image/scrum/roles.png" alt="sprints"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品负责人&lt;/strong&gt;负责告诉团队“做什么”，而&lt;strong&gt;敏捷大师&lt;/strong&gt;负责告诉团队“怎么做”。&lt;/p&gt;
&lt;p&gt;具体流程来讲，&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;产品负责人&lt;/strong&gt;是最了解客户需求的人，所以他来负责拟定一份可能进入最终产品的产品的功能需求清单（&lt;code&gt;product backlog&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;敏捷大师&lt;/strong&gt;召集大家发起第一次会议，冲刺准备会议（&lt;code&gt;sprint planning&lt;/code&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;决定哪些需求可以进入这次的冲刺&lt;/li&gt;
&lt;li&gt;&lt;p&gt;评估需求的难度&lt;/p&gt;
&lt;p&gt; 人类不善于评估任务时间，但可以分清任务难度，以最简单的任务为基准，使用斐波那契数字给每个任务一个评分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最终输出一份本次冲刺&lt;strong&gt;用户故事&lt;/strong&gt;清单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户故事&lt;/strong&gt; 就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为&lt;strong&gt;_&lt;/strong&gt;，我想要&lt;strong&gt;_&lt;/strong&gt;，所以&lt;strong&gt;_&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;AS a ( role ), I want ( feature ), so that ( benefit )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="/image/scrum/user_stroies.png" alt="用户故事"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3）正式进入冲刺阶段，&lt;strong&gt;团队&lt;/strong&gt;开始开发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个冲刺通常持续 1 ~ 3 周&lt;/li&gt;
&lt;li&gt;工作透明化，用白板记录，确保了解所有人都在干什么&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每天早上有15分钟的每日站会，团队成员轮流回答&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你昨天做了什么去帮助团队完成冲刺？&lt;/li&gt;
&lt;li&gt;今天打算做什么来帮助团队完成冲刺？&lt;/li&gt;
&lt;li&gt;&lt;p&gt;遇到什么阻碍？&lt;/p&gt;
&lt;p&gt;注意任务不是自上而下的，而是自主决定自主完成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每天更新燃尽图，统计完成进度&lt;/p&gt;
&lt;p&gt;4）完成一次冲刺，&lt;strong&gt;敏捷大师&lt;/strong&gt;召集大家开冲刺回顾会议（sprint review）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把完成的功能给&lt;strong&gt;产品负责人&lt;/strong&gt;看，不展示成果，就没有效果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意在流程改进上，不要责备某个人&lt;/p&gt;
&lt;p&gt; 每个人都是制度的产物，scrum方法会承认和接受这个现实，进而审视导致失败的制度，而不是非要找出一个人来承担责任&lt;/p&gt;
&lt;p&gt;5）跳回 &lt;code&gt;2）&lt;/code&gt; 循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结敏捷开发中的3个角色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/scrum/roles2.png" alt="sprints"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结敏捷开发的3次会议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/scrum/meeting.png" alt="scrum meeting"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结整个流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/scrum/workflow.png" alt="scrum workflow"&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>CodingBlog：给程序员的私房极简博客系统</title>
    <id>http://nshen.net/project/2017-09-04/new-blog</id>
    <link href="http://nshen.net/project/2017-09-04/new-blog"/>
    <updated>2017-09-04T00:00:00.000Z</updated>
    <content>&lt;p&gt;对，就是你现在看到的这个跟我同款的博客，如果你喜欢的话，请去给我点个赞，谢谢 --&amp;gt; &lt;a href="https://github.com/nshen/coding-blog"&gt;CodingBlog@Github&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我之前在使用 &lt;code&gt;Hexo&lt;/code&gt; 博客，觉得还不错，但是换过几个皮肤都有不满意的地方，有些皮肤在半墙的状态加载缓慢，有些有我无法接受的css炫酷动画，还有些中文排版很差，有些排版不错，但首页大图就占了半屏，我实在不能理解。喜欢简洁的我本想基于默认皮肤自定义一个，发现默认皮肤只是外表简洁，内部有几十个 ejs 模板文件，和20多个 css 文件，需要预编译。作为一个前端新手实在有点不知道怎么下手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我看来这个级别的个人博客，一个 &lt;code&gt;header&lt;/code&gt; 一个 &lt;code&gt;footer&lt;/code&gt; 就足够个性化自定义了，中间应该全部程序生成。&lt;/p&gt;
&lt;p&gt;之后我就在网上搜索有什么其他更简洁的博客系统满足我的喜好，然后就发现了 Metalsmith。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/codinglog/metalsmith.png" alt="metalsmith"&gt;&lt;/p&gt;
&lt;h2 id="metalsmith"&gt;Metalsmith&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.metalsmith.io/"&gt;Metalsmith&lt;/a&gt; 是一个基于插件的文档生成器，本身基本不做任何事，只遍历文件夹中的文件，并把他们交给插件来处理，处理完再存成新文件。一般建站常见的任务，已有无数的第三方插件可以帮你做，比如需要&lt;code&gt;markdown&lt;/code&gt;就有&lt;code&gt;metalsmith-markdown&lt;/code&gt;插件，需要&lt;code&gt;sitemap&lt;/code&gt;就有对应的&lt;code&gt;metalsmith-sitemap&lt;/code&gt;插件，也可以自定义插件加入构建流。&lt;/p&gt;
&lt;p&gt;正好我想练习一下&lt;code&gt;div + css&lt;/code&gt;，所以我决定试试手，基于MetalSmith打造一个程序员专用的极简博客系统。&lt;/p&gt;
&lt;h2 id="-"&gt;极简的博客&lt;/h2&gt;
&lt;p&gt;我的目标：&lt;/p&gt;
&lt;p&gt;极简干净，默认无图无动画，加载快，方便个性化修改，作为个人学习实践的发布平台。&lt;/p&gt;
&lt;p&gt;简而不漏，作为程序员专用的博客，这里有一些我想到的&lt;strong&gt;需求&lt;/strong&gt;需要实现：&lt;/p&gt;
&lt;h2 id="-"&gt;纯静态无服务器依赖&lt;/h2&gt;
&lt;p&gt;无服务器依赖肯定要摆在需求第一位的，不能像10多年前一样用&lt;code&gt;asp博客&lt;/code&gt;就要去租&lt;code&gt;asp虚拟主机&lt;/code&gt; 过几天大家都用&lt;code&gt;wordpress&lt;/code&gt;了，又要去租&lt;code&gt;php主机&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在的标准是 &lt;strong&gt;随便扔在什么免费的地方都能运行，绑定个域名就能用了。&lt;/strong&gt; 今天放&lt;code&gt;Github&lt;/code&gt;上，明天放&lt;code&gt;Coding&lt;/code&gt;上，后天放&lt;code&gt;oschina&lt;/code&gt;上，实在不行放自己路由器上也能访问。&lt;/p&gt;
&lt;h2 id="markdown-"&gt;Markdown标准&lt;/h2&gt;
&lt;p&gt;当年我写博客时，仅流行的ASP博客就有 &lt;code&gt;L-Blog&lt;/code&gt; ，&lt;code&gt;LBS&lt;/code&gt;，&lt;code&gt;Z-Blog&lt;/code&gt;，&lt;code&gt;PJBlog&lt;/code&gt;。。。等等。有些作者停更了，有些出bug了，或者某天又出更漂亮更强大的博客系统了，每次要换博客时各种博客系统，各种版本之间导数据别提多烦了。好在近几年出现了&lt;code&gt;Markdown&lt;/code&gt;标准。&lt;/p&gt;
&lt;p&gt;现在几乎所有的文档生成器都支持Markdown了，也就是说，如果你的博客是用Markdown写的，不再需要数据库，而且换博客程序时基本上再也不用各种转数据了。&lt;/p&gt;
&lt;h3 id="markdown-"&gt;Markdown书写环境&lt;/h3&gt;
&lt;p&gt;既然是程序员专用，我是推荐在 &lt;a href="https://code.visualstudio.com"&gt;VSCode&lt;/a&gt; 里直接写博客的&lt;/p&gt;
&lt;p&gt;像插入链接图片什么的都是有语法提示的，忘了语法也没关系&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/codinglog/snippets.png" alt="alt"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint"&gt;markdownlint&lt;/a&gt; 这个lint插件可以实时告诉你哪些markdown格式有错误，让你更专注书写，而不用时时去检查错误。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles"&gt;Markdown Preview Github Styling&lt;/a&gt; 插件，让你用&lt;code&gt;Github&lt;/code&gt;的风格实时预览&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/codinglog/github_preview.png" alt="github preview"&gt;&lt;/p&gt;
&lt;p&gt;最好写完博客 &lt;code&gt;Ctrl + Shift + B&lt;/code&gt; (run build task) 直接就把博客 build 出来。&lt;/p&gt;
&lt;h2 id="-"&gt;代码高亮&lt;/h2&gt;
&lt;p&gt;硬需求，必须得支持，比较流行的高亮库有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://highlightjs.org/"&gt;highlight.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://prismjs.com/"&gt;Prism.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;据说后者好看一点，JavaScript 的创始人也在用&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;function Greeter(greeting) {
    this.greeting = greeting;
}

Greeter.prototype.greet = function() {
    return &amp;quot;Hello, &amp;quot; + this.greeting;
}

// Oops, we&amp;#39;re passing an object when we want a string. This will print
// &amp;quot;Hello, [object Object]&amp;quot; instead of &amp;quot;Hello, world&amp;quot; without error.
let greeter = new Greeter({message: &amp;quot;world&amp;quot;});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;中文排版干净舒服&lt;/h2&gt;
&lt;p&gt;不要求过分漂亮，但起码看起来要干净舒服，文字要清晰。有些程序员的博客还在用楷体，其审美真是受不了，主观问题不多说，直接向&lt;code&gt;Github&lt;/code&gt;看齐就好，毕竟大家普遍觉得他的还不错。&lt;/p&gt;
&lt;p&gt;我先使用了国际通用的&lt;code&gt;css reset&lt;/code&gt;库叫做 &lt;a href="https://necolas.github.io/normalize.css/"&gt;normalize.css&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;又找到一个css库就叫做 &lt;a href="https://github.com/sindresorhus/github-markdown-css"&gt;github-markdown-css&lt;/a&gt; 太棒了直接用起来就好了！&lt;/p&gt;
&lt;h2 id="-"&gt;搜索引擎友好&lt;/h2&gt;
&lt;p&gt;如果你不是个明星程序员，那么注定流量大部分来自于搜索引擎，所以千万不要忽略SEO的重要性&lt;/p&gt;
&lt;p&gt;下边是一篇 &lt;code&gt;Markdown&lt;/code&gt; 博客开头加入的 &lt;code&gt;YAML&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-markdown"&gt;---
title: CodingBlog：给程序员的私房极简博客系统
date: 2017-09-01
tags: Markdown,文档
description: 这是一篇介绍CodingBlog博客是如何实现的文章
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我希望生成对应的HTML是这样的，博客的 &lt;code&gt;tag&lt;/code&gt; ，正好对应搜索引擎需要的 &lt;code&gt;keywords&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;title&amp;gt; CodingBlog：给程序员的私房极简博客系统 | CodingBlog&amp;lt;/title&amp;gt;
&amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;这是一篇介绍CodingBlog博客是如何实现的文章&amp;quot;&amp;gt;
&amp;lt;meta name=&amp;quot;keywords&amp;quot; content=&amp;quot;Markdown,文档&amp;quot;&amp;gt;
&amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;Nshen &amp;lt;nshen121@gmail.com&amp;gt;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后 Sitemap 和 feed 也是少不了的。&lt;/p&gt;
&lt;h2 id="-1080p-"&gt;响应式，1080p优先&lt;/h2&gt;
&lt;p&gt;根据我的后台统计，作为一个独立博客，不会是mobile优先，大部分流量还是来自大屏，所以优先给他们最好的显示效果&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/codinglog/1920.png" alt="1080p优先"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;header&lt;/code&gt;在小屏幕下应该是响应式的，有 mobile 和 pad 两种尺寸。&lt;/p&gt;
&lt;h2 id="-"&gt;社交分享&lt;/h2&gt;
&lt;p&gt;找到一个叫做 &lt;a href="https://github.com/overtrue/share.js"&gt;share.js&lt;/a&gt; 的库，如下图看起来不错，用起来&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/codinglog/share.png" alt="share.js"&gt;&lt;/p&gt;
&lt;h2 id="-git-wiki"&gt;与git配合替代云笔记或wiki&lt;/h2&gt;
&lt;p&gt;我在看文档或pdf的时候，习惯记一些笔记，或用wiki的形式整理一些链接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;evernote&lt;/code&gt; ， &lt;code&gt;网易云笔记&lt;/code&gt; ， &lt;code&gt;为知笔记&lt;/code&gt; 云笔记换了又换，总有这样那样的不足。&lt;/p&gt;
&lt;p&gt;为什么不在博客里加个云笔记&lt;strong&gt;私密目录&lt;/strong&gt;呢，可以把&lt;strong&gt;私密目录&lt;/strong&gt;绑定到一个私有git库(&lt;code&gt;coding&lt;/code&gt;或&lt;code&gt;oschina&lt;/code&gt;免费)，在&lt;strong&gt;私密目录&lt;/strong&gt;里边的文件不会 build 到最终网站上。但会随着我们的私有库进行版本管理，就跟云笔记一样了。如果草稿完成，可以手动移到src目录里，则会根据需求参与 build ，生成一篇日志或者一个独立网页了。&lt;/p&gt;
&lt;p&gt;详细博客目录是这样设计的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myblog
  |
  |----- build/  // 生成的网站目录
  |----- src/    // markdown文章目录
  |----- note/   // 私密目录
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;myblog&lt;/code&gt; 是整个博客程序的目录，可以整个把这个目录git同步到一个免费的私有库中，但会&lt;code&gt;.gitignore&lt;/code&gt;过滤掉&lt;code&gt;build&lt;/code&gt;目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build&lt;/code&gt;目录就是生成的整个网站，我使用chrome的插件 &lt;a href="https://github.com/kzahel/web-server-chrome"&gt;web-server-chrome&lt;/a&gt; 绑定在这个目录，就可以直接在本地chrome中预览生成的网站了&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/codinglog/server.png" alt="web-server-chrome"&gt;&lt;/p&gt;
&lt;p&gt;同时，这个&lt;code&gt;build&lt;/code&gt;目录也是一个&lt;code&gt;git&lt;/code&gt;目录，同步在 public 的&lt;code&gt;Github Pages&lt;/code&gt; 或 &lt;code&gt;Coding Pages&lt;/code&gt; 上，进入该目录，&lt;code&gt;push&lt;/code&gt; 一下，就直接传到外网了，别人就可以访问了，超级方便。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt; 目录则是所有博客&lt;code&gt;.md&lt;/code&gt;文件放的地方，如果我要写博客，直接用&lt;code&gt;VSCode&lt;/code&gt;打开这个目录，这个目录里的子目录就是博客的分类，在相应的子目录里新建一个&lt;code&gt;.md&lt;/code&gt;文件就可以写了，而且用&lt;code&gt;VSCode&lt;/code&gt;打开&lt;code&gt;src&lt;/code&gt;目录，会非常干净，不会误操作目录外的其他文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;note&lt;/code&gt; 目录是草稿或者是代替云笔记或wiki的&lt;strong&gt;私密目录&lt;/strong&gt;的目录，在里边的文件不会 build 到最终网站上。但会随着我们的私有库进行版本管理，就跟云笔记一样了。如果草稿完成，可以手动移到&lt;code&gt;src&lt;/code&gt;目录里，生成一篇日志或生成一篇独立类似wiki的网页。&lt;/p&gt;
&lt;h2 id="-tags"&gt;分类与 tags&lt;/h2&gt;
&lt;p&gt;我根据个人的需求，默认将内容分为两类，&lt;strong&gt;article&lt;/strong&gt; 和 &lt;strong&gt;project&lt;/strong&gt; （其实就是两个文件夹），article 分类下可以放一些学习或读书笔记，project 分类下可以放一些我做的小项目。&lt;/p&gt;
&lt;p&gt;其他详细的类别，全部通过加 &lt;code&gt;tag&lt;/code&gt; 的方式实现，比如 &lt;code&gt;JavaScript&lt;/code&gt; 相关的文章可以加 &lt;code&gt;JavaScript&lt;/code&gt; 的 &lt;code&gt;tag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之后访问下边的链接，会列出所有带&lt;code&gt;JavaScript&lt;/code&gt;标签的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://nshen.net/tags/#JavaScript"&gt;http://nshen.net/tags/#JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="-"&gt;总结&lt;/h2&gt;
&lt;p&gt;我尝试实现了上边提到的功能，好像有些简陋，但暂时个人觉得已经够用了。&lt;br&gt;代码已经上传到github上了，如果你想跟我使用同款的博客，请到戳下边的链接进去看看，会有使用说明。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nshen/coding-blog"&gt;CodingBlog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得哪里不爽，或是功能太少，欢迎帮我完善，代码很简单而且有注释。&lt;/p&gt;
&lt;p&gt;如果可以的话，请进去加个star，谢谢。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>给自学游戏和图形开发者的数学符号指南</title>
    <id>http://nshen.net/article/2016-03-10/math-as-code</id>
    <link href="http://nshen.net/article/2016-03-10/math-as-code"/>
    <updated>2016-03-10T10:10:00.000Z</updated>
    <content>&lt;p&gt;之前补数学知识的时候，看到数学符号就头大，前几天在Github上发现了这篇文章，尝试翻译了一下，现在全文贴到这里。&lt;/p&gt;
&lt;p&gt;由于原文会持续更新，可以到我的github上watch这个项目，我会随原文进行更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/nshen/math-as-code/blob/master/README-zh.md"&gt;https://github.com/nshen/math-as-code/blob/master/README-zh.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正文：&lt;/p&gt;
&lt;!--more--&gt; 
&lt;h1 id="math-as-code"&gt;math-as-code&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;译注：译者英文与数学水平都非常有限，尝试翻译，如有错误请指正。&lt;a href="./README.md"&gt;英文原版&lt;/a&gt; 在此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一份通过对比数学符号和JavaScript代码来帮助开发者更容易了解数学符号的参考。&lt;/p&gt;
&lt;p&gt;动机:学术论文可能会吓着自学游戏和图形的程序猿:)&lt;/p&gt;
&lt;p&gt;这个指南还没有完成。如果你发现错误或者想要贡献，请&lt;a href="https://github.com/Jam3/math-as-code/issues"&gt;open a ticket&lt;/a&gt;或发一个 PR。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： 简洁起见，有些代码示例使用了&lt;a href="https://www.npmjs.com/"&gt;npm 包&lt;/a&gt;。你可以到他们的GitHub repos来查看实现的详细情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="-"&gt;前言&lt;/h1&gt;
&lt;p&gt;数学符号可以表示不同的意思，这取决于作者，上下文和所学习的领域（线性代数，集合理论，等等）。这份指南也许不会涵盖符号的&lt;em&gt;所有&lt;/em&gt;用法。在某些情况，会引用一些真实材料（博客文章,出版物等等）来演示某个符号的实际用法。&lt;/p&gt;
&lt;p&gt;更完整的列表，请看&lt;a href="https://en.wikipedia.org/wiki/List_of_mathematical_symbols"&gt;Wikipedia - List of Mathematical Symbols&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;简单起见，这里许多的代码示例都操作浮点数值，并不是数字健壮的（numerically robust）。为什么这会是一个问题的更多细节请看&lt;a href="https://github.com/mikolalysenko/robust-arithmetic-notes"&gt;Robust Arithmetic Notes&lt;/a&gt; 作者是 Mikola Lysenko。&lt;/p&gt;
&lt;h1 id="-"&gt;目录&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#variable-name-conventions"&gt;变量名约定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#equals-symbols"&gt;等号 &lt;code&gt;=&lt;/code&gt; &lt;code&gt;≈&lt;/code&gt; &lt;code&gt;≠&lt;/code&gt; &lt;code&gt;:=&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#square-root-and-complex-numbers"&gt;平方根与复数 &lt;code&gt;√&lt;/code&gt; &lt;em&gt;&lt;code&gt;i&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#dot--cross"&gt;点 &amp;amp; 叉 &lt;code&gt;·&lt;/code&gt; &lt;code&gt;×&lt;/code&gt; &lt;code&gt;∘&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#scalar-multiplication"&gt;标量乘法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vector-multiplication"&gt;向量乘法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#dot-product"&gt;点乘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#cross-product"&gt;叉乘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#sigma"&gt;西格玛 &lt;code&gt;Σ&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;求和&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#capital-pi"&gt;大写 Pi &lt;code&gt;Π&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;序列的积&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pipes"&gt;管道 &lt;code&gt;||&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#absolute-value"&gt;绝对值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#euclidean-norm"&gt;欧几里得模&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#determinant"&gt;行列式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#hat"&gt;帽子 &lt;strong&gt;&lt;code&gt;â&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; - &lt;em&gt;单位向量&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#element"&gt;&amp;quot;属于&amp;quot; &lt;code&gt;∈&lt;/code&gt; &lt;code&gt;∉&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#common-number-sets"&gt;常见数字集 &lt;code&gt;ℝ&lt;/code&gt; &lt;code&gt;ℤ&lt;/code&gt; &lt;code&gt;ℚ&lt;/code&gt; &lt;code&gt;ℕ&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#function"&gt;函数 &lt;code&gt;ƒ&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#piecewise-function"&gt;分段函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#common-functions"&gt;通用函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#function-notation"&gt;函数符号 &lt;code&gt;↦&lt;/code&gt; &lt;code&gt;→&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#prime"&gt;撇号 &lt;code&gt;′&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#floor--ceiling"&gt;向下取整和向上取整（floor &amp;amp; ceiling） &lt;code&gt;⌊&lt;/code&gt; &lt;code&gt;⌉&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#arrows"&gt;箭头&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#material-implication"&gt;实质蕴含（material implication） &lt;code&gt;⇒&lt;/code&gt; &lt;code&gt;→&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#equality"&gt;等式 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;≥&lt;/code&gt; &lt;code&gt;≫&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#conjunction--disjunction"&gt;与 &amp;amp; 或 &lt;code&gt;∧&lt;/code&gt; &lt;code&gt;∨&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#logical-negation"&gt;逻辑非 &lt;code&gt;¬&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#intervals"&gt;区间（intervals）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#more"&gt;更多...&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;变量名约定&lt;/h2&gt;
&lt;p&gt;有很多命名约定取决于上下文和所学领域，他们并不太一致。然而在一些文献中你会发现变量名遵循一些模式，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;s&lt;/em&gt; - 斜体小写字母用做标量 （例如一个数字）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;x&lt;/strong&gt; - 粗体小写字母用做向量 （例如一个2D点）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt; - 粗体大写字母用做矩阵 （例如一个3D变换）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;θ&lt;/em&gt; - 斜体小写希腊字母用做常量和特殊变量 （例如 &lt;a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system"&gt;欧拉角 &lt;em&gt;θ&lt;/em&gt;, &lt;em&gt;theta&lt;/em&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本指南也基于这个格式。&lt;/p&gt;
&lt;h2 id="-"&gt;等号&lt;/h2&gt;
&lt;p&gt;有很多符号很像等号 &lt;code&gt;=&lt;/code&gt; 。这里有些常见的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 表示相等 （值相同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;≠&lt;/code&gt; 表示不相等 （值不同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;≈&lt;/code&gt; 表示约等于 （&lt;code&gt;π ≈ 3.14159&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:=&lt;/code&gt; 表示定义 （A 被定义为 B）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 JavaScript 中:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 相等
2 === 3

// 不相等
2 !== 3

// 约等于
almostEqual(Math.PI, 3.14159, 1e-5)

function almostEqual(a, b, epsilon) {
  return Math.abs(a - b) &amp;lt;= epsilon
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也许看过 &lt;code&gt;:=&lt;/code&gt;， &lt;code&gt;=:&lt;/code&gt; 和 &lt;code&gt;=&lt;/code&gt; 符号用来表示 &lt;em&gt;定义&lt;/em&gt;。&lt;sup&gt;&lt;a href="http://mimosa-pudica.net/improved-oren-nayar.html#images"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;例如，下边定义 &lt;em&gt;x&lt;/em&gt; 为 2&lt;em&gt;kj&lt;/em&gt; 的别名。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?x%20%3A%3D%202kj" alt="equals1"&gt;&lt;/p&gt;
&lt;!-- x := 2kj --&gt;
&lt;p&gt;在 JavaScript 中，我们用 &lt;code&gt;var&lt;/code&gt; 来 &lt;em&gt;定义&lt;/em&gt; 变量和提供别名：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var x = 2 * k * j
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，这里的x值是可变的，仅是当时的一个快照。在某些有预处理器语言中的 &lt;code&gt;#define&lt;/code&gt; 语句才比较接近于数学中的 &lt;em&gt;定义&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;在JavaScript (ES6) 中，更精确的 &lt;em&gt;定义&lt;/em&gt; ，应该有点类似这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const f = (k, j) =&amp;gt; 2 * k * j
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与此不同的是，下边这句表示的是相等：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?x%20%3D%202kj" alt="equals2"&gt;&lt;/p&gt;
&lt;!-- x = 2kj --&gt;
&lt;p&gt;上边的等式也可以解释为一个 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/console/assert"&gt;断言&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;console.assert(x === (2 * k * j))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;平方根与复数&lt;/h2&gt;
&lt;p&gt;一个平方根运算是这种形式:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cleft%28%5Csqrt%7Bx%7D%5Cright%29%5E2%20%3D%20x" alt="squareroot"&gt;&lt;/p&gt;
&lt;!-- \left(\sqrt{x}\right)^2 = x --&gt;
&lt;p&gt;在编程语言中我们使用 &lt;code&gt;sqrt&lt;/code&gt; 函数， 像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var x = 9;
console.log(Math.sqrt(x));
//=&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复数是 &lt;img src="http://latex.codecogs.com/svg.latex?a&amp;space;&amp;plus;&amp;space;ib" alt="complex"&gt; 形式的表达式， 其中 &lt;img src="http://latex.codecogs.com/svg.latex?a" alt="a"&gt; 是实数部分， &lt;img src="http://latex.codecogs.com/svg.latex?b" alt="b"&gt; 是虚数部分。 虚数 &lt;img src="http://latex.codecogs.com/svg.latex?i" alt="i"&gt; 的定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?i%3D%5Csqrt%7B-1%7D" alt="imaginary"&gt;.&lt;br&gt;&lt;!-- i=\sqrt{-1} --&gt;&lt;/p&gt;
&lt;p&gt;JavaScript没有内置复数的功能，但有一些库支持复数算法。例如， &lt;a href="https://www.npmjs.com/package/mathjs"&gt;mathjs&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var math = require(&amp;#39;mathjs&amp;#39;)

var a = math.complex(3, -1)
//=&amp;gt; { re: 3, im: -1 }

var b = math.sqrt(-1)
//=&amp;gt; { re: 0, im: -1 }

console.log(math.multiply(a, b).toString())
//=&amp;gt; &amp;#39;1 + 3i&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个库还支持字符串表达式求值， 所以上边的可以写为：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;console.log(math.eval(&amp;#39;(3 - i) * i&amp;#39;).toString())
//=&amp;gt; &amp;#39;1 + 3i&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.npmjs.com/package/immutable-complex"&gt;immutable-complex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.npmjs.com/package/complex-js"&gt;complex-js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.numericjs.com/"&gt;Numeric-js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;点 &amp;amp; 叉&lt;/h2&gt;
&lt;p&gt;点 &lt;code&gt;·&lt;/code&gt; 和叉 &lt;code&gt;×&lt;/code&gt; 符号根据上下文的不同有不同的用法。&lt;/p&gt;
&lt;p&gt;他们可能看上去很明显，但在进入下一部分之前，理解他们之间微妙的不同是非常重要的。&lt;/p&gt;
&lt;h4 id="-"&gt;标量乘法&lt;/h4&gt;
&lt;p&gt;两个符号都可以表示简单的标量之间的乘法。下边的写法意思相同：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?5%20%5Ccdot%204%20%3D%205%20%5Ctimes%204" alt="dotcross1"&gt;&lt;/p&gt;
&lt;!-- 5 \cdot 4 = 5 \times 4 --&gt;
&lt;p&gt;在编程语言中，我们倾向用星号表示相乘：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var result = 5 * 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常，使用乘法符号只是为了避免意义模糊（例如两个数字之间的）。这里，我们可以完全省略：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?3kj" alt="dotcross2"&gt;&lt;/p&gt;
&lt;!-- 3kj --&gt;
&lt;p&gt;如果这些变量表示的是标量，则代码应该这样写:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var result = 3 * k * j
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-"&gt;向量乘法&lt;/h4&gt;
&lt;p&gt;表示向量和标量之间相乘，或两向量的逐元素相乘（element-wise multiplication），我们不用点 &lt;code&gt;·&lt;/code&gt; 或叉 &lt;code&gt;×&lt;/code&gt; 符号。 这些符号在线性代数中有不同的意思，后边讨论。&lt;/p&gt;
&lt;p&gt;让我们用之前的例子，但用在向量上。对于向量的逐元素相乘（element-wise vector multiplication）来说，你可能会看到用一个空心点来表示 &lt;a href="https://en.wikipedia.org/wiki/Hadamard_product_%28matrices%29"&gt;Hadamard product&lt;/a&gt;。&lt;sup&gt;&lt;a href="http://buzzard.ups.edu/courses/2007spring/projects/million-paper.pdf"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?3%5Cmathbf%7Bk%7D%5Ccirc%5Cmathbf%7Bj%7D" alt="dotcross3"&gt;&lt;/p&gt;
&lt;!-- 3\mathbf{k}\circ\mathbf{j} --&gt;
&lt;p&gt;某些时候，作者可能会显式定义一个不同的符号，例如圆中点 &lt;code&gt;⊙&lt;/code&gt; 或实心圈 &lt;code&gt;●&lt;/code&gt; 。&lt;sup&gt;&lt;a href="https://www.math.washington.edu/~morrow/464_12/fft.pdf"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;这是对应的代码，使用数组 &lt;code&gt;[x, y]&lt;/code&gt; 来表示2D向量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var s = 3
var k = [ 1, 2 ]
var j = [ 2, 3 ]

var tmp = multiply(k, j)
var result = multiplyScalar(tmp, s)
//=&amp;gt; [ 6, 18 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;multiply&lt;/code&gt; 和 &lt;code&gt;multiplyScalar&lt;/code&gt; 函数应该这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function multiply(a, b) {
  return [ a[0] * b[0], a[1] * b[1] ]
}

function multiplyScalar(a, scalar) {
  return [ a[0] * scalar, a[1] * scalar ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的，矩阵相乘也不用 &lt;code&gt;·&lt;/code&gt; 或 &lt;code&gt;×&lt;/code&gt; 符号。 矩阵乘法会在后边章节提到.&lt;/p&gt;
&lt;h4 id="-"&gt;点乘&lt;/h4&gt;
&lt;p&gt;点符号 &lt;code&gt;·&lt;/code&gt; 可用来表示两向量之间的 &lt;a href="https://en.wikipedia.org/wiki/Dot_product"&gt;&lt;em&gt;点乘&lt;/em&gt;&lt;/a&gt; 。 由于其值是一个标量，通常被叫做 &lt;em&gt;标量积（scalar product）&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cmathbf%7Bk%7D%5Ccdot%20%5Cmathbf%7Bj%7D" alt="dotcross4"&gt;&lt;/p&gt;
&lt;!-- \mathbf{k}\cdot \mathbf{j} --&gt;
&lt;p&gt;这在线性代数和3D向量中是非常常见的，代码类似这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var k = [ 0, 1, 0 ]
var j = [ 1, 0, 0 ]

var d = dot(k, j)
//=&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为 &lt;code&gt;0&lt;/code&gt; 告诉我们两向量互相垂直. 这是3元素向量的 &lt;code&gt;点乘&lt;/code&gt; 函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-"&gt;叉乘&lt;/h4&gt;
&lt;p&gt;叉乘符号 &lt;code&gt;×&lt;/code&gt; 可以用来表示两向量的 &lt;a href="https://en.wikipedia.org/wiki/Cross_product"&gt;&lt;em&gt;叉乘&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cmathbf%7Bk%7D%5Ctimes%20%5Cmathbf%7Bj%7D" alt="dotcross5"&gt;&lt;/p&gt;
&lt;!-- \mathbf{k}\times \mathbf{j} --&gt;
&lt;p&gt;在代码中，应该是这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var k = [ 0, 1, 0 ]
var j = [ 1, 0, 0 ]

var result = cross(k, j)
//=&amp;gt; [ 0, 0, -1 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里得到结果为 &lt;code&gt;[ 0, 0, -1 ]&lt;/code&gt;，这个向量同时垂直于 &lt;strong&gt;k&lt;/strong&gt; 和 &lt;strong&gt;j&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;我们的叉乘 &lt;code&gt;cross&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function cross(a, b) {
  var ax = a[0], ay = a[1], az = a[2],
    bx = b[0], by = b[1], bz = b[2]

  var rx = ay * bz - az * by
  var ry = az * bx - ax * bz
  var rz = ax * by - ay * bx
  return [ rx, ry, rz ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;向量乘法，叉乘，点乘的其他实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/stackgl/gl-vec3"&gt;gl-vec3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/stackgl/gl-vec2"&gt;gl-vec2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/hughsk/vectors"&gt;vectors&lt;/a&gt; - 包含 n维实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-sigma-"&gt;西格玛（sigma）&lt;/h2&gt;
&lt;p&gt;大写希腊字母 &lt;code&gt;Σ&lt;/code&gt; (Sigma) 用来表示 &lt;a href="https://en.wikipedia.org/wiki/Summation"&gt;总和 Summation&lt;/a&gt;。 换句话说就是对一些数字求和。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Csum_%7Bi%3D1%7D%5E%7B100%7Di" alt="sigma"&gt;&lt;/p&gt;
&lt;!-- \sum_{i=1}^{100}i --&gt;
&lt;p&gt;这里, &lt;code&gt;i=1&lt;/code&gt; 是说从 &lt;code&gt;1&lt;/code&gt; 西格玛上边的数字&lt;code&gt;100&lt;/code&gt;为止。这些分别为上下边界。 &amp;quot;E&amp;quot; 右边的 &lt;em&gt;i&lt;/em&gt; 告诉我们求和的是什么。代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var sum = 0
for (var i = 1; i &amp;lt;= 100; i++) {
  sum += i
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sum&lt;/code&gt; 的结果为 &lt;code&gt;5050&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 对于整数，这个特殊形式可以优化为：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var n = 100 // 上边界
var sum = (n * (n + 1)) / 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有另一个例子，这里的 &lt;em&gt;i&lt;/em&gt; ，或 “想要求和的东西” 是不同的：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Csum_%7Bi%3D1%7D%5E%7B100%7D%282i&amp;plus;1%29" alt="sum2"&gt;&lt;/p&gt;
&lt;!-- \sum_{i=1}^{100}(2i+1) --&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var sum = 0
for (var i = 1; i &amp;lt;= 100; i++) {
  sum += (2 * i + 1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sum&lt;/code&gt; 的结果为 &lt;code&gt;10200&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个符号可被嵌套，非常像嵌套一个 &lt;code&gt;for&lt;/code&gt; 循环。 你应该先求和最右边的西格玛， 除非作者加入括号改变了顺序。然而下边的例子，由于我们处理有限的和，顺序就不重要了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Csum_%7Bi%3D1%7D%5E%7B2%7D%5Csum_%7Bj%3D4%7D%5E%7B6%7D%283ij%29" alt="sigma3"&gt;&lt;/p&gt;
&lt;!-- \sum_{i=1}^{2}\sum_{j=4}^{6}(3ij) --&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var sum = 0
for (var i = 1; i &amp;lt;= 2; i++) {
  for (var j = 4; j &amp;lt;= 6; j++) {
    sum += (3 * i * j)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;sum&lt;/code&gt; 值为 &lt;code&gt;135&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="-pi"&gt;大写 Pi&lt;/h2&gt;
&lt;p&gt;大写 Pi 或 “大Pi” 与 &lt;a href="#sigma"&gt;西格玛&lt;/a&gt; 非常接近， 不同的是我们用乘法取得一系列数字的乘积。 &lt;/p&gt;
&lt;p&gt;看下边：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cprod_%7Bi%3D1%7D%5E%7B6%7Di" alt="capitalPi"&gt;&lt;/p&gt;
&lt;!-- \prod_{i=1}^{6}i --&gt;
&lt;p&gt;代码应该类似这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var value = 1
for (var i = 1; i &amp;lt;= 6; i++) {
  value *= i
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;value&lt;/code&gt; 结果应得到 &lt;code&gt;720&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="-pipes-"&gt;管道（pipes）&lt;/h2&gt;
&lt;p&gt;管道符号，就是 &lt;em&gt;竖线（bars）&lt;/em&gt;，根据上下文不同，可以表示不同意思。下边的是3种常见用途 &lt;a href="#absolute-value"&gt;绝对值&lt;/a&gt;, &lt;a href="#euclidean-norm"&gt;欧几里得模&lt;/a&gt;, 和 &lt;a href="#determinant"&gt;行列式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这3种特性都是描述对象的 &lt;em&gt;长度（length）&lt;/em&gt; 。&lt;/p&gt;
&lt;h4 id="-"&gt;绝对值&lt;/h4&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cleft%20%7C%20x%20%5Cright%20%7C" alt="pipes1"&gt;&lt;/p&gt;
&lt;!-- \left | x \right | --&gt;
&lt;p&gt;对于数字 &lt;em&gt;x&lt;/em&gt;, &lt;code&gt;|x|&lt;/code&gt; 表示 &lt;em&gt;x&lt;/em&gt; 的绝对值。代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var x = -5
var result = Math.abs(x)
// =&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-euclidean-norm-"&gt;欧几里得模（Euclidean norm）&lt;/h4&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cleft%20%5C%7C%20%5Cmathbf%7Bv%7D%20%5Cright%20%5C%7C" alt="pipes4"&gt;&lt;/p&gt;
&lt;!-- \left \| \mathbf{v} \right \| --&gt;
&lt;p&gt;对于向量 &lt;strong&gt;v&lt;/strong&gt;， &lt;code&gt;‖v‖&lt;/code&gt; 是 &lt;strong&gt;v&lt;/strong&gt; 的&lt;a href="https://en.wikipedia.org/wiki/Norm_%28mathematics%29#Euclidean_norm"&gt;欧几里得模（Euclidean norm）&lt;/a&gt; 。也叫做向量的 &amp;quot;量级（magnitude）&amp;quot; 或 &amp;quot;长度（length）&amp;quot; 。&lt;/p&gt;
&lt;p&gt;通常用双竖线表示来避免与&lt;em&gt;绝对值&lt;/em&gt; 符号混淆，但有些时候也会看见单竖线。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cleft%20%7C%20%5Cmathbf%7Bv%7D%20%5Cright%20%7C" alt="pipes2"&gt;&lt;/p&gt;
&lt;!-- \left | \mathbf{v} \right | --&gt;
&lt;p&gt;这里的例子用数组 &lt;code&gt;[x, y, z]&lt;/code&gt; 来表示一个3D向量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var v = [ 0, 4, -3 ]
length(v)
//=&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;length&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function length (vec) {
  var x = vec[0]
  var y = vec[1]
  var z = vec[2]
  return Math.sqrt(x * x + y * y + z * z)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/mattdesl/magnitude/blob/864ff5a7eb763d34bf154ac5f5332d7601192b70/index.js"&gt;magnitude&lt;/a&gt; - n-dimensional&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/stackgl/gl-vec2/blob/21f460a371540258521fd2f720d80f14e87bd400/length.js"&gt;gl-vec2/length&lt;/a&gt; - 2D vector&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/stackgl/gl-vec3/blob/507480fa57ba7c5fb70679cf531175a52c48cf53/length.js"&gt;gl-vec3/length&lt;/a&gt; - 3D vector&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="-"&gt;行列式&lt;/h4&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cleft%20%7C%5Cmathbf%7BA%7D%20%5Cright%20%7C" alt="pipes3"&gt;&lt;/p&gt;
&lt;!-- \left |\mathbf{A}  \right | --&gt;
&lt;p&gt;对于一个矩阵 &lt;strong&gt;A&lt;/strong&gt;， &lt;code&gt;|A|&lt;/code&gt; 表示矩阵 &lt;strong&gt;A&lt;/strong&gt; 的&lt;a href="https://en.wikipedia.org/wiki/Determinant"&gt;行列式（determinant）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这是一个计算 2x2 矩阵行列式的例子，矩阵用一个column-major格式的扁平数数组表示。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var determinant = require(&amp;#39;gl-mat2/determinant&amp;#39;)

var matrix = [ 1, 0, 0, 1 ]
var det = determinant(matrix)
//=&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/stackgl/gl-mat4/blob/c2e2de728fe7eba592f74cd02266100cc21ec89a/determinant.js"&gt;gl-mat4/determinant&lt;/a&gt; - 也可以看 &lt;a href="https://github.com/stackgl/gl-mat3"&gt;gl-mat3&lt;/a&gt; 和 &lt;a href="https://github.com/stackgl/gl-mat2"&gt;gl-mat2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.npmjs.com/package/ndarray-determinant"&gt;ndarray-determinant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.npmjs.com/package/glsl-determinant"&gt;glsl-determinant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.npmjs.com/package/robust-determinant"&gt;robust-determinant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.npmjs.com/package/robust-determinant-2"&gt;robust-determinant-2&lt;/a&gt; 和 &lt;a href="https://www.npmjs.com/package/robust-determinant-3"&gt;robust-determinant-3&lt;/a&gt;，专门 2x2 和 3x3 的矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;帽子&lt;/h2&gt;
&lt;p&gt;在几何里，字母上的 “帽子” 符号用来表示一个&lt;a href="https://en.wikipedia.org/wiki/Unit_vector"&gt;单位向量&lt;/a&gt;。例如，这是向量 &lt;strong&gt;a&lt;/strong&gt; 的单位向量。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Chat%7B%5Cmathbf%7Ba%7D%7D" alt="hat"&gt;&lt;/p&gt;
&lt;!-- \hat{\mathbf{a}} --&gt;
&lt;p&gt;在笛卡尔空间中，单位向量的长度为1。意思是向量的每个部分都在 -1.0 到 1.0 之间。这里我们 &lt;em&gt;归一化（normalize）&lt;/em&gt; 一个3D向量为单位向量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var a = [ 0, 4, -3 ]
normalize(a)
//=&amp;gt; [ 0, 0.8, -0.6 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是 &lt;code&gt;归一化（normalize）&lt;/code&gt; 函数，接收一个3D向量参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function normalize(vec) {
  var x = vec[0]
  var y = vec[1]
  var z = vec[2]
  var squaredLength = x * x + y * y + z * z

  if (squaredLength &amp;gt; 0) {
    var length = Math.sqrt(squaredLength)
    vec[0] = vec[0] / length
    vec[1] = vec[1] / length
    vec[2] = vec[2] / length
  }
  return vec
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/stackgl/gl-vec3/blob/507480fa57ba7c5fb70679cf531175a52c48cf53/normalize.js"&gt;gl-vec3/normalize&lt;/a&gt; 和 &lt;a href="https://github.com/stackgl/gl-vec2/blob/21f460a371540258521fd2f720d80f14e87bd400/normalize.js"&gt;gl-vec2/normalize&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/hughsk/vectors/blob/master/normalize-nd.js"&gt;vectors/normalize-nd&lt;/a&gt; (n-dimensional)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;属于&lt;/h2&gt;
&lt;p&gt;集合理论中，“属于”符号 &lt;code&gt;∈&lt;/code&gt; 和 &lt;code&gt;∋&lt;/code&gt; 可以被用来描述某物是否为集合中的一个元素。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?A%3D%5Cleft%20%5C%7B3%2C9%2C14%7D%7B%20%5Cright%20%5C%7D%2C%203%20%5Cin%20A" alt="element1"&gt;&lt;/p&gt;
&lt;!-- A=\left \{3,9,14}{  \right \}, 3 \in A --&gt;
&lt;p&gt;这里我们有一个数字集 &lt;em&gt;A&lt;/em&gt; &lt;code&gt;{ 3, 9, 14 }&lt;/code&gt; 而且我们说 &lt;code&gt;3&lt;/code&gt; 是“属于”这个集合的。 &lt;/p&gt;
&lt;p&gt;在ES5种一个简单的实现应该这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var A = [ 3, 9, 14 ]

A.indexOf(3) &amp;gt;= 0
//=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，可以用只能保存唯一值的&lt;code&gt;Set&lt;/code&gt;，这样更精确。这是ES6的一个特性。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var A = new Set([ 3, 9, 14 ])

A.has(3)
//=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反向的 &lt;code&gt;∋&lt;/code&gt; 意义相同，只是顺序改变：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?A%3D%5Cleft%20%5C%7B3%2C9%2C14%7D%7B%20%5Cright%20%5C%7D%2C%20A%20%5Cni%203" alt="element2"&gt;&lt;/p&gt;
&lt;!-- A=\left \{3,9,14}{  \right \}, A \ni 3 --&gt;
&lt;p&gt;你可以使用 &amp;quot;不属于&amp;quot; 符号 &lt;code&gt;∉&lt;/code&gt; 和 &lt;code&gt;∌&lt;/code&gt; 像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?A%3D%5Cleft%20%5C%7B3%2C9%2C14%7D%7B%20%5Cright%20%5C%7D%2C%206%20%5Cnotin%20A" alt="element3"&gt;&lt;/p&gt;
&lt;!-- A=\left \{3,9,14}{  \right \}, 6 \notin A --&gt;
&lt;h2 id="-"&gt;常见数字集&lt;/h2&gt;
&lt;p&gt;你可能在一些公式中看见一些大&lt;a href="https://en.wikipedia.org/wiki/Blackboard_bold"&gt;黑板粗体字&lt;/a&gt;。他们一般是用来描述集合的。&lt;/p&gt;
&lt;p&gt;例如，我们可以描述 &lt;em&gt;k&lt;/em&gt; 是&lt;a href="#element"&gt;属于&lt;/a&gt; &lt;code&gt;ℝ&lt;/code&gt; 集的一个元素。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?k%20%5Cin%20%5Cmathbb%7BR%7D" alt="real"&gt;&lt;/p&gt;
&lt;!-- k \in \mathbb{R} --&gt;
&lt;p&gt;下边列出一些常见集和他们的符号。&lt;/p&gt;
&lt;h4 id="-real-numbers-"&gt;&lt;code&gt;ℝ&lt;/code&gt; 实数（real numbers）&lt;/h4&gt;
&lt;p&gt;大 &lt;code&gt;ℝ&lt;/code&gt; 描述 &lt;em&gt;实数（real numbers）&lt;/em&gt; 的集合。他们包括整数，有理数，无理数。&lt;/p&gt;
&lt;p&gt;JavaScript认为整数和浮点数为相同类型，所以下边将是一个 &lt;em&gt;k&lt;/em&gt; ∈ ℝ 的简单测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function isReal (k) {
  return typeof k === &amp;#39;number&amp;#39; &amp;amp;&amp;amp; isFinite(k);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意：&lt;/em&gt; 实数也是 &lt;em&gt;有限数（finite）&lt;/em&gt;，&lt;em&gt;非无限的（not infinite）&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="-rational-numbers-"&gt;&lt;code&gt;ℚ&lt;/code&gt; 有理数（rational numbers）&lt;/h4&gt;
&lt;p&gt;有理数是可以被表示为分数，或 &lt;em&gt;比率&lt;/em&gt;（类似&lt;code&gt;⅗&lt;/code&gt;）的实数。有理数不能以0作分母。&lt;/p&gt;
&lt;p&gt;这意味着所有的整数都是有理数，因为可以看成分母为1。&lt;/p&gt;
&lt;p&gt;换句话说无理数就是不能表示为比率的数，例如 π (PI)。&lt;/p&gt;
&lt;h4 id="-integers-"&gt;&lt;code&gt;ℤ&lt;/code&gt; 整数（integers）&lt;/h4&gt;
&lt;p&gt;一个整数，是没有小数部分的实数。可为正也可以为负。&lt;/p&gt;
&lt;p&gt;在JavaScript中的简单测试应该这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function isInteger (n) {
  return typeof n === &amp;#39;number&amp;#39; &amp;amp;&amp;amp; n % 1 === 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-natural-numbers-"&gt;&lt;code&gt;ℕ&lt;/code&gt; 自然数（natural numbers）&lt;/h4&gt;
&lt;p&gt;自然数是正整数或非负整数。取决于所学领域和上下文，集合中可能包含也可能不包含0，所以可以是下边任意一种集合。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;{ 0, 1, 2, 3, ... }
{ 1, 2, 3, 4, ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前者在计算机科学中更常见，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function isNaturalNumber (n) {
  return isInteger(n) &amp;amp;&amp;amp; n &amp;gt;= 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-"&gt;&lt;code&gt;ℂ&lt;/code&gt; 复数&lt;/h4&gt;
&lt;p&gt;复数是实数域虚数的组合，被视为2D平面上的一个坐标。更详细的信息请看&lt;a href="http://betterexplained.com/articles/a-visual-intuitive-guide-to-imaginary-numbers/"&gt;A Visual, Intuitive Guide to Imaginary Numbers&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="-"&gt;函数&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Function_%28mathematics%29"&gt;函数&lt;/a&gt; 是数学的基本特性，其概念很容易转换成代码。&lt;/p&gt;
&lt;p&gt;函数把输入输出值联系起来。例如下边是一个函数：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?x%5E%7B2%7D" alt="function1"&gt;&lt;/p&gt;
&lt;!-- x^{2} --&gt;
&lt;p&gt;我们可以给函数一个 &lt;em&gt;名字&lt;/em&gt; 。一般来说我们用  &lt;code&gt;ƒ&lt;/code&gt; 来描述一个函数，但也可以命名为 &lt;code&gt;A(x)&lt;/code&gt; 或其他什么。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?f%5Cleft%20%28x%20%5Cright%20%29%20%3D%20x%5E%7B2%7D" alt="function2"&gt;&lt;/p&gt;
&lt;!-- f\left (x  \right ) = x^{2} --&gt;
&lt;p&gt;在代码中，我们可以给函数命名为 &lt;code&gt;square&lt;/code&gt; 写出来应该类似这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function square (x) {
  return Math.pow(x, 2)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有时函数没有名字，而是直接写出输出值。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?y%20%3D%20x%5E%7B2%7D" alt="function3"&gt;&lt;/p&gt;
&lt;!-- y = x^{2} --&gt;
&lt;p&gt;在上边的例子中，&lt;em&gt;x&lt;/em&gt; 是输入值，&lt;em&gt;y&lt;/em&gt; 是输出值，他们是平方的关系。&lt;/p&gt;
&lt;p&gt;像编程语言一样，函数也可以有多个参数。他们在数学中被称为 &lt;em&gt;arguments&lt;/em&gt;，并且函数接受的参数数量被称为函数的 &lt;em&gt;arity&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?f%28x%2Cy%29%20%3D%20%5Csqrt%7Bx%5E2%20&amp;plus;%20y%5E2%7D" alt="function4"&gt;&lt;/p&gt;
&lt;!-- f(x,y) = \sqrt{x^2 + y^2} --&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function length (x, y) {
  return Math.sqrt(x * x + y * y)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;分段函数&lt;/h3&gt;
&lt;p&gt;有些函数根据输入值 &lt;em&gt;x&lt;/em&gt; 的不同会有不同的关系。&lt;/p&gt;
&lt;p&gt;下边的函数 &lt;em&gt;f&lt;/em&gt; 根据不同的输入值选择两个不同的“子函数”。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?f%28x%29%3D%20%5Cbegin%7Bcases%7D%20%5Cfrac%7Bx%5E2-x%7D%7Bx%7D%2C%26%20%5Ctext%7Bif%20%7D%20x%5Cgeq%201%5C%5C%200%2C%20%26%20%5Ctext%7Botherwise%7D%20%5Cend%7Bcases%7D" alt="piecewise1"&gt;&lt;/p&gt;
&lt;!--    f(x)= 
\begin{cases}
    \frac{x^2-x}{x},&amp; \text{if } x\geq 1\\
    0, &amp; \text{otherwise}
\end{cases} --&gt;
&lt;p&gt;这非常接近于代码中的&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt;。右边的条件经常被写为&lt;strong&gt;&amp;quot;for x &amp;lt; 0&amp;quot;&lt;/strong&gt; 或 &lt;strong&gt;&amp;quot;if x = 0&amp;quot;&lt;/strong&gt;。如果条件为true，就使用其左边的函数。&lt;/p&gt;
&lt;p&gt;在分段函数中，&lt;strong&gt;&amp;quot;otherwise&amp;quot;&lt;/strong&gt; 和 &lt;strong&gt;&amp;quot;elsewhere&amp;quot;&lt;/strong&gt; 类似于代码中的 &lt;code&gt;else&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function f (x) {
  if (x &amp;gt;= 1) {
    return (Math.pow(x, 2) - x) / x
  } else {
    return 0
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;通用函数&lt;/h3&gt;
&lt;p&gt;有些函数名在数学中是普遍存在的。在一个程序员的角度看，这些应该类似于编程语言中的“内置”函数（就像JavaScript中的 &lt;code&gt;parseInt&lt;/code&gt; ）。&lt;/p&gt;
&lt;p&gt;一个例子就是 &lt;em&gt;sgn&lt;/em&gt; 函数。这是 &lt;em&gt;正负号&lt;/em&gt; 函数，或者叫 &lt;em&gt;符号&lt;/em&gt; 函数。让我们用&lt;a href="#piecewise-function"&gt;分段函数&lt;/a&gt;来描述它：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?sgn%28x%29%20%3A%3D%20%5Cbegin%7Bcases%7D%20-1%26%20%5Ctext%7Bif%20%7D%20x%20%3C%200%5C%5C%200%2C%20%26%20%5Ctext%7Bif%20%7D%20%7Bx%20%3D%200%7D%5C%5C%201%2C%20%26%20%5Ctext%7Bif%20%7D%20x%20%3E%200%5C%5C%20%5Cend%7Bcases%7D" alt="sgn"&gt;&lt;/p&gt;
&lt;!-- sgn(x) := 
\begin{cases}
    -1&amp; \text{if } x &lt; 0\\
    0, &amp; \text{if } {x = 0}\\
    1, &amp; \text{if } x &gt; 0\\
\end{cases} --&gt;
&lt;p&gt;代码中，应该这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function sgn (x) {
  if (x &amp;lt; 0) return -1
  if (x &amp;gt; 0) return 1
  return 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此函数作为独立的module在这里&lt;a href="https://github.com/scijs/signum"&gt;signum&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其他类似函数的例子还有: &lt;em&gt;sin&lt;/em&gt;， &lt;em&gt;cos&lt;/em&gt;， &lt;em&gt;tan&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id="-"&gt;函数符号&lt;/h3&gt;
&lt;p&gt;在某些著作中，函数可以被更明确的符号定义。例如，让我们回到之前提到的 &lt;code&gt;square&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?f%5Cleft%20%28x%20%5Cright%20%29%20%3D%20x%5E%7B2%7D" alt="function2"&gt;&lt;/p&gt;
&lt;!-- f\left (x  \right ) = x^{2} --&gt;
&lt;p&gt;也可以写为以下形式：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?f%20%3A%20x%20%5Cmapsto%20x%5E2" alt="mapsto"&gt;&lt;/p&gt;
&lt;!-- f : x \mapsto x^2 --&gt;
&lt;p&gt;带尾巴的箭头通常意思为“映射到”，如，&lt;em&gt;将x映射到x&lt;sup&gt;2&lt;/sup&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;有时，不是很常见，这个符号也用来描述函数的 &lt;em&gt;domain&lt;/em&gt; 和 &lt;em&gt;codomain&lt;/em&gt;。对 &lt;em&gt;ƒ&lt;/em&gt; 更正式的定义可以写为：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?%5Cbegin%7Balign*%7D%20f%20%3A%26%5Cmathbb%7BR%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D%5C%5C%20%26x%20%5Cmapsto%20x%5E2%20%5Cend%7Balign*%7D" alt="funcnot"&gt;&lt;/p&gt;
&lt;!-- \begin{align*}
f :&amp;\mathbb{R} \rightarrow \mathbb{R}\\
&amp;x \mapsto x^2 
\end{align*}
 --&gt;
&lt;p&gt;函数的 &lt;em&gt;domain&lt;/em&gt; 和 &lt;em&gt;codomain&lt;/em&gt; 分别跟他的 &lt;em&gt;input&lt;/em&gt; 和 &lt;em&gt;output&lt;/em&gt; 类型有点像。这里有另一个例子，使用了我们之前输出整数的 &lt;em&gt;sgn&lt;/em&gt; 函数。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?sgn%20%3A%20%5Cmathbb%7BR%7D%20%5Crightarrow%20%5Cmathbb%7BZ%7D" alt="domain2"&gt;&lt;/p&gt;
&lt;!-- sgn : \mathbb{R} \rightarrow \mathbb{Z} --&gt;
&lt;p&gt;这里的箭头（没有尾巴）用来映射一个 &lt;em&gt;集合&lt;/em&gt; 到另一个。&lt;/p&gt;
&lt;p&gt;在JavaScript和其他动态类型语言中，你也许会用文档 和/或 运行时检查来解释和验证函数的输入/输出。例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/**
 * Squares a number.
 * @param  {Number} a real number
 * @return {Number} a real number
 */
function square (a) {
  if (typeof a !== &amp;#39;number&amp;#39;) {
    throw new TypeError(&amp;#39;expected a number&amp;#39;)
  }
  return Math.pow(a, 2)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有些工具例如&lt;a href="http://flowtype.org/"&gt;flowtype&lt;/a&gt;尝试将静态类型带入到JavaScript中。&lt;/p&gt;
&lt;p&gt;其他语言，例如Java，允许真正的方法重载（overloading），它们基于函数输入输出的静态类型。这更接近于数学领域：使用不同 &lt;em&gt;domain&lt;/em&gt; 的两个函数是不同的。&lt;/p&gt;
&lt;h2 id="-prime-"&gt;撇号（prime）&lt;/h2&gt;
&lt;p&gt;撇号 (&lt;code&gt;′&lt;/code&gt;) 通常用在变量名上，用来描述某物很类似，而不用另起个名来描述它。也可以描述经过一些变换后的“下一个值”。&lt;/p&gt;
&lt;p&gt;例如，如果我们有一个2D点 &lt;em&gt;(x, y)&lt;/em&gt; ，然后旋转它，你会把旋转后的点命名为&lt;em&gt;(x′, y′)&lt;/em&gt;。 或者将矩阵 &lt;strong&gt;M&lt;/strong&gt; 的 &lt;em&gt;转置矩阵&lt;/em&gt; 命名为 &lt;strong&gt;M′&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在代码中，我们通常的分配一个描述更详细的变量名，例如&lt;code&gt;transformedPosition&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;作为数学&lt;a href="#function"&gt;函数&lt;/a&gt;，撇号通常描述为函数的 &lt;em&gt;衍生（derivative）&lt;/em&gt; 函数。衍生物会在未来的章节解释。我们来看一个之前的函数：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?f%5Cleft%20%28x%20%5Cright%20%29%20%3D%20x%5E%7B2%7D" alt="function2"&gt;&lt;/p&gt;
&lt;!-- f\left (x  \right ) = x^{2} --&gt;
&lt;p&gt;它的衍生物函数（derivative）可以写为一个带撇号&lt;code&gt;′&lt;/code&gt;的函数：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?f%27%28x%29%20%3D%202x" alt="prime1"&gt;&lt;/p&gt;
&lt;!-- f'(x) = 2x --&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function f (x) {
  return Math.pow(x, 2)
}

function fPrime (x) {
  return 2 * x
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个撇号可以用来表示第二个衍生函数（derivative） &lt;em&gt;ƒ′′&lt;/em&gt; 或 第三个衍生函数（derivative）&lt;em&gt;ƒ′′′&lt;/em&gt; ，之后更高的数字，一般作者会用罗马数字 &lt;em&gt;ƒ&lt;/em&gt;&lt;sup&gt;IV&lt;/sup&gt; 或上标数字 &lt;em&gt;ƒ&lt;/em&gt;&lt;sup&gt;(n)&lt;/sup&gt; 表示。&lt;/p&gt;
&lt;h2 id="-floor-ceiling-"&gt;向下取整和向上取整（floor &amp;amp; ceiling）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;⌊x⌋&lt;/code&gt; 和 &lt;code&gt;⌈x⌉&lt;/code&gt; 这种特殊的括号分别用来表示&lt;em&gt;floor&lt;/em&gt; 和 &lt;em&gt;ceil&lt;/em&gt; 函数。 &lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?floor%28x%29%20%3D%20%5Clfloor%20x%20%5Crfloor" alt="floor"&gt;&lt;/p&gt;
&lt;!-- floor(x) =  \lfloor x \rfloor --&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?ceil%28x%29%20%3D%20%5Clceil%20x%20%5Crceil" alt="ceil"&gt;&lt;/p&gt;
&lt;!-- ceil(x) =  \lceil x \rceil --&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;Math.floor(x)
Math.ceil(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当这两个符号混合&lt;code&gt;⌊x⌉&lt;/code&gt;，它通常表示一个取整到最近的整数的函数。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?round%28x%29%20%3D%20%5Clfloor%20x%20%5Crceil" alt="round"&gt;&lt;/p&gt;
&lt;!-- round(x) =  \lfloor x \rceil --&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;Math.round(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;箭头&lt;/h2&gt;
&lt;p&gt;箭头通常用来表示&lt;a href="#function-notation"&gt;函数符号&lt;/a&gt;。这里还有一些在其他领域中的用法可以看看。&lt;/p&gt;
&lt;h4 id="-material-implication-"&gt;实质蕴含（material implication）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;⇒&lt;/code&gt; 和 &lt;code&gt;→&lt;/code&gt; 优势被用作表示实质蕴涵（material implication）的逻辑。意思是如果A是true，那么B也是true。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?A%20%5CRightarrow%20B" alt="material1"&gt;&lt;/p&gt;
&lt;!-- A \Rightarrow B --&gt;
&lt;p&gt;解释为代码应该为：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;if (A === true) {
  console.assert(B === true)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头可以是左右任何方向 &lt;code&gt;⇐&lt;/code&gt; &lt;code&gt;⇒&lt;/code&gt;，也可以双向&lt;code&gt;⇔&lt;/code&gt;。当 &lt;em&gt;A ⇒ B&lt;/em&gt; 并且 &lt;em&gt;B ⇒ A&lt;/em&gt;，就是他们是相等的：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?A%20%5CLeftrightarrow%20B" alt="material-equiv"&gt;&lt;/p&gt;
&lt;!-- A \Leftrightarrow B --&gt;
&lt;h4 id="-equality-"&gt;等式（equality）&lt;/h4&gt;
&lt;p&gt;在数学中， &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;≤&lt;/code&gt; 和 &lt;code&gt;≥&lt;/code&gt; 与代码中的使用方法一样：分别为 &lt;em&gt;小于&lt;/em&gt;, &lt;em&gt;大于&lt;/em&gt;, &lt;em&gt;小于等于&lt;/em&gt; 和 &lt;em&gt;大于等于&lt;/em&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;50 &amp;gt; 2 === true
2 &amp;lt; 10 === true
3 &amp;lt;= 4 === true
4 &amp;gt;= 4 === true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;偶尔会看到在这些符号上加了一条斜线，来表示 &lt;em&gt;不&lt;/em&gt;，比如， &lt;em&gt;k&lt;/em&gt; 不 &amp;quot;大于&amp;quot; &lt;em&gt;j&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?k%20%5Cngtr%20j" alt="ngt"&gt;&lt;/p&gt;
&lt;!-- k \ngtr j --&gt;
&lt;p&gt; &lt;code&gt;≪&lt;/code&gt; 和 &lt;code&gt;≫&lt;/code&gt;通常用来表示 &lt;em&gt;明显（significant）&lt;/em&gt; 不相等。这是说 &lt;em&gt;k&lt;/em&gt; 是有&lt;a href="https://en.wikipedia.org/wiki/Order_of_magnitude"&gt;数量级（order of magnitude）&lt;/a&gt;的大于 &lt;em&gt;j&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?k%20%5Cgg%20j" alt="orderofmag"&gt;&lt;/p&gt;
&lt;!-- k \gg j --&gt;
&lt;p&gt;在数学中，&lt;em&gt;数量级（order of magnitude）&lt;/em&gt; 是相当明确的；不只是“相当大的不同”而已。上边的一个简单例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;orderOfMagnitude(k) &amp;gt; orderOfMagnitude(j)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下边是我们的 &lt;code&gt;orderOfMagnitude&lt;/code&gt; 函数，使用了&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc"&gt;Math.trunc&lt;/a&gt; (ES6)。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function log10(n) {
  // logarithm in base 10
  return Math.log(n) / Math.LN10
}

function orderOfMagnitude (n) {
  return Math.trunc(log10(n))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;sup&gt;&lt;em&gt;Note:&lt;/em&gt; This is not numerically robust.&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;这里是在ES5下使用&lt;a href="https://www.npmjs.com/package/math-trunc"&gt;math-trunc&lt;/a&gt; 的polyfill。&lt;/p&gt;
&lt;h4 id="-conjunction-disjunction-"&gt;与（conjunction） &amp;amp; 或（disjunction）&lt;/h4&gt;
&lt;p&gt;另一种箭头在逻辑中的使用是与（conjunction）&lt;code&gt;∧&lt;/code&gt; 和 或（disjunction） &lt;code&gt;∨&lt;/code&gt;。他们分别类似于程序员的 &lt;code&gt;AND&lt;/code&gt; 和 &lt;code&gt;OR&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;下边展示了与（conjunction）&lt;code&gt;∧&lt;/code&gt;， 逻辑中的&lt;code&gt;AND&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?k%20%3E%202%20%5Cland%20k%20%3C%204%20%5CLeftrightarrow%20k%20%3D%203" alt="and"&gt;&lt;/p&gt;
&lt;!-- k &gt; 2 \land k &lt;  4 \Leftrightarrow k = 3   --&gt;
&lt;p&gt;在JavaScript中，我们使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 假设 &lt;em&gt;k&lt;/em&gt; 是一个自然数，那么这个逻辑意味着k等于3：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;if (k &amp;gt; 2 &amp;amp;&amp;amp; k &amp;lt; 4) {
  console.assert(k === 3)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于双边都相等 &lt;code&gt;⇔&lt;/code&gt;，所以也说明下边成立：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;if (k === 3) {
  console.assert(k &amp;gt; 2 &amp;amp;&amp;amp; k &amp;lt; 4)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下箭头 &lt;code&gt;∨&lt;/code&gt; 是逻辑或（disjunction），就像 OR 操作符一样。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?A%20%5Clor%20B" alt="logic-or"&gt;&lt;/p&gt;
&lt;!-- A \lor B --&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;A || B
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-logical-negation-"&gt;逻辑非（logical negation）&lt;/h2&gt;
&lt;p&gt;有时候，&lt;code&gt;¬&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;!&lt;/code&gt; 符号都用来表示逻辑 &lt;code&gt;NOT&lt;/code&gt;。例如，只有在A为false的时候，&lt;em&gt;¬A&lt;/em&gt; 为true。&lt;/p&gt;
&lt;p&gt;这里是一个使用 &lt;em&gt;not&lt;/em&gt; 符号简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?x%20%5Cneq%20y%20%5CLeftrightarrow%20%5Clnot%28x%20%3D%20y%29" alt="negation"&gt;&lt;/p&gt;
&lt;!-- x \neq y \Leftrightarrow \lnot(x = y) --&gt;
&lt;p&gt;翻译成代码的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;if (x !== y) {
  console.assert(!(x === y))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意：&lt;/em&gt; 根据上下文的不同，波浪线 &lt;code&gt;~&lt;/code&gt; 可以有很多种不同的意思。例如，&lt;em&gt;行等价（row equivalence）&lt;/em&gt;（矩阵理论）或&lt;em&gt;相同数量级（same order of magnitude）&lt;/em&gt; （在&lt;a href="#equality"&gt;等式（equality）&lt;/a&gt;章节讨论过）。&lt;/p&gt;
&lt;h2 id="-intervals-"&gt;区间（intervals）&lt;/h2&gt;
&lt;p&gt;有时函数会处理被一些值限定范围的实数，这样的约束可以用&lt;em&gt;区间（interval）&lt;/em&gt;来表示。&lt;/p&gt;
&lt;p&gt;例如我们可以表示0和1之间的数，让他们包含或不包含0和1：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不包含0或1： &lt;img src="http://latex.codecogs.com/svg.latex?%280%2C%201%29" alt="interval-opened-left-opened-right"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- (0, 1) --&gt;
&lt;ul&gt;
&lt;li&gt;包含0但不包含1： &lt;img src="http://latex.codecogs.com/svg.latex?%5B0%2C%201%29" alt="interval-closed-left-opened-right"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- [0, 1) --&gt;
&lt;ul&gt;
&lt;li&gt;不包含0但包含1： &lt;img src="http://latex.codecogs.com/svg.latex?%280%2C%201%5D" alt="interval-opened-left-closed-right"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- (0, 1] --&gt;
&lt;ul&gt;
&lt;li&gt;包含0和1： &lt;img src="http://latex.codecogs.com/svg.latex?%5B0%2C%201%5D" alt="interval-closed-left-closed-right"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- [0, 1] --&gt;
&lt;p&gt;例如我们指出一个点 &lt;code&gt;x&lt;/code&gt; 在3D单位立方体中，我们可以说：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://latex.codecogs.com/svg.latex?x%20%5Cin%20%5B0%2C%201%5D%5E3" alt="interval-unit-cube"&gt;&lt;/p&gt;
&lt;!-- x \in [0, 1]^3 --&gt;
&lt;p&gt;在代码中我们可以用两个元素大小的一维数组表示区间：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var nextafter = require(&amp;#39;nextafter&amp;#39;)

var a = [nextafter(0, Infinity), nextafter(1, -Infinity)]     // 开区间
var b = [nextafter(0, Infinity), 1]                           // 左闭右开区间
var c = [0, nextafter(1, -Infinity)]                          // 左开右闭区间
var d = [0, 1]                                                // 闭区间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区间与集合运算结合符使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;交集（intersection）&lt;/em&gt; e.g. &lt;img src="http://latex.codecogs.com/svg.latex?%5B3%2C%205%29%20%5Ccap%20%5B4%2C%206%5D%20%3D%20%5B4%2C%205%29" alt="interval-intersection"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- [3, 5) \cap [4, 6] = [4, 5) --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;并集（union）&lt;/em&gt; e.g. &lt;img src="http://latex.codecogs.com/svg.latex?%5B3%2C%205%29%20%5Ccup%20%5B4%2C%206%5D%20%3D%20%5B3%2C%206%5D" alt="interval-union"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- [3, 5) \cup [4, 6] = [3, 6] --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;差集（difference）&lt;/em&gt; e.g. &lt;img src="http://latex.codecogs.com/svg.latex?%5B3%2C%205%29%20-%20%5B4%2C%206%5D%20%3D%20%5B3%2C%204%29" alt="interval-difference-1"&gt; 还有 &lt;img src="http://latex.codecogs.com/svg.latex?%5B4%2C%206%5D%20-%20%5B3%2C%205%29%20%3D%20%5B5%2C%206%5D" alt="interval-difference-2"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- [3, 5) - [4, 6] = [3, 4) --&gt;
&lt;!-- [4, 6] - [3, 5)  = [5, 6] --&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var Interval = require(&amp;#39;interval-arithmetic&amp;#39;)
var nexafter = require(&amp;#39;nextafter&amp;#39;)

var a = Interval(3, nexafter(5, -Infinity))
var b = Interval(4, 6)

Interval.intersection(a, b)
// {lo: 4, hi: 4.999999999999999}

Interval.union(a, b)
// {lo: 3, hi: 6}

Interval.difference(a, b)
// {lo: 3, hi: 3.9999999999999996}

Interval.difference(b, a)
// {lo: 5, hi: 6}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/scijs/nextafter"&gt;next-after&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/maurizzzio/interval-arithmetic"&gt;interval-arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;更多...&lt;/h2&gt;
&lt;p&gt;喜欢这份指南？提出&lt;a href="https://github.com/Jam3/math-as-code/issues/1"&gt;更多的特性&lt;/a&gt;的建议或给我们发Pull Request！&lt;/p&gt;
&lt;h2 id="-"&gt;贡献&lt;/h2&gt;
&lt;p&gt;关于怎样贡献详见 &lt;a href="./CONTRIBUTING.md"&gt;CONTRIBUTING.md&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="license"&gt;License&lt;/h2&gt;
&lt;p&gt;MIT, 详见 &lt;a href="http://github.com/Jam3/math-as-code/blob/master/LICENSE.md"&gt;LICENSE.md&lt;/a&gt;。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>高血压用药扫盲</title>
    <id>http://nshen.net/article/2016-02-16/gao-xue-ya</id>
    <link href="http://nshen.net/article/2016-02-16/gao-xue-ya"/>
    <updated>2016-02-16T12:00:00.000Z</updated>
    <content>&lt;p&gt;近期老妈高血压突然控制不住入院，观察期间医生给换了好多种药，不知道老妈吃的是什么心里有点不安，所以自己研究了一下高血压相关的东西，这里分享一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意: 此文为个人在网上的总结，本人外行，极可能有错，生命大事还请咨询医生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--more--&gt;
&lt;h2 id="-"&gt;用药原则&lt;/h2&gt;
&lt;p&gt;常见有4类血压药，是从不同原理控制血压的。原则上，当一种血压药已经无法控制住血压的时候，不应该继续加量，而应该遵循最小药量原则不同种类联合用药。&lt;/p&gt;
&lt;h2 id="-"&gt;血压药分类：&lt;/h2&gt;
&lt;h3 id="a-acei-arbs-"&gt;A类（ACEI / ARBs） 糖尿病首选&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;适用与禁忌&lt;/strong&gt;：A类药物更适于有胰岛素抵抗、糖尿病、左心功能不全、心力衰竭、心肌梗死的患者，同时， ACEI、ARB有利于防止肾病进展，但不可用于孕妇。&lt;/p&gt;
&lt;h4 id="acei-"&gt;ACEI（血管紧张素抑制剂）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;血管紧张素转换酶抑制剂：常用的有卡托普利、依那普利、贝那普利、西拉普利。降压起效缓慢、逐渐增强。ACE抑制剂具有改善胰岛素抵抗和减少尿蛋白作用，&lt;strong&gt;在肥胖、糖尿病和心脏、肾脏靶器官受损的高血压患者具有相对较好的疗效，特别适用于伴有心力衰竭、心肌梗死后、糖耐量减退或糖尿病肾病的高血压患者&lt;/strong&gt;。不良反应时刺激性干咳和血管性水肿。高钾血症、妊娠妇女和双侧肾动脉狭窄患者禁用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;分辨&lt;/strong&gt;：常见各种&lt;strong&gt;普利&lt;/strong&gt;类药，具体看说明书。&lt;/p&gt;
&lt;h4 id="arbs-"&gt;ARBs（血管紧张素二受体阻滞剂）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;血管紧张素二受体抑制剂：常用的有氯沙坦，降压作用起效缓慢，但持久而稳定。最大的特点是直接与药物有关的不良反应少，不引起刺激性干咳，持续治疗的依从性高。虽然在治疗对象与禁忌证与ACEI相同，但ARB有自身治疗特点，与ACEI并列为目前推荐的常用五大类降压药中的一类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;分辨&lt;/strong&gt;：常见各种&lt;strong&gt;氯沙坦&lt;/strong&gt;类药，具体看说明书。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="b-beta-blockers-"&gt;B类（Beta-blockers β受体阻滞剂） 心率失常首选&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;适用与禁忌&lt;/strong&gt;：β受体阻滞剂适用于高血压伴心绞痛、心肌梗死、心衰、快速心律失常、青光眼和怀孕的患者，哮喘或周围血管病甚用该类药物。同时该类药物还会影响糖脂代谢，可增加糖尿病发病风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分辨&lt;/strong&gt;：常见各种&lt;strong&gt;洛尔&lt;/strong&gt;类药，具体看说明书。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;β受体阻滞剂：常用的有美托洛尔、阿替洛尔、比索洛尔、卡维洛尔、拉贝洛尔。降压作用可能通过抑制中枢和周围的RAAS。降压起效较迅速、强力。适用于各种不同严重程度高血压，尤其是心律较快的中、青年患者或合并心绞痛患者，&lt;strong&gt;对老年人高血压疗效相对较差&lt;/strong&gt;。β阻滞剂治疗的主要障碍时心动过缓和一些影响生活质量的不良反应，较高剂量被他5阻滞剂治疗时突然停药可导致撤药综合症。虽然糖尿病不是使用β1阻滞剂的禁忌证，但它增加胰岛素抵抗，还可能掩盖和延长降糖治疗过程中的低血糖证，使用时要注意。不良反应主要有心动过缓、乏力、四肢发冷。β受体阻滞剂对心肌收缩力、方式传导及窦性心律均有抑制作用，并可增加气道阻力。急性心力衰竭、支气管哮喘、病态窦房结综合症、房室传导阻滞和外周血管病患者禁用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id="c-ccb-"&gt;C类（CCB 钙离子拮抗剂） 老年人首选&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;适用与禁忌&lt;/strong&gt;：长效CCB（如“拜新同”）有较好的防止脑卒中、血管性痴呆和抗动脉粥样硬化作用，对糖脂及电解质代谢无影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分辨&lt;/strong&gt;：常见各种&lt;strong&gt;地平&lt;/strong&gt;类药，具体看说明书。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;钙通道阻滞剂：又称钙拮抗剂，主要有硝苯地平、维拉帕米和地尔硫卓、根据药物作用持续时间，钙通道阻滞剂又可分为短效和长效。除心力衰竭外钙拮抗剂较少有禁忌证。相对于其它降压药的优势是&lt;strong&gt;老年患者有较好的降压疗效&lt;/strong&gt;，高钠摄入不影响降压疗效；在嗜酒的患者也有显著的降压作用；可用于合并糖尿病、冠心病或外周血管病患者；长期治疗还有抗动脉粥样应还作用。主要缺点是开始治疗阶段有反射性交感活性增强，引起心率增快、面部潮红、头痛、下肢水肿，不宜在心力衰竭、窦房结功能底下或心脏传导阻滞者患者中应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id="d-diuretics-"&gt;D类（diuretics 利尿剂） 一般不单独使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;适用与禁忌&lt;/strong&gt;：降低收缩压的作用优于舒张压，适用于老年单纯收缩期高血压的患者或有心衰表现的患者，应用中要注意避免血钾过低，&lt;strong&gt;痛风患者禁用，肾功能不全者禁用&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分辨&lt;/strong&gt;：常见各种&lt;strong&gt;噻嗪&lt;/strong&gt;类，具体看说明书。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;利尿剂：有噻嗪类、袢利尿剂和保钾利尿剂。各种利尿剂的降压疗效相仿，降压作用主要通过排纳，减少细胞外容量，降低外周血管阻力。降压起效角平缓，持续时间相对较长，作用持久，服药2-3周后作用达到高峰。适用于轻、中度高血压，在盐敏感性高血压，合并肥胖或糖尿病、更年期女性和老年人高血压有较强降压效果。利尿剂的主要不利作用是低血钾征和影响血脂、血糖、血尿酸代谢，往往发生在大剂量时，因此现在推荐使用小剂量，不良反应主要是乏力、尿量增多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="-"&gt;常见名词解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;收缩压：高压&lt;/li&gt;
&lt;li&gt;舒张压：低压&lt;/li&gt;
&lt;li&gt;原发性高血压：最常见高血压，占所有高血压病例90–95%。&lt;/li&gt;
&lt;li&gt;继发性高血压：是由明确的病因所致。肾脏疾病是继发性高血压最常见的病因。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;正常血压表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;年龄&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;收缩压（男）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;舒张压（男）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;收缩压（女）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;舒张压（女）&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;16—20&lt;/td&gt;
&lt;td&gt;115&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;21—25&lt;/td&gt;
&lt;td&gt;115&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;td&gt;71&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;26—30&lt;/td&gt;
&lt;td&gt;115&lt;/td&gt;
&lt;td&gt;75&lt;/td&gt;
&lt;td&gt;112&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;31—35&lt;/td&gt;
&lt;td&gt;117&lt;/td&gt;
&lt;td&gt;76&lt;/td&gt;
&lt;td&gt;114&lt;/td&gt;
&lt;td&gt;74&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;36—40&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;116&lt;/td&gt;
&lt;td&gt;77&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;41—45&lt;/td&gt;
&lt;td&gt;124&lt;/td&gt;
&lt;td&gt;81&lt;/td&gt;
&lt;td&gt;122&lt;/td&gt;
&lt;td&gt;78&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;46—50&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;82&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;79&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;51—55&lt;/td&gt;
&lt;td&gt;134&lt;/td&gt;
&lt;td&gt;84&lt;/td&gt;
&lt;td&gt;134&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;56—60&lt;/td&gt;
&lt;td&gt;137&lt;/td&gt;
&lt;td&gt;84&lt;/td&gt;
&lt;td&gt;139&lt;/td&gt;
&lt;td&gt;82&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;61—65&lt;/td&gt;
&lt;td&gt;148&lt;/td&gt;
&lt;td&gt;86&lt;/td&gt;
&lt;td&gt;145&lt;/td&gt;
&lt;td&gt;83&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：以上统计为98年完成的，如今人的平均血压有所增加。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>npm包管理器学习笔记</title>
    <id>http://nshen.net/article/2016-02-13/npm-js</id>
    <link href="http://nshen.net/article/2016-02-13/npm-js"/>
    <updated>2016-02-13T15:15:00.000Z</updated>
    <content>&lt;p&gt;npm是js界的包管理器，这里记录一下它基本的使用方法。&lt;/p&gt;
&lt;!--more--&gt; 
&lt;h2 id="-npm"&gt;安装npm&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://nodejs.org/"&gt;https://nodejs.org/&lt;/a&gt; 下载安装nodejs&lt;br&gt;&lt;code&gt;node -v&lt;/code&gt;查看安装版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;node自带npm, &lt;code&gt;npm -v&lt;/code&gt;查看npm版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更新到最新版本&lt;br&gt;&lt;code&gt;npm install npm -g&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果遇到permission错误到这里看看&lt;br&gt;&lt;code&gt;https://docs.npmjs.com/getting-started/fixing-npm-permissions&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="-"&gt;安装包&lt;/h2&gt;
&lt;p&gt;分为本地安装和全局安装,本地安装后你可以在的程序中用&lt;code&gt;require(&amp;#39;package&amp;#39;)&lt;/code&gt;访问,全局安装通常是用于命令行工具,例如构建工具grunt CLI.&lt;/p&gt;
&lt;h3 id="-"&gt;本地安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm install &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;br&gt;如果有&lt;code&gt;package.json&lt;/code&gt;指明依赖,则不需要输入package_name直接&lt;code&gt;npm install&lt;/code&gt; 即可全部安装完成。&lt;br&gt;运行后会当前目录生成一个&lt;code&gt;node_modules&lt;/code&gt;目录,package会安装在里边&lt;br&gt;如果当前目录有一个&lt;code&gt;package.json&lt;/code&gt; 则会安装里边指定的版本,否则安装最新版.&lt;br&gt;安装完成即可在代码中使用了&lt;br&gt;&lt;code&gt;require(&amp;#39;lodash&amp;#39;);&lt;/code&gt; //如果没有安装loadash则会报错&lt;/p&gt;
&lt;h3 id="-"&gt;全局安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm install -g &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全局包安装路径:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm root -g&lt;/code&gt; 显示全局包安装路径&lt;/p&gt;
&lt;p&gt;在我的电脑上显示 &lt;code&gt;C:\Users\Administrator\AppData\Roaming\npm\node_modules&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="package-json"&gt;package.json&lt;/h2&gt;
&lt;p&gt;package.json最低要求需要name与version&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;my-awesome-package&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自动创建package.json&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后一路填表就可以了,author部分可以填多一些&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Your Name &amp;lt;email@example.com&amp;gt; (http://example.com)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指明包依赖列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;dependencies&amp;quot;&lt;/code&gt;: these packages are required by your application in production&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;devDependencies&amp;quot;&lt;/code&gt;: these packages are only needed for development and testing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装package时自动加入依赖列表&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install &amp;lt;package_name&amp;gt; --save&lt;/code&gt; 加入到dependencies&lt;br&gt;&lt;code&gt;npm install &amp;lt;package_name&amp;gt; --save-dev&lt;/code&gt; 加入到devDependencies&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="-"&gt;更新包&lt;/h2&gt;
&lt;h3 id="-"&gt;本地包更新&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm ls&lt;/code&gt; 查看已经安装的package&lt;br&gt;&lt;code&gt;npm outdated&lt;/code&gt; 查看是否有新版本 ，分为 current wanted latest&lt;br&gt;&lt;code&gt;npm update&lt;/code&gt; 更新到wanted版本，加--save，保存到package.json&lt;/p&gt;
&lt;p&gt;如需更新到latest，建议安装 &lt;a href="https://www.npmjs.com/package/npm-check-updates"&gt;npm-check-updates&lt;/a&gt; 插件&lt;/p&gt;
&lt;h3 id="-"&gt;全局包更新&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm ls -g --depth=0&lt;/code&gt; 查看都安装了哪些全局包&lt;br&gt;&lt;code&gt;npm outdated -g --depth=0&lt;/code&gt; 查看哪个包需要更新&lt;br&gt;&lt;code&gt;npm install -g &amp;lt;package_name&amp;gt;&lt;/code&gt; 更新&lt;br&gt;&lt;code&gt;npm update -g&lt;/code&gt; 更新所有的全局包&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="-"&gt;删除包&lt;/h2&gt;
&lt;h3 id="-"&gt;本地删除&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm uninstall &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除包,但不会清理package.json中的依赖项,下次&lt;code&gt;npm ls&lt;/code&gt;时会报错缺少包&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm uninstall --save &amp;lt;package_name&amp;gt;&lt;/code&gt; 这样连依赖一起删掉&lt;/p&gt;
&lt;p&gt;如果只删除了依赖,没有删除包,下次&lt;code&gt;npm ls&lt;/code&gt;时会报多了包&lt;/p&gt;
&lt;p&gt;这时应该用&lt;code&gt;npm prune&lt;/code&gt;把包也删除掉&lt;/p&gt;
&lt;h3 id="-"&gt;全局删除&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm uninstall -g &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="-"&gt;发布包&lt;/h2&gt;
&lt;h3 id="-"&gt;创建用户&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm adduser&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;填入用户名密码邮箱, &lt;code&gt;https://www.npmjs.com/~用户名&lt;/code&gt;查看是否创建成功&lt;/p&gt;
&lt;h3 id="-"&gt;发布&lt;/h3&gt;
&lt;p&gt;确保package.json填写正确&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm publish&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果报错考虑是否package.json中的name有重复了,修改后再次发布试试.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="-"&gt;更新发布的包&lt;/h2&gt;
&lt;p&gt;修改后再次&lt;code&gt;npm publish&lt;/code&gt; 后会报错,是因为没有修改version.&lt;br&gt;手动修改package.json或者用下边三条命令来修改版本后,再publish&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm version patch&lt;/code&gt; //末位&lt;br&gt;&lt;code&gt;npm version minor&lt;/code&gt; //中间&lt;br&gt;&lt;code&gt;npm version major&lt;/code&gt; //首位&lt;/p&gt;
&lt;h3 id="-"&gt;关于版本号&lt;/h3&gt;
&lt;p&gt;对于 &lt;strong&gt;发布者&lt;/strong&gt; 来说当项目准备公开时,版本号应该为&lt;code&gt;1.0.0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Patch release&lt;/strong&gt;:  Bug fixes 或其他 minor changes: , 增加最后一位版本号, e.g. &lt;code&gt;1.0.1&lt;/code&gt; 对应命令&lt;code&gt;npm version patch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Minor release&lt;/strong&gt;: New features 不会破坏现有的 features, 增加中间位, e.g. &lt;code&gt;1.1.0&lt;/code&gt; 对应命令&lt;code&gt;npm version minor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Major release&lt;/strong&gt;: 不能向后兼容,增加首位, e.g. &lt;code&gt;2.0.0&lt;/code&gt;对应命令 &lt;code&gt;npm version major&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;strong&gt;使用者&lt;/strong&gt; 来说,可以安装指定的版本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install package_name@1.x&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;版本更多内容:&lt;br&gt;&lt;a href="https://docs.npmjs.com/misc/semver"&gt;https://docs.npmjs.com/misc/semver&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="-package-json"&gt;更新package.json&lt;/h2&gt;
&lt;p&gt;开发过程中更新包后，需要更新package.json里依赖的版本号到最新。&lt;/p&gt;
&lt;p&gt;最简单的办法是使用 &lt;code&gt;npm-check-updates&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install -g npm-check-updates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;显示当前项目所有依赖：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ ncu

 express           4.12.x  →   4.13.x
 multer            ^0.1.8  →   ^1.0.1
 react-bootstrap  ^0.22.6  →  ^0.24.0
 react-a11y        ^0.1.1  →   ^0.2.6
 webpack          ~1.9.10  →  ~1.10.5

Run with -u to upgrade your package.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;更新：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ ncu -u

 express           4.12.x  →   4.13.x

package.json upgraded
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新完毕。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="cnpm-"&gt;cnpm 镜像加速&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安装太慢可以使用淘宝镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://npm.taobao.org/"&gt;http://npm.taobao.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装 &lt;code&gt;cnpm&lt;/code&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装后就可以用&lt;code&gt;cnpm&lt;/code&gt;代替&lt;code&gt;npm&lt;/code&gt;了&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还有暂时用不到的有待研究：&lt;/p&gt;
&lt;p&gt;私有包&lt;br&gt;&lt;a href="https://docs.npmjs.com/getting-started/scoped-packages"&gt;https://docs.npmjs.com/getting-started/scoped-packages&lt;/a&gt;&lt;br&gt;tag&lt;br&gt;&lt;a href="https://docs.npmjs.com/getting-started/using-tags"&gt;https://docs.npmjs.com/getting-started/using-tags&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="-yarn-"&gt;更新：与 yarn 命令对比&lt;/h2&gt;
&lt;p&gt;来自： &lt;a href="https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison"&gt;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;npm (v5)&lt;/th&gt;
&lt;th&gt;Yarn&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;npm install&lt;/td&gt;
&lt;td&gt;yarn add&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;yarn add --flat&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;yarn add --har&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install --no-package-lock&lt;/td&gt;
&lt;td&gt;yarn add --no-lockfile&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;yarn add --pure-lockfile&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install [package] --save&lt;/td&gt;
&lt;td&gt;yarn add [package]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install [package] --save-dev&lt;/td&gt;
&lt;td&gt;yarn add [package] --dev&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;yarn add [package] --peer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install [package] --save-optional&lt;/td&gt;
&lt;td&gt;yarn add [package] --optional&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install [package] --save-exact&lt;/td&gt;
&lt;td&gt;yarn add [package] --exact&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;yarn add [package] --tilde&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install [package] --global&lt;/td&gt;
&lt;td&gt;yarn global add [package]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm update --global&lt;/td&gt;
&lt;td&gt;yarn global upgrade&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm rebuild&lt;/td&gt;
&lt;td&gt;yarn add --force&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm uninstall [package]&lt;/td&gt;
&lt;td&gt;yarn remove [package]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm cache clean&lt;/td&gt;
&lt;td&gt;yarn cache clean [package]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rm -rf node_modules &amp;amp;&amp;amp; npm install&lt;/td&gt;
&lt;td&gt;yarn upgrade&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm version major&lt;/td&gt;
&lt;td&gt;yarn version --major&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm version minor&lt;/td&gt;
&lt;td&gt;yarn version --minor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm version patch&lt;/td&gt;
&lt;td&gt;yarn version --patch&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
  </entry>
  <entry>
    <title>学会用好 Visual Studio Code</title>
    <id>http://nshen.net/article/2015-11-20/vscode</id>
    <link href="http://nshen.net/article/2015-11-20/vscode"/>
    <updated>2015-11-20T17:25:00.000Z</updated>
    <content>&lt;p&gt;Visual Studio Code是个牛逼的编辑器，启动非常快，完全可以用来代替其他文本文件编辑工具。又可以用来做开发，支持各种语言，相比其他IDE，轻量级完全可配置还集成Git感觉非常的适合前端开发，是微软亲生的想必TypeScript会支持的非常好。 所以我仔细研究了一下文档未来可能会作为主力工具使用。&lt;/p&gt;
&lt;h2 id="-command-palette"&gt;主命令框 Command Palette&lt;/h2&gt;
&lt;p&gt;最重要的功能就是 &lt;code&gt;F1&lt;/code&gt; 或 &lt;code&gt;Ctrl+Shift+P&lt;/code&gt; 打开的命令面板了，在这个命令框里可以执行VSCode的任何一条命令，可以查看每条命令对应的快捷键，甚至可以关闭这个编辑器。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/vscode/20160418095539.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;按一下&lt;code&gt;Backspace&lt;/code&gt;会进入到&lt;code&gt;Ctrl+P&lt;/code&gt;模式里&lt;/p&gt;
&lt;h1 id="ctrl-p-"&gt;Ctrl+P 模式&lt;/h1&gt;
&lt;p&gt;在&lt;code&gt;Ctrl+P&lt;/code&gt;下输入&lt;code&gt;&amp;gt;&lt;/code&gt;又可以回到&lt;strong&gt;主命令框&lt;/strong&gt; &lt;code&gt;Ctrl+Shift+P&lt;/code&gt;模式。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Ctrl+P&lt;/code&gt;窗口下还可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接输入文件名，快速打开文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 列出当前可执行的动作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt; 显示Errors或Warnings，也可以&lt;code&gt;Ctrl+Shift+M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:&lt;/code&gt; 跳转到行数，也可以&lt;code&gt;Ctrl+G&lt;/code&gt;直接进入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt; 跳转到symbol（搜索变量或者函数），也可以&lt;code&gt;Ctrl+Shift+O&lt;/code&gt;直接进入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@:&lt;/code&gt;根据分类跳转symbol，查找属性或函数，也可以&lt;code&gt;Ctrl+Shift+O&lt;/code&gt;后输入&lt;code&gt;:&lt;/code&gt;进入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 根据名字查找symbol，也可以&lt;code&gt;Ctrl+T&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="-"&gt;常用快捷键&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id="-"&gt;编辑器与窗口管理&lt;/h2&gt;
&lt;h3 id="-"&gt;同时打开多个窗口（查看多个项目）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;打开一个新窗口： &lt;code&gt;Ctrl+Shift+N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关闭窗口： &lt;code&gt;Ctrl+Shift+W&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-"&gt;同时打开多个编辑器（查看多个文件）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;新建文件 &lt;code&gt;Ctrl+N&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;历史打开文件之间切换 &lt;code&gt;Ctrl+Tab&lt;/code&gt;，&lt;code&gt;Alt+Left&lt;/code&gt;，&lt;code&gt;Alt+Right&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;切出一个新的编辑器（最多3个）&lt;code&gt;Ctrl+\&lt;/code&gt;，也可以按住Ctrl鼠标点击Explorer里的文件名&lt;/li&gt;
&lt;li&gt;左中右3个编辑器的快捷键&lt;code&gt;Ctrl+1&lt;/code&gt; &lt;code&gt;Ctrl+2&lt;/code&gt; &lt;code&gt;Ctrl+3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3个编辑器之间循环切换 Ctrl+` &lt;/li&gt;
&lt;li&gt;编辑器换位置，&lt;code&gt;Ctrl+k&lt;/code&gt;然后按&lt;code&gt;Left&lt;/code&gt;或&lt;code&gt;Right&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;代码编辑&lt;/h2&gt;
&lt;h3 id="-"&gt;格式调整&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;代码行缩进&lt;code&gt;Ctrl+[&lt;/code&gt;， &lt;code&gt;Ctrl+]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;折叠打开代码块 &lt;code&gt;Ctrl+Shift+[&lt;/code&gt;， &lt;code&gt;Ctrl+Shift+]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+C&lt;/code&gt; &lt;code&gt;Ctrl+V&lt;/code&gt;如果不选中，默认复制或剪切一整行&lt;/li&gt;
&lt;li&gt;代码格式化：&lt;code&gt;Shift+Alt+F&lt;/code&gt;，或&lt;code&gt;Ctrl+Shift+P&lt;/code&gt;后输入&lt;code&gt;format code&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修剪空格&lt;code&gt;Ctrl+Shift+X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上下移动一行： &lt;code&gt;Alt+Up&lt;/code&gt; 或 &lt;code&gt;Alt+Down&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;向上向下复制一行： &lt;code&gt;Shift+Alt+Up&lt;/code&gt;或&lt;code&gt;Shift+Alt+Down&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在当前行下边插入一行&lt;code&gt;Ctrl+Enter&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;在当前行上方插入一行&lt;code&gt;Ctrl+Shift+Enter&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-"&gt;光标相关&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;移动到行首：&lt;code&gt;Home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移动到行尾：&lt;code&gt;End&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移动到文件结尾：&lt;code&gt;Ctrl+End&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移动到文件开头：&lt;code&gt;Ctrl+Home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移动到后半个括号 &lt;code&gt;Ctrl+Shift+]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;选中当前行&lt;code&gt;Ctrl+i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择从光标到行尾&lt;code&gt;Shift+End&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;选择从行首到光标处&lt;code&gt;Shift+Home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除光标右侧的所有字&lt;code&gt;Ctrl+Delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Shrink/expand selection： &lt;code&gt;Shift+Alt+Left&lt;/code&gt;和&lt;code&gt;Shift+Alt+Right&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Multi-Cursor：可以连续选择多处，然后一起修改，&lt;code&gt;Alt+Click&lt;/code&gt;添加cursor或者&lt;code&gt;Ctrl+Alt+Down&lt;/code&gt; 或 &lt;code&gt;Ctrl+Alt+Up&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同时选中所有匹配的&lt;code&gt;Ctrl+Shift+L&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+D&lt;/code&gt;下一个匹配的也被选中(被我自定义成删除当前行了，见下边&lt;code&gt;Ctrl+Shift+K&lt;/code&gt;)    &lt;/li&gt;
&lt;li&gt;回退上一个光标操作&lt;code&gt;Ctrl+U&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-"&gt;重构代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;跳转到定义处：&lt;code&gt;F12&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义处缩略图：只看一眼而不跳转过去&lt;code&gt;Alt+F12&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列出所有的引用：&lt;code&gt;Shift+F12&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同时修改本文件中所有匹配的：&lt;code&gt;Ctrl+F12&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重命名：比如要修改一个方法名，可以选中后按&lt;code&gt;F2&lt;/code&gt;，输入新的名字，回车，会发现所有的文件都修改过了。&lt;/li&gt;
&lt;li&gt;跳转到下一个Error或Warning：当有多个错误时可以按&lt;code&gt;F8&lt;/code&gt;逐个跳转&lt;/li&gt;
&lt;li&gt;查看diff 在explorer里选择文件右键 &lt;code&gt;Set file to compare&lt;/code&gt;，然后需要对比的文件上右键选择&lt;code&gt;Compare with &amp;#39;file_name_you_chose&amp;#39;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-"&gt;查找替换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查找 &lt;code&gt;Ctrl+F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查找替换 &lt;code&gt;Ctrl+H&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;整个文件夹中查找 &lt;code&gt;Ctrl+Shift+F&lt;/code&gt;&lt;br&gt;匹配符：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; to match one or more characters in a path segment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; to match on one character in a path segment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**&lt;/code&gt; to match any number of path segments ,including none&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; to group conditions (e.g. &lt;code&gt;{**/*.html,**/*.txt}&lt;/code&gt; matches all html and txt files)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; to declare a range of characters to match (e.g., &lt;code&gt;example.[0-9]&lt;/code&gt; to match on &lt;code&gt;example.0&lt;/code&gt;,&lt;code&gt;example.1&lt;/code&gt;, …&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;显示相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全屏：&lt;code&gt;F11&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;zoomIn/zoomOut：&lt;code&gt;Ctrl + =&lt;/code&gt;/&lt;code&gt;Ctrl + -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;侧边栏显/隐：&lt;code&gt;Ctrl+B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;侧边栏4大功能显示：&lt;ul&gt;
&lt;li&gt;Show Explorer &lt;code&gt;Ctrl+Shift+E&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;Show Search&lt;code&gt;Ctrl+Shift+F&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;Show Git&lt;code&gt;Ctrl+Shift+G&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;Show Debug&lt;code&gt;Ctrl+Shift+D&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Show Output&lt;code&gt;Ctrl+Shift+U&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;预览markdown&lt;code&gt;Ctrl+Shift+V&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自动保存：File -&amp;gt; AutoSave ，或者&lt;code&gt;Ctrl+Shift+P&lt;/code&gt;，输入 auto &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="-"&gt;皮肤预览&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;f1&lt;/code&gt;后输入 &lt;code&gt;theme&lt;/code&gt; 回车，然后上下键即可预览&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/vscode/preview_themes.gif" alt=""&gt;&lt;/p&gt;
&lt;h1 id="-settings-json"&gt;自定义settings.json&lt;/h1&gt;
&lt;p&gt;&lt;img src="/image/vscode/20160418105531.png" alt=""&gt;&lt;/p&gt;
&lt;h2 id="user-settings-vs-code-"&gt;&lt;code&gt;User settings&lt;/code&gt; 是全局设置，任何vs Code打开的项目都会依此配置。&lt;/h2&gt;
&lt;p&gt; 默认存储在:&lt;/p&gt;
&lt;p&gt;Windows: &lt;code&gt;%APPDATA%\Code\User\settings.json&lt;/code&gt;&lt;br&gt;Mac: &lt;code&gt;$HOME/Library/Application Support/Code/User/settings.json&lt;/code&gt;&lt;br&gt;Linux: &lt;code&gt;$HOME/.config/Code/User/settings.json&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="workspace-settings-"&gt;&lt;code&gt;Workspace settings&lt;/code&gt; 是本工作区的设置，会覆盖上边的配置&lt;/h2&gt;
&lt;p&gt;存储在工作区的&lt;code&gt;.vocode&lt;/code&gt;文件夹下。&lt;/p&gt;
&lt;p&gt;几乎所有设定都在&lt;code&gt;settings.json&lt;/code&gt;里，包括&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Editor Configuration - font, word wrapping, tab size, line numbers, indentation, ...&lt;/li&gt;
&lt;li&gt;Window Configuration - restore folders, zoom level, ...&lt;/li&gt;
&lt;li&gt;Files Configuration - excluded file filters, default encoding, trim trailing whitespace, ...&lt;/li&gt;
&lt;li&gt;File Explorer Configuration - encoding, WORKING FILES behavior, ...&lt;/li&gt;
&lt;li&gt;HTTP Configuration - proxy settings&lt;/li&gt;
&lt;li&gt;Search Configuration - file exclude filters&lt;/li&gt;
&lt;li&gt;Git Configuration - disable Git integration, auto fetch behavior&lt;/li&gt;
&lt;li&gt;Telemetry Configuration - disable telemetry reporting, crash reporting&lt;/li&gt;
&lt;li&gt;HTML Configuration - HTML format configuration&lt;/li&gt;
&lt;li&gt;CSS Configuration - CSS linting configuration&lt;/li&gt;
&lt;li&gt;JavaScript Configuration - Language specific settings&lt;/li&gt;
&lt;li&gt;JSON Configuration - Schemas associated with certain JSON files&lt;/li&gt;
&lt;li&gt;Markdown Preview Configuration - Add a custom CSS to the Markdown preview&lt;/li&gt;
&lt;li&gt;Less Configuration - Control linting for Less&lt;/li&gt;
&lt;li&gt;Sass Configuration - Control linting for Sass&lt;/li&gt;
&lt;li&gt;TypeScript Configuration - Language specific settings&lt;/li&gt;
&lt;li&gt;PHP Configuration - PHP linter configuration&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如可以修改让vscode认识&lt;code&gt;.glsl&lt;/code&gt;扩展名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{

    // Configure file associations to languages (e.g. &amp;quot;*.extension&amp;quot;: &amp;quot;html&amp;quot;). These have precedence over the default associations of the languages installed.
    &amp;quot;files.associations&amp;quot;: {
        &amp;quot;*.glsl&amp;quot;: &amp;quot;shaderlab&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="-"&gt;修改默认快捷键&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;File -&amp;gt; Preferences -&amp;gt; Keyboard Shortcuts&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;keybindings.json&lt;/code&gt;，我的显示在这里&lt;code&gt;C:\Users\Administrator\AppData\Roaming\Code\User\keybindings.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Place your key bindings in this file to overwrite the defaults
[
    //ctrl+space被切换输入法快捷键占用
    {
        &amp;quot;key&amp;quot;: &amp;quot;ctrl+alt+space&amp;quot;,
        &amp;quot;command&amp;quot;: &amp;quot;editor.action.triggerSuggest&amp;quot;,
        &amp;quot;when&amp;quot;: &amp;quot;editorTextFocus&amp;quot;
    },
    // ctrl+d删除一行
    {
        &amp;quot;key&amp;quot;: &amp;quot;ctrl+d&amp;quot;,
        &amp;quot;command&amp;quot;: &amp;quot;editor.action.deleteLines&amp;quot;,
        &amp;quot;when&amp;quot;: &amp;quot;editorTextFocus&amp;quot;
    },
    {
        &amp;quot;key&amp;quot;: &amp;quot;ctrl+shift+k&amp;quot;, //与删除一行的快捷键互换了：）
        &amp;quot;command&amp;quot;: &amp;quot;editor.action.addSelectionToNextFindMatch&amp;quot;,
        &amp;quot;when&amp;quot;: &amp;quot;editorFocus&amp;quot;
    },
    //ctrl+shift+/多行注释
    {
        &amp;quot;key&amp;quot;:&amp;quot;ctrl+shift+/&amp;quot;,
        &amp;quot;command&amp;quot;: &amp;quot;editor.action.blockComment&amp;quot;,
        &amp;quot;when&amp;quot;: &amp;quot;editorTextFocus&amp;quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id="-"&gt;自定义代码段&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src="/image/vscode/20160401113811.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;然后输入语言,例如我这里输入 &lt;code&gt;typescript&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于每次输入箭头函数&lt;code&gt;() =&amp;gt; {}&lt;/code&gt;太烦了，我这里加入一段加入一段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;quot;arrow function&amp;quot;: {
        &amp;quot;prefix&amp;quot;: &amp;quot;func&amp;quot;,
        &amp;quot;body&amp;quot;: [
            &amp;quot;(${e}) =&amp;gt; {$1}&amp;quot;
        ],
        &amp;quot;description&amp;quot;: &amp;quot;arrow function&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;保存后，下次输入&lt;code&gt;func&lt;/code&gt;的时候就会自动出来箭头函数了&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/vscode/20160401114330.png" alt=""&gt;&lt;/p&gt;
&lt;h1 id="-typescript-"&gt;配置TypeScript环境&lt;/h1&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;首先覆盖默认ctrl + space快捷键，因为这个快捷键被输入法切换占用了&lt;br&gt;&lt;code&gt;C:\Users\Administrator\AppData\Roaming\Code\User\keybindings.json&lt;/code&gt;&lt;br&gt;加入 &lt;pre&gt;&lt;code&gt;// Place your key bindings in this file to overwrite the defaults
[
{ &amp;quot;key&amp;quot;: &amp;quot;ctrl+alt+space&amp;quot;,            &amp;quot;command&amp;quot;: &amp;quot;editor.action.triggerSuggest&amp;quot;,
                                  &amp;quot;when&amp;quot;: &amp;quot;editorTextFocus&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;File - Open Folder 打开项目的目录&lt;/li&gt;
&lt;li&gt;创建 &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;{}&lt;/code&gt; ,在大括号中间 &lt;code&gt;ctrl + alt + space&lt;/code&gt; （上边的自定义键盘）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="/image/vscode/11979441.png" alt=""&gt;&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;输入&lt;pre&gt;&lt;code&gt;{
 &amp;quot;compilerOptions&amp;quot;: {
     &amp;quot;target&amp;quot;: &amp;quot;ES5&amp;quot;,
     &amp;quot;module&amp;quot;: &amp;quot;amd&amp;quot;,
     &amp;quot;sourceMap&amp;quot;: true
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;可以创建&lt;code&gt;.ts&lt;/code&gt;文件了&lt;/li&gt;
&lt;li&gt;配置TaskRunner &lt;code&gt;Ctrl+Shift+P&lt;/code&gt; 输入 &lt;code&gt;Configure Task Runner&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run Task &lt;code&gt;Ctrl+Shift+B&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="-typings"&gt;安装typings&lt;/h1&gt;
&lt;p&gt;Install typings to bring in the .d.ts files which power javascript intellisense.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install typings --global

# Search for definitions.
typings search tape

# Find an available definition (by name).
typings search --name react

# Install typings (DT is &amp;quot;ambient&amp;quot;, make sure to enable the flag and persist the selection in `typings.json`).
typings install react --ambient --save
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;install will create a typings folder. VS Code will reference the .d.ts files for intellisense.&lt;/p&gt;
&lt;h1 id="-"&gt;插件&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;新版本支持插件安装了&lt;/p&gt;
&lt;p&gt;插件市场 &lt;a href="https://marketplace.visualstudio.com/#VSCode"&gt;https://marketplace.visualstudio.com/#VSCode&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="-"&gt;安装插件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;F1&lt;/code&gt; 输入 &lt;code&gt;extensions&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/vscode/29945359.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;点击第一个开始安装或升级，或者也可以  &lt;code&gt;Ctrl+P&lt;/code&gt; 输入 &lt;code&gt;ext install&lt;/code&gt;进入&lt;br&gt;点击第二个会列出已经安装的扩展，可以从中卸载&lt;/p&gt;
&lt;p&gt;ext install &lt;/p&gt;
&lt;h3 id="-"&gt;我在用的插件(期待更新...)&lt;/h3&gt;
&lt;h4 id="docthis-jsdoc-"&gt;docthis 插件可以自动添加JSDoc注释。&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ctrl + p&lt;/code&gt; 后 输入&lt;code&gt;ext install docthis&lt;/code&gt; 可直接安装。&lt;/p&gt;
&lt;p&gt;安装后连续两次 &lt;code&gt;Ctrl+Alt+D&lt;/code&gt; 即可在光标处插入注释。&lt;/p&gt;
&lt;p&gt;详细： &lt;a href="https://marketplace.visualstudio.com/items?itemName=joelday.docthis"&gt;https://marketplace.visualstudio.com/items?itemName=joelday.docthis&lt;/a&gt;&lt;/p&gt;
&lt;h4 id="vscode-todo-todo-"&gt;vscode-todo 显示todo列表&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ctrl + p&lt;/code&gt; 后 输入&lt;code&gt;ext install vscode-todo&lt;/code&gt; 可直接安装。&lt;/p&gt;
&lt;p&gt;详细: &lt;a href="https://marketplace.visualstudio.com/items?itemName=MattiasPernhult.vscode-todo"&gt;https://marketplace.visualstudio.com/items?itemName=MattiasPernhult.vscode-todo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.johnpapa.net/learning-visual-studio-code/" title="Learning Visual Studio Code"&gt;Learning Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.visualstudio.com/docs/customization/keybindings" title="Key Bindings for Visual Studio Code"&gt;Key Bindings for Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Microsoft/vscode-tips-and-tricks" title="VS Code Tips and Tricks"&gt;VS Code Tips and Tricks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>读书《Learn More Study Less》整体性学习法</title>
    <id>http://nshen.net/article/2015-11-03/learn-more-study-less</id>
    <link href="http://nshen.net/article/2015-11-03/learn-more-study-less"/>
    <updated>2015-11-03T09:21:00.000Z</updated>
    <content>&lt;p&gt;忘记在哪里看到这本书的介绍了，据说是一个小子自学1年，完成了4年麻省理工的课程，然后写了一本他学习方法的书。&lt;br&gt;我搜了一下，居然中英文版都有，就花时间好好读了一遍，就是这本。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/learnMoreStudyLess/book.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;以下是这本书的完整笔记：&lt;/p&gt;
&lt;!--more--&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;整体性学习法是一套能更准确描述大脑如何运作的学习理论。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="-3-idea-"&gt;整体性学习法基于这3个idea：&lt;/h2&gt;
&lt;p&gt;&lt;img src="/image/learnMoreStudyLess/0.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="-constructs"&gt;结构 Constructs&lt;/h3&gt;
&lt;p&gt;一个结构，就像脑中的一座城市， 大脑中有无数个这种城市， 比如 c++结构(c++ city)， 这个结构定义了你知道的c++所有知识和你对c++所有知识点(ideas)的interconnected的总和. 而某一个知识点(idea)就像这个city中的一个building， building之间连接的道路越多越容易越容易在知识点中穿梭，所以当建造一个Construct (城市)的时候，你的目标应该是在ideas之间建设尽可能多的interconnections。&lt;/p&gt;
&lt;h4 id="-familiar-constructs"&gt;常见的结构 Familiar Constructs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;感知结构 Sensory Constructs&lt;br&gt;很多的图像，声音，感觉通过经验聚集在一起。&lt;/li&gt;
&lt;li&gt;关系结构 Relationship Constructs&lt;br&gt;故事，人，人们之间的交互定义了我们的经验. 有没有精彩的故事能让要学习的主题更容易理解?&lt;/li&gt;
&lt;li&gt;基础数学结构 Basic Math Constructs&lt;br&gt;这些非常明显的数学基础可以用来简化其他主题之间的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-models"&gt;模型 Models&lt;/h3&gt;
&lt;p&gt;模型是简化的结构，是内容的精华 ，如果结构是一本书的话，模型就是书的目录。模型的目的是压缩信息，把核心概念链接起来，就创造了一个模型。刚开始学习某门知识的时候通常先建设模型，模型不需要特别精确，随着理解的增加，继续修正模型，或者重建新的模型。可以通过想象和可视化的方法创建模型(把子空间想想成蓝背景上的一个红色网格，把变量想象成装不同类型的瓶子)&lt;/p&gt;
&lt;h3 id="-highways"&gt;高速公路 Highways&lt;/h3&gt;
&lt;p&gt;孤立结构(Construct)之间的联系就是高速公路(Highways)增加城市之间的联系，即结构与结构之间的联系。&lt;br&gt;建立高速公路的好处不会马上显现出来。如果你想上学取得好成绩，很多老师会强调要有良好定义的结构，而不要大脑里塞满了各种高速公路。&lt;br&gt;然而，高速公路能激发创造力。“跳出盒子”之外思考最恰当地描述了那些在结构之外思考的人们。以不曾想过的方式将常人眼里风马牛不相及的专业联系在一起思考，这就是创造。&lt;br&gt;利用高速公路可以在专业交叉的领域建立起新的结构。（这种不同专业间的比喻好处是，它比用生活经验来比喻更容易产生新知识）。 &lt;/p&gt;
&lt;p&gt;结构，模型， 高速公路，形成了holistic learning的骨架 ， 是下边要介绍的学习方法的理论基础， 有了这些基础你就可以知道这些学习方法是否有效，甚至修改或创建你自己的学习方法.&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/learnMoreStudyLess/1.png" alt=""&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="-6-"&gt;整体性学习法的6个学习阶段&lt;/h2&gt;
&lt;p&gt;6个是独立的阶段，通常不需要全部完成就可以通过考试，也不必按照指定的顺序执行，重要的是每一个阶段都是学习中的关键活动，经常性的缺失某步，学习就会失败，所学信息不会进入holistic网络。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/learnMoreStudyLess/2.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="-acquire"&gt;获取 Acquire&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Receiving information through your senses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  获取的目标是以最精简的形式获取信息。包括听到的和看到的信息。例如：阅读，上课记笔记，个人的经历，都是获取阶段。&lt;/p&gt;
&lt;p&gt;获取信息3个指标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化：剔除冗余，只获取有用的信息。&lt;/li&gt;
&lt;li&gt;容量：获取的越多越好。&lt;/li&gt;
&lt;li&gt;速度：越快越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加强读写方法，在这个阶段会有很大的改善空间。&lt;/p&gt;
&lt;h4 id="-"&gt;获取能力薄弱表现在&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;阅读，听讲需要很长时间。&lt;/li&gt;
&lt;li&gt;需要反复阅读才能得到所有基础信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="-"&gt;主要原因在于：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;没有好的阅读和学习习惯。&lt;/li&gt;
&lt;li&gt;笔记记得差，不是记得太多，就是太少。&lt;/li&gt;
&lt;li&gt;不懂基础术语，或英语太烂。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-understand"&gt;理解 Understand&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Get the surface of information.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解的目标是把获取到的原始的信息，给予其上下文意义。这也许是你要执行的最基础的interlinking。&lt;/p&gt;
&lt;p&gt;读再多不理解也是没用，如果不理解，想要记住他几乎是不可能的，大多数人能感觉到明白阶段的存在。虽然信息经过初步理解后变得有意义，但是此时信息还没有很牢固地扎根于你的大脑中。&lt;br&gt;这个阶段可以理解事情的表面意义。比如你学了一个数学公式，你知道了每个符号的意思，可以用这个公式解题了，那么重复这个公式足够多次就有可能记住这个公式。&lt;/p&gt;
&lt;p&gt;大多数人在这个阶段就止步不前了，这个阶段你只是简单的链接了足够的信息，理解了信息，可是这远远不够，你也许不能知道公式是怎么推导的，或者不知道怎么把这个公式应用到外边其他的问题里。&lt;br&gt;即使这个阶段有很多限制，但你必须先通过了理解这个阶段，才能进行下边更深入的研究&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Learning by rote is learning with only the Understand Phase.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解能力薄弱表现在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然读了，但不懂作者说的是什么。&lt;/li&gt;
&lt;li&gt;笔记记得挺清晰完美，但却不明白什么意思。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不是大不了的问题，可以放慢速度，寻找更容易理解的材料来学。&lt;/p&gt;
&lt;h3 id="-explore"&gt;探索 Explore&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Connect that basic idea to others.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;探索才是整体性学习法的开始，理解只是表面，这个阶段需要用 &lt;em&gt;模型 models&lt;/em&gt; 来简化和扩展 &lt;em&gt;结构constructs&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;经历过理解阶段，一个整体性学习者在这个阶段会问：这个公式从哪来的？这个公式的每个部分有什么不同？哪些部分可以改变？改变后会得到什么样的结果？其他公式和这个公式有什么异同？&lt;br&gt;这样虽然会浪费些时间，但一旦这些方法成为习惯，探索自然而然的就完成了，理解不能让你满足，好奇心会驱使你去联系新的材料。&lt;/p&gt;
&lt;p&gt;探索有3种主要形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Depth Exploration 深度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exploring the background of an idea.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;深度探索不止要你理解一个公式，还要理解为什么公式被开发出来，被谁开发出来？公式从哪来的？怎样发现的？为什么会这样？&lt;br&gt;&lt;strong&gt;深度探索是去探究知识的背景&lt;/strong&gt;。&lt;br&gt;深度拓展可能是牢牢锁定知识的最佳方法，但是同时也是最花时间的工作。            &lt;/p&gt;
&lt;p&gt;  create links into information&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lateral Exploration 横向&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exploring associated ideas.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;信息不是孤立的，有哪些公式跟这个比较像？这个公式被发现的时候还发现了哪些公式？同一个作者，或同一个领域还有哪些发现？&lt;br&gt;横向探索比深度探索少一些研究，但更多一些创造性。&lt;br&gt;create links around information ，意味着创建&lt;em&gt;模型models&lt;/em&gt;，与原知识建立关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vertical Exploration 纵向&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exploring the idea as it relates to different constructs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;信息是有模式的，这些模式可以在其它信息中找到，意味着在完全不相关的领域也能找到联系，是在&lt;em&gt;结构Constructs&lt;/em&gt;间建立&lt;em&gt;高速公路Highways&lt;/em&gt;。&lt;br&gt;这是最难的，也是最需要创造性的。&lt;/p&gt;
&lt;p&gt;Metaphor and visceralization both work best 在这个阶段&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;画图有助于这3种探索。&lt;/p&gt;
&lt;p&gt;Exploration弱主要表现为：&lt;/p&gt;
&lt;p&gt;inflexibility（缺少灵活性），不能把遇到的知识与其他领域学习过的知识联系起来。假如让你用这个新的知识去解决一个非常规问题，就常常束&lt;br&gt;手无策。&lt;/p&gt;
&lt;p&gt;Explore是整体性学习法发力的地方，这里目标是塑造 模型models ，高速公路highways， 广泛的联系来定义完整的结构constructs&lt;/p&gt;
&lt;h3 id="-debug"&gt;纠错 Debug&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Prune away false connections.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习不可能不出错，错误的联系可能导致错误的理解。你以为理解正确，实际上是从错误的联系推导而来。&lt;/p&gt;
&lt;p&gt;Debug阶段是在模型models和高速公路highways上寻找错误，除去多余的联系。&lt;br&gt;纠错的唯一途径就是实践(纠错可以采取很多种方法，包括阅读那些与你的观点相反的书籍，以及把你的结论放入现实世界中)&lt;/p&gt;
&lt;p&gt;Debug弱主要表现在：&lt;/p&gt;
&lt;p&gt;inaccurate connections（错误联系太多）&lt;/p&gt;
&lt;h3 id="-apply"&gt;应用 Apply&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Take an idea and give it meaning beyond immediate uses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应用把纠错Debug带入更高一级，通过比较（知识）信息是如何在现实中运行的来进行调整，如果理解不符合现实世界，那么再多也无用。在这一步失败的典型例子就是书呆子，那些读书读得很好但是出了学校大门却茫然不知所措的家伙。&lt;/p&gt;
&lt;p&gt;知识中的很大一部分存在于潜意识中，这部分知识如果不去运用就得不到很好的发展。读了图书馆里所有的管理学书籍也只是理解了管理学的概念，但是如果能亲自管理企业，那么对概念就不仅仅是理解，而且是一种感觉。　创造新的途径，应用所学知识到你的生活中去，这是整体性学习的最后环节，也是最终目的。更多的实践，抛开书本，走出去，去做实验，去接触生活，去融入社会。 &lt;/p&gt;
&lt;p&gt;Apply应用弱主要表现在：&lt;/p&gt;
&lt;p&gt; 不能在真实世界中很好地运用知识&lt;/p&gt;
&lt;p&gt;解决办法： 少理论，多实践&lt;/p&gt;
&lt;h3 id="-test"&gt;测试 Test&lt;/h3&gt;
&lt;p&gt;测试不是一个独立的步骤，上边的每个步骤之后都要执行这个测试Test步骤 ， Testing是为了检查每个步骤执行的怎么样，没有自我检查你就不会意识到每一步执行的到底怎么样， 测试有助于迅速定位问题所在，帮助你改进学习的方法，克服缺点。&lt;/p&gt;
&lt;p&gt;通过测试可以了解到你对知识的理解程度，对上边的每个阶段都要问自己&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Acquire Test - Have I seen/listened to the idea before?&lt;/li&gt;
&lt;li&gt;Understand Test - Do I get (at a surface level) what this idea means?&lt;/li&gt;
&lt;li&gt;Explore Test - Do I understand where this idea comes from, what it is related to  and what outside ideas can be connected with it? &lt;/li&gt;
&lt;li&gt;Debug Test - Have I removed inappropriate links between this idea and others? Have I removed false conclusions based on connections that don’t actually exist?&lt;/li&gt;
&lt;li&gt;Apply Test - Have I used this idea in my practical life?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-"&gt;总结&lt;/h3&gt;
&lt;p&gt;强调上述步骤并非线性，而应是可以灵活跳过某个步骤的环形，找出薄弱环节，每个人的薄弱点不同。整体性学习法每一步都很重要，一旦你知道了弱点所在， 你可以通过多多练习来改进它。一开始， 采用新技术总是要花点时间的， 但是一旦你掌握之后，它们就成了属于你自己的学习策略。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="-"&gt;信息类型&lt;/h2&gt;
&lt;p&gt;&lt;img src="/image/learnMoreStudyLess/3.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="arbitrary-"&gt;Arbitrary 随意信息&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Facts, dates, lists, rules and sequences. They have little logical grouping or depth.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一系列事实，日期，定义或规则，没有逻辑，需要理解的工作少，需要反复的机械记忆，死记硬背。&lt;br&gt;处理这种信息，第一目标是尽量找到潜在逻辑关系。&lt;/p&gt;
&lt;h3 id="opinion-"&gt;Opinion 观点信息&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Information gathered for the sole purpose of supporting or defeating your argument.&lt;br&gt;Volume is important here, rather than being able to memorize.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是存在争论的信息。难点在于获取阶段；速读技巧（检查大量的信息以寻找其中的模式，而不是去记忆具体的细节）&lt;/p&gt;
&lt;h3 id="process-"&gt;Process 过程信息&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Information in the form of skills. Requires practice, but is easier to remember.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过程信息是需要付诸行动的信息。写个程序，造个房子，设计个原型都是基于过程信息的。不断练习对这类信息最重要。&lt;br&gt;大多数过程信息都&lt;strong&gt;依赖于正确的模型&lt;/strong&gt;。通过练习可以缓慢地形成一个结构， 有正确的模型可以提高学习速度。&lt;br&gt;你无须全部学习材料，拥有正确的背景模型，你就可以练习那些教你的动作。&lt;br&gt;过程信息的好处是，如果你练习了，它比其他类型的信息记得更牢，时间更长。通过练习，可以将模型与你的知识结构更好地融合在一起。 &lt;/p&gt;
&lt;h3 id="concrete-"&gt;Concrete 具体信息&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Ideas that are easy to visualize. These are often practical ideas that are easy to experience.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 是那些在实际中可以观察到、看到、听到或触到的信息。&lt;/p&gt;
&lt;h3 id="abstract-"&gt;Abstract 抽象信息&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Ideas that are difficult to experience. Math, philosophy and physics are some of the most abstract fields.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象信息和具体信息很像，但缺少与感官的明显连接。数学、物理、 心理学、 计算机和化学都依赖抽象信息。 量子物理学和微积分中有大量抽象的信息，不容易马上想象出图像来。&lt;br&gt;抽象信息与随意信息（Arbitrary）正好相反， 非常难以理解， 但是逻辑性很强， 而随意信息非常浅显，但是逻辑性差， 抽象信息的学习好比潜入深海的探索。&lt;/p&gt;
&lt;p&gt;在学习抽象信息时，整体性学习优势明显。通过将信息转化为更容易想象成图像的形式，你可以为知识建立广泛联系。&lt;br&gt;Visceralization and metaphor(内在化和比喻法)是对于将复杂知识简化至关重要，Model debugging (模型纠错)也很重要，因为一开始你建立的模型总是存在各种各样的错误。 &lt;/p&gt;
&lt;p&gt;抽象信息的难点：理解和拓展阶段显得难以忍受。假如你感到理解困难，可以降低接受信息的速度，将前面的信息深入地探究。这种知识的特点是一环接着一环，所以打好基础至关重要。 &lt;/p&gt;
&lt;p&gt;判断要学习的信息是属于哪种类型，就可以决定学习时使用什么技术， 以及估算记忆时会遇到的困难.&lt;/p&gt;
&lt;h3 id="-"&gt;结构强弱&lt;/h3&gt;
&lt;p&gt;Arbitrary(随意信息)结构最弱，  难以进行整体性学习， 应尽力找出其中的逻辑，能帮助记忆，实在不行要这几种方法了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linking 联想法&lt;/li&gt;
&lt;li&gt;Pegging 挂钩法 &lt;/li&gt;
&lt;li&gt;Compression 压缩法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Concrete(具体信息)和Process(过程信息)是最强的结构， 他们都可以创建有形的经验来帮助你通过感觉来与新知识建立连接。&lt;/p&gt;
&lt;p&gt;结构越强，越容易进行整体性学习，本书的很多方法都教你将弱结构，变为强结构来学习。&lt;/p&gt;
&lt;p&gt;根据强度选择方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Weak – Learning through repetition.&lt;/li&gt;
&lt;li&gt;Better – Learning with linking, pegging or information compression.&lt;/li&gt;
&lt;li&gt;Best – Learning with metaphor, visceralization or diagrams.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="-"&gt;常用技术&lt;/h2&gt;
&lt;p&gt;&lt;img src="/image/learnMoreStudyLess/4.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="-speed-reading"&gt;快速阅读 Speed Reading&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指读法 ：食指放在要读的文字下边，用手指控制阅读速度。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;积极阅读：在笔记本上写下每章的标题，包括子标题，每读完一部分（指读法），写一些笔记。&lt;br&gt;在阅读过程中需要记下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这节的主要点是什么。（获取完整）&lt;/li&gt;
&lt;li&gt;怎么能记住这节的要点。（link, visualize or metaphor）&lt;/li&gt;
&lt;li&gt;怎样才能扩展和应用这节的要点。（应用） &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;积极阅读缺点是太慢，只在不易理解和记忆的部分用这种阅读方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-flow-based-note-taking"&gt;笔记流 Flow-Based Note Taking&lt;/h3&gt;
&lt;p&gt;只写主要观点，尽量少的词汇，用箭头把观点连接起来。&lt;/p&gt;
&lt;p&gt;好处：可以配合其他方法（Metaphor, diagraming and information compression ）加强理解。&lt;/p&gt;
&lt;h3 id="linking-ideas"&gt;Linking ideas&lt;/h3&gt;
&lt;p&gt; 这两种信息才需要链接，其他的一般不需要特别的学习方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Difficult information 困难信息 (可以是没有逻辑一系列步骤，或者是一个日期列表。使用linking methods记得牢)&lt;/li&gt;
&lt;li&gt;Critical information  关键信息 （是建筑的地基，是其他知识的基础，比如矩阵的行列式，不理解的话，其他的就没法学）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果不是特别关键和困难的信息，就没必要采取专门的技术。因为大部分的学习过程是&lt;br&gt;潜意识的，你在不知不觉中就可能形成了足够的联系和模型，而没有应用什么专门的技术。&lt;/p&gt;
&lt;p&gt;metaphor, visceralization or diagrams 是最基本的行成模型的方法。&lt;/p&gt;
&lt;h3 id="-metaphor"&gt;比喻 Metaphor&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Look for a story, image or process that mirrors what you are studying.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在不熟悉的概念和熟悉的概念之间假设一座桥&lt;/p&gt;
&lt;p&gt;metaphors in holistic learning are more often used to connect similar processes, events or ordering of information.&lt;/p&gt;
&lt;p&gt;如何找到比喻 ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定你要理解或记忆的信息。&lt;/li&gt;
&lt;li&gt;在个人经验中寻找与信息相似的东西，允许不完美的比喻。&lt;/li&gt;
&lt;li&gt;重复这个过程，检查比喻不恰当的地方。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;技巧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要有寻找比喻的欲望&lt;/li&gt;
&lt;li&gt;注意第一个出现在脑海中的念头&lt;/li&gt;
&lt;li&gt;优化测试你的比喻&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-visceralization"&gt;内在化 Visceralization&lt;/h3&gt;
&lt;p&gt;内在化指不仅仅在脑海中出现图像，而且有声音、触觉和情感等。是将信息由你不熟悉的类型转化为你容易理解和联系的方式。拿起笔和纸来练习,看到纸上活灵活现的图像会让你记得更清楚。 &lt;/p&gt;
&lt;p&gt;如何：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;明确你要内在化的概念（可以是个函数，或是一个数学概念）&lt;/li&gt;
&lt;li&gt;以这个概念为基础在脑中建立一个图片（mental image）&lt;/li&gt;
&lt;li&gt;脑图是静态的还是随时间变化的？如果是静态的尝试动起来&lt;/li&gt;
&lt;li&gt;现在添加其他感觉，尝试把它拿起来，操作它，用你的身体感觉它，将所有的感觉与运动的图像相联系。&lt;/li&gt;
&lt;li&gt;加入其它感觉或 情绪的影响到脑图上。&lt;/li&gt;
&lt;li&gt;提炼并重复图像直到你提起这个图像就能联想到知识&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;比喻和内在化可以结合使用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="diagraming-"&gt;Diagraming 图示法&lt;/h3&gt;
&lt;p&gt;是内在化的简单版，但比内在化浪费时间。&lt;br&gt;好处是可以容易的与笔记流和积极阅读结合使用&lt;br&gt;就是一个压缩了多个概念的图片，最常见的是charts&lt;br&gt;有3种主要的图：流简图flow， concept and image diagrams. &lt;/p&gt;
&lt;h4 id="flow-based-diagrams-"&gt;Flow-Based Diagrams 流简图&lt;/h4&gt;
&lt;p&gt;最基本的流简图就是用箭头连接各个相关的元素。&lt;br&gt;从最原始的观点出发，逐步画出其他相关的观点来。&lt;br&gt;不需要画的漂亮，注重理解。&lt;/p&gt;
&lt;p&gt;适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绘制一系列步骤（怎样做长除法，怎样写现金流转声明）&lt;/li&gt;
&lt;li&gt;绘制历史事件，创造分支将事件联系在一起，不仅通过事件之间的因果关系，而且根据事件的发生时间来建立联系。&lt;/li&gt;
&lt;li&gt;绘出一个系统（例如：函数在程序中怎样执行的？）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="concept-based-diagrams-"&gt;Concept-Based Diagrams 概念图&lt;/h4&gt;
&lt;p&gt;步骤不重要，但关系很重要，箭头上要写上1-3个词来描述这两个概念的关联。&lt;br&gt;从最重要的观点出发，不断发出分支细化知识及分解观点。&lt;/p&gt;
&lt;h4 id="image-diagrams-"&gt;Image Diagrams 图像简图&lt;/h4&gt;
&lt;p&gt;用粗糙简单的涂鸦来代替文字，包括观点和观点之间的联系，图像比文字更加生动，容易记住。&lt;br&gt;画一些小图像以代替某些重要的观点，它们在我的脑海中记得更清晰，没有必要花费很长的时间画一些复杂的图画，花个 10-20 秒简单地涂鸦是比较好的选择。&lt;/p&gt;
&lt;h3 id="handling-the-arbitrary"&gt;Handling the Arbitrary&lt;/h3&gt;
&lt;p&gt;前边说过Arbitrary(随意信息)结构最弱，  难以进行整体性学习。&lt;br&gt;这3种方法介于整体性学习法和死记硬背之间。&lt;/p&gt;
&lt;h3 id="linking-"&gt;Linking 联想法&lt;/h3&gt;
&lt;p&gt;联想法的目的是将一系列观点串在一起，就像链条。一旦你进入链条中的一环，就可以轻易地到达链条中的其他环节。 &lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列出清单序列&lt;/li&gt;
&lt;li&gt;给清单中的每一项设置一个符号 （设计的符号要能迅速让你联想到原始的知识，因为联想法记住的是视觉符号，而不是抽象信息本身。除非你确信能从视觉符号想到原始知识，否则不要使用联想法。 ）&lt;/li&gt;
&lt;li&gt;创建属于自己的联想。创造生动夸张的图像，能将序列中的两个符号联系在一起。 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;联想法的难点： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号重复——给同样的符号加上不同的颜色。 &lt;/li&gt;
&lt;li&gt;断裂的联系——建议联想链最好不要太长，建议5-15 个为好。超过这个数量，建议你把大联想链分成几个小的。 &lt;/li&gt;
&lt;li&gt;难以辨认的符号。符号最好清晰简明，容易记住。 &lt;/li&gt;
&lt;li&gt;触发物丢失。在某些例子中，你可能需要增加一个联想，一个列表中第一项和触发物之间的联想。 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="pegging-"&gt;Pegging 挂钩法&lt;/h3&gt;
&lt;p&gt;将要记忆的信息与数字联系在一起。&lt;br&gt;挂钩法首先要给基本数字创造形象，我喜欢给13（0-12）个数字设立13 个押韵的单词，用来储存13 个数字，这13 个位置可以用来记住数字、概念以及步骤等等。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;英文的押韵（原书）            中文版的押韵（最后面是我个人的第一反应，大家可以结合自己的情况，不需要与我一样）
0（zero）----hero            零-------铃-----《倩女幽魂》中燕赤霞手上的那个法铃
1(one)------gun              一-------衣------一件红色的大衣
2(two)----shoe               二--------耳------老子那双垂肩的耳朵
3(three)----tree             三--------伞------西湖舟上，许仙和白娘子打得那把伞
4(four)----door              四--------寺-----少林寺，还是金山寺
5(five)----hive              五--------舞-----《黄飞鸿》上面的舞龙灯、舞狮子
6(six)----sticks             六-------柳------柳毅传书
7(seven)-----heaven          七-------妻-----老婆
8(eghite)-----plate          八-------疤----踢球留下来的那道疤
9(nine)----wine              九-------酒----五星茅台
10(ten)---pent               十-------石----《石头记》
11(eleven)-ribbon(我知道，不是太押韵)
12(dozen)-----oven
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挂钩法与联想法类似，只不过挂钩法不是将信息与前后知识点相连，而是将信息与具体0-12 个数字联系一起。&lt;br&gt;用这种方式记忆，如果其中一个联系破坏了，其他的联系还是很容易想起来的，只需要花点力气回忆你的数字挂钩系统。&lt;/p&gt;
&lt;h3 id="information-compression"&gt;Information Compression&lt;/h3&gt;
&lt;h4 id="mnemonics-"&gt;Mnemonics 记忆术&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Using words to compress several ideas into a single idea.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用一个短语或单词来储存数个信息的方法。最好的记忆术应该选择尽量简单通用的短语或单词。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;八国联军：我 (俄) 屌 (德意奥) 硬 (英)，没 (美) 法日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="-picture-linking"&gt;图像记忆 Picture Linking&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Create a picture that links several ideas under a single theme.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是把几个信息联系起来并且用一张简图来表示。  在纸上画&lt;/p&gt;
&lt;h4 id="-notes-compression"&gt;笔记压缩 Notes Compression&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Rewrite a vast quantity of notes onto just a few pages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔记压缩是掌握大容量内容的好办法，让你看清结构从而更容易建立连接，可以作为其他信息压缩技术的起点，如linking，pegging，或其他整体性学习法&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拿几张白纸。&lt;/li&gt;
&lt;li&gt;用最小的字，写下笔记中的主要观点。使用尽可能少的字。&lt;/li&gt;
&lt;li&gt;在旁边写出相关的idea，公式，概念，或定义。&lt;strong&gt;用最小的字&lt;/strong&gt;，尽量少写来节省空间。&lt;/li&gt;
&lt;li&gt;持续用简化形式写出其他观点，直到所有观点都写完。最后你得到大约1-3 张密密麻麻写满信息的纸。 &lt;/li&gt;
&lt;li&gt;有时候，还可以更进一步，如果第一次写的不太容易看清关系，将上面压缩后的内容，加工、修饰得更有条理，更好看一些。 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="extending-ideas-"&gt;Extending Ideas 扩展观点&lt;/h3&gt;
&lt;h3 id="practical-usage-"&gt;Practical Usage 实际应用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Look for ways to apply the idea in your daily life.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过将知识应用于实际，知识才会记得更牢。多思考学的东西怎么才能应用到实际中来。&lt;/p&gt;
&lt;h3 id="model-debugging-"&gt;Model Debugging 模型纠错&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Practice questions in your subject regularly and look for potential errors in your holistic web.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模型纠错就是实践的意思。 实践是摆脱错误的唯一方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Separate Typos From Concept Errors&lt;br&gt;简单错误修正，大错误回到models, metaphors and visceralizations&lt;/li&gt;
&lt;li&gt;The Shotgun Approach&lt;/li&gt;
&lt;li&gt;Spread Practice Times Out 每日练习，而不是临时抱佛脚。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="project-based-learning-"&gt;Project-Based Learning 基于项目学习&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Set up projects of 1-3 months that will force you to learn new concepts. This is a useful exercise for self-education, where there is less structure to guide you.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于项目学习是最好的学习方法，设定1-3个月的项目，写个程序，网站，游戏，或写本书。。。&lt;/p&gt;
&lt;p&gt;一些tips&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;keep it Small 看起来遥遥无期的项目会动摇你的信心。&lt;/li&gt;
&lt;li&gt;Write it Down 在纸上写出项目过程，写文档能在你感到失意或无聊的时候，使你专注。&lt;/li&gt;
&lt;li&gt;Create an Objective Outcome 在project有明确目标的时候，可以推动你的积极性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-"&gt;高效率学生&lt;/h3&gt;
&lt;h3 id="manage-your-energy-"&gt;Manage Your Energy 能量管理&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Stay in shape, eat healthy and don&amp;#39;t work without sleep.&lt;br&gt;Schedule a day off each week.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加精力容量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每周3-5次运动，最好每天40分钟。&lt;/li&gt;
&lt;li&gt;每晚睡7-8小时。&lt;/li&gt;
&lt;li&gt;不要吃高糖高脂肪的，多吃谷物与未加工食品，这样可以让你一天的血糖水平保持平稳，避免忽高忽低。&lt;/li&gt;
&lt;li&gt;多喝水。&lt;/li&gt;
&lt;li&gt;不吃早餐危害大，每天4-5小餐最佳。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把计划表从线性格式改成Circular Scheduling&lt;/p&gt;
&lt;p&gt;线性的计划是平均安排时间执行工作， 而圆形计划安排则先集中小部分时间做大部分工作，这种计划安排能让你做到有张有弛，而不是死气沉沉，像个机器人。下面是一些建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每周休息1天&lt;/li&gt;
&lt;li&gt;所有工作挪到早上，晚上多睡觉，早早完成工作，晚上你就有几小时的空闲了。&lt;/li&gt;
&lt;li&gt;90分钟timeboxes，时间结束停止工作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="don-t-study-"&gt;Don&amp;#39;t “Study” 不要“学习”&lt;/h3&gt;
&lt;p&gt;不用“学习”这个笼统，容易产生歧义的词，我们只定义学习过程中需要做得那些活动。&lt;/p&gt;
&lt;p&gt;学习不是坐在书桌前越长越好，学习 需要挑选要吃的食物（获取信息） ，咀嚼（明白阶段） ，消化（理解阶段） 、吸收（应用阶段） ”。&lt;/p&gt;
&lt;p&gt;除非你把你为了学习需要做得具体活动列出来，否则你可能花费大量的时间用在所谓的“学习”表象上，而不是真正的学会了什么。 &lt;/p&gt;
&lt;h3 id="end-procrastination-"&gt;End Procrastination 停止拖延&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Set up a Weekly and Daily Goals list to keep focused.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="weekly-daily-goals-system"&gt;Weekly/Daily Goals System&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;每个周末创建一个weekly todo list，包含所有下周想做的事情，阅读，学习，活动。&lt;/li&gt;
&lt;li&gt;每天晚上，检查weekly todo list，创建一个daily goals list&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好处： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少决定做多做少的压力，照着表做就好了&lt;/li&gt;
&lt;li&gt;保证大项目不拖延&lt;/li&gt;
&lt;li&gt;平衡工作量&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="-batch"&gt;批量工作 Batch&lt;/h4&gt;
&lt;p&gt;类似的小任务放在一起一次做完，节省时间，因为可以集中时间和精力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适合小任务打包，超过3-5小时的任务不要打包&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一次性完成作业。 &lt;/p&gt;
&lt;p&gt;一次性完成作业。如果一项作业花费的时间不会超过 8 小时，我就坐在凳子上不挪窝，一鼓作气完成它。将一个花 3 小时就可以写完的文章，分成 15 次零散时间内完成，肯定会浪费很多时间，每一次都要花时间重新鼓起写作的激情才能开始正式的写作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提高注意力阈值。 &lt;/p&gt;
&lt;p&gt;注意力阈值就是指集中完成某项工作的最长时间，超过这个时间，注意力就急剧下降。通过不断接受越来越多的批量作业，你可以逐渐提高你的注意力阈值，阈值越高，表示能一次完成的工作量也越大。 
　　 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="-get-organized"&gt;有组织 Get Organized&lt;/h4&gt;
&lt;p&gt;有组织可以提高工作学习效率，假如你做事杂乱无序，下面是一些让你变得有组织的关键步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Everything has a home. &lt;/li&gt;
&lt;li&gt;Carry a notepad with you at all times. &lt;/li&gt;
&lt;li&gt;Maintain a calendar and a to-do list.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-"&gt;自我教育&lt;/h3&gt;
&lt;h4 id="-improve-your-habits"&gt;学习习惯 Improve your habits&lt;/h4&gt;
&lt;p&gt;习惯每日阅读，每日练习，设定目标，细分到每一天。&lt;/p&gt;
&lt;p&gt;怎样养成每日习惯: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;坚持某个习惯30 天。 &lt;/li&gt;
&lt;li&gt;坚持下去。每天坚持以同样的方式完成同样的习惯，今天阅读，明天听讲，后天练习的方式对于养成习惯来说太脱节了。 &lt;/li&gt;
&lt;li&gt;享受这个习惯。用头脑风暴法列举出各种各样的可以养成的习惯吧. &lt;/li&gt;
&lt;li&gt;寻找特殊时段。找到属于你的每天特殊时段有助于强化你的习惯。 &lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="-"&gt;克服挫折&lt;/h4&gt;
&lt;p&gt;有强烈兴趣的课程不会阻挡你前进&lt;/p&gt;
&lt;p&gt;减少挫折技巧&lt;br&gt;1）写下障碍，尽可能详尽，让我更好的思考问题&lt;br&gt;2）用论坛&lt;br&gt;3）get How-To Manuals&lt;br&gt;4）用另一角度思考&lt;/p&gt;
&lt;h4 id="-"&gt;设定学习目标&lt;/h4&gt;
&lt;p&gt;不过太多的结构也会限制人的自由，让人喘不过气来（我相信这是大多数人对传统教育的感觉） 。太少的结构则可能使学习令人生厌和目标性不强，这样的学习容易陷入自由散漫的状态之中。设定学习目标可以给你恰当的结构，你可以在这个结构之下拓展、探究新的知识，这样的自我教育就不是随意的，而是有组织、有系统、有计划和目的的学习了。&lt;/p&gt;
&lt;p&gt;tips&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有目标都要写下来，没写的目标都是不存在的，写出一些语句加上deadline才算数。&lt;/li&gt;
&lt;li&gt;让目标客观化。在学习的过程中，你要能很容易地就判断出是否已经达到了目标。&lt;/li&gt;
&lt;li&gt;让目标有一定难度，但可完成。&lt;/li&gt;
&lt;li&gt;把目标转化成daily和weekly的具体行动&lt;/li&gt;
&lt;li&gt;有规律的回顾你设置的目标，至少每周一次检查目标实现情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-"&gt;完整思维导图&lt;/h3&gt;
&lt;p&gt;&lt;img src="/image/learnMoreStudyLess/learnMoreStudyLess.png" alt=""&gt;&lt;/p&gt;
&lt;h4 id="-"&gt;下载：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/image/learnMoreStudyLess/learnMoreStudyLess.png"&gt;learnMoreStudyLess.png&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/image/learnMoreStudyLess/learnMoreStudyLess.xmind"&gt;learnMoreStudyLess.xmind&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Stage3D.js：用TypeScript与WebGL实现Stage3D API</title>
    <id>http://nshen.net/project/2015-02-04/stage3d-js</id>
    <link href="http://nshen.net/project/2015-02-04/stage3d-js"/>
    <updated>2015-02-04T17:12:00.000Z</updated>
    <content>&lt;p&gt;在入门WebGL的过程中经常与Stage3D的API对比，后干脆把Stage3D的API实现出来了，也包括了AS3的数学库。&lt;/p&gt;
&lt;h2 id="-"&gt;一些演示：&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/bunnyMark/BunnyMark.html"&gt;bunnymark&lt;/a&gt;&lt;br&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/shooter/index.html"&gt;a shooter game&lt;/a&gt;&lt;br&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/blend.html"&gt;blend test&lt;/a&gt;&lt;br&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/gouraudShading.html"&gt;gouraudShading&lt;/a&gt;&lt;br&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/loadObj.html"&gt;load Obj model&lt;/a&gt;&lt;br&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/textureTriangle.html"&gt;textureTriangle&lt;/a&gt;&lt;br&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/renderingModes.html"&gt;renderingModes&lt;/a&gt;&lt;br&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/drawSquare.html"&gt;drawSquare&lt;/a&gt;&lt;br&gt;&lt;a href="http://github.nshen.net/Stage3D.js/examples/drawTriangle.html"&gt;drawTriangle&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="-"&gt;项目地址：&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/nshen/Stage3D.js"&gt;https://github.com/nshen/Stage3D.js&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id="-"&gt;最简单的画三角形的代码如下 &lt;a href="http://github.nshen.net/Stage3D.js/examples/drawTriangle.html"&gt;(效果演示)&lt;/a&gt; :&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
var canvas: HTMLCanvasElement = &amp;lt;HTMLCanvasElement&amp;gt;document.getElementById(&amp;quot;my-canvas&amp;quot;);

stage3d = new stageJS.Stage3D(canvas);
stage3d.addEventListener(stageJS.events.Event.CONTEXT3D_CREATE, onCreated);
stage3d.requestContext3D();

function onCreated(e: stagl.events.Event): void
{
    context3d = stage3d.context3D;
    context3d.configureBackBuffer(stage3d.stageWidth, stage3d.stageHeight, 2, true);

    var program: stagl.Program3D = context3d.createProgram();
    program.upload(&amp;quot;shader-vs&amp;quot;, &amp;quot;shader-fs&amp;quot;); // shaders are in html file
    context3d.setProgram(program);


    var vertexBuffer: stagl.VertexBuffer3D = context3d.createVertexBuffer(3, 7);
    vertexBuffer.uploadFromVector([
        -1, -1, 0, 1, 0, 0, 1,   //xyz rgba
        1, -1, 0, 0, 1, 0, 1,
        0, 1, 0, 0, 0, 1, 1]
        , 0, 3);

    context3d.setVertexBufferAt(&amp;quot;va0&amp;quot;, vertexBuffer, 0, stagl.Context3DVertexBufferFormat.FLOAT_3); // pos
    context3d.setVertexBufferAt(&amp;quot;va1&amp;quot;, vertexBuffer, 3, stagl.Context3DVertexBufferFormat.FLOAT_4); // color

    var indexBuffer: stagl.IndexBuffer3D = context3d.createIndexBuffer(3);
    indexBuffer.uploadFromVector([0, 1, 2], 0, 3);

    context3d.clear(0.0, 0.0, 0.0, 1.0);
    context3d.drawTriangles(indexBuffer);
    context3d.present();

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我直接拿第二个例子&lt;a href="http://github.nshen.net/Stage3D.js/examples/shooter/index.html"&gt;(a shooter game)&lt;/a&gt; 参加了coding.net的HTML5大赛，得了个优秀作品奖：）&lt;/p&gt;
&lt;h2 id="-"&gt;战利品：&lt;/h2&gt;
&lt;p&gt;定制 Filco 机械键盘一个&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/coding.jpg" alt=""&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>使用grunt-ts编译typescript项目</title>
    <id>http://nshen.net/article/2014-12-05/grunt-ts</id>
    <link href="http://nshen.net/article/2014-12-05/grunt-ts"/>
    <updated>2014-12-05T12:55:20.000Z</updated>
    <content>&lt;p&gt;不是这世界变化快，是我一直没关注。这几年js发展这么快是我怎么也想不到的，今天研究的是js界高大上的Grunt构建工具，因为发现很多老外的开源项目都在用这个。研究一下，还挺方便的。&lt;/p&gt;
&lt;p&gt;首先看一下我的目录结构&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-markup"&gt;    ProjectA
        |-----build //编译后的all.js等文件放在这里
        |-----core  //typescript项目,里边若干.ts文件
        |-----test  //用编译后的all.js做测试,里边有若干js和html文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的需求是这样的，core文件夹里有多个.ts文件，需要按照我指定的顺序编译成一个all.js文件，为什么要指定顺序，是因为js是从上到下执行，没执行到的就是不存在的。如果顺序不对的话运行时会报各种找不到类的错误。除了这个还有以下需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译的&lt;code&gt;all.js&lt;/code&gt;放到&lt;code&gt;build/&lt;/code&gt;目录&lt;/li&gt;
&lt;li&gt;需要生成&lt;code&gt;build/all.js.map&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要生成&lt;code&gt;build/all.d.ts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要生成&lt;code&gt;build/all.min.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基于ES5，Commonjs编译&lt;/li&gt;
&lt;li&gt;编译后的文件删除注释&lt;/li&gt;
&lt;li&gt;编译后将build目录下的所有文件复制到test文件夹里做测试&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;p&gt;估计已经涵盖大部分typescript开源项目的需求了，我不知道其他人是怎么做这些的，我自己之前一直使用WebStorm来写TypeScript，WebStorm里有一个叫做File Watcher的功能，可以把它配置成每次发现文件改动自动调用编译器tsc来编译TypeScript，它有一个Arguments的文本框，可以添加tsc的编译参数。&lt;/p&gt;
&lt;p&gt;我都是这么填的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;--sourcemap E:\ProjectA\core\reference.ts -d --out E:\ProjectA\test\all.js --target ES5 --removeComments
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我在reference.ts里指定了ts文件的顺序，所以只编译这一个文件，就达到了按指定文件顺序全部编译的目的。&lt;br&gt;我写了绝对路径，这样就可以在任何目录里编译了。&lt;br&gt;因为不能复制文件，就只能把core项目直接编译到test文件夹里做测试了。&lt;/p&gt;
&lt;p&gt;测试完后，我还要手动手动把all.js复制回build文件夹，想办法生成min.js等一堆麻烦事。。。直到发现了&lt;a href="http://gruntjs.com/"&gt;Grunt&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id="-grount-"&gt;用Grount实现需求&lt;/h1&gt;
&lt;h2 id="-cli"&gt;安装&lt;code&gt;cli&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;来到项目路径&lt;/h2&gt;
&lt;p&gt;npm init 命令来创建一个 &lt;code&gt;package.json&lt;/code&gt; 文件，回答问题会自动创建&lt;code&gt;package.json&lt;/code&gt;，其实一路回车就行了，都有默认答案&lt;br&gt;好多属性，不知道有什么用的，删掉！看官网教程好像只需要一个name ，一个 version就行，其他删掉了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;gruntTest&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;just a test&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-grunt-"&gt;装第一个依赖项目，必然是&lt;code&gt;grunt&lt;/code&gt;本身&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install grunt --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成，目录里多了一个&lt;code&gt;node_modules&lt;/code&gt;目录，这是nodejs模块安装到的目录。&lt;/p&gt;
&lt;h3 id="-gitignore"&gt;修改gitignore&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt;文件里加入这两个目录，不然被传到github上就不好了&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-markup"&gt;/node_modules
.tscache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在&lt;code&gt;package.json&lt;/code&gt;变成这样了&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;gruntTest&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;just a test&amp;quot;,
    &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;grunt&amp;quot;: &amp;quot;^0.4.5&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为安装grunt时时加了&lt;code&gt;--save-dev&lt;/code&gt;参数，所以会被自动加进依赖里&lt;/p&gt;
&lt;h3 id="-typescript-grunt-ts"&gt;安装今天的主角，TypeScript的编译器插件grunt-ts&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install grunt-ts --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再看&lt;code&gt;package.json&lt;/code&gt;如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;gruntTest&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;just a test&amp;quot;,
    &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;grunt&amp;quot;: &amp;quot;^0.4.5&amp;quot;,
    &amp;quot;grunt-ts&amp;quot;: &amp;quot;^1.12.1&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-all-min-js-"&gt;安装生成all.min.js的插件&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install grunt-contrib-uglify --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-copy-"&gt;安装copy插件&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install grunt-contrib-copy --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在看一眼&lt;code&gt;package.json&lt;/code&gt;应该变成这样了&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;gruntTest&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;just a test&amp;quot;,
    &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;grunt&amp;quot;: &amp;quot;^0.4.5&amp;quot;,
    &amp;quot;grunt-contrib-copy&amp;quot;: &amp;quot;^0.7.0&amp;quot;,
    &amp;quot;grunt-contrib-uglify&amp;quot;: &amp;quot;^0.6.0&amp;quot;,
    &amp;quot;grunt-ts&amp;quot;: &amp;quot;^1.12.1&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ok ，全部安装完毕，现在可以看&lt;a href="https://www.npmjs.org/package/grunt-ts"&gt;grunt-ts官网&lt;/a&gt;介绍各种参数怎么用吧&lt;/p&gt;
&lt;p&gt;添加一个Gruntfile，基于&lt;a href="https://github.com/TypeStrong/grunt-ts/blob/master/sample/Gruntfile.js"&gt;官网的例子&lt;/a&gt;直接修改的&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;module.exports = function (grunt) {
    &amp;quot;use strict&amp;quot;;

    grunt.initConfig({
        ts:  //用来编译typescript的任务
        {
            options: 
            {
                comments: false,               // 删除注释
                target: &amp;#39;es5&amp;#39;,                 // es5,默认为es3
                module: &amp;#39;commonjs&amp;#39;,            // 居然默认是amd?
                declaration: true,             // 生成.d.ts
            },

            build: 
            {
                src: [&amp;quot;core/reference.ts&amp;quot;],  
                // reference: &amp;#39;core/reference.ts&amp;#39;,  //第一次生成reference.ts,之后手动修改顺序,之后注释掉
                out: &amp;#39;./build/all.js&amp;#39;, 
            }
        },

        uglify: //uglify插件用来代码压缩,生成min.js
        {
            min:
            {
                files: {&amp;#39;build/all.min.js&amp;#39;: [&amp;#39;build/all.js&amp;#39;]}
            }
        },

        //copy插件把build目录下的所有文件复制到test文件夹
        copy:
        {
            builds: {expand: true, cwd: &amp;#39;build/&amp;#39;, src: &amp;#39;*&amp;#39;, dest: &amp;#39;test/&amp;#39;}
        }

    });

    //加载之前命令行安装的3个插件
    grunt.loadNpmTasks(&amp;quot;grunt-ts&amp;quot;);     
    grunt.loadNpmTasks(&amp;quot;grunt-contrib-copy&amp;quot;);
    grunt.loadNpmTasks(&amp;quot;grunt-contrib-uglify&amp;quot;);

    //任务顺序: 编译typescript -&amp;gt; 生成min.js -&amp;gt; 复制build目录里的文件到ProjectA_Test
    grunt.registerTask(&amp;quot;default&amp;quot;, [&amp;quot;ts:build&amp;quot; , &amp;quot;uglify:min&amp;quot; , &amp;quot;copy:builds&amp;quot;]);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以编译了，打开命令行，输入grunt ，应该是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;E:\ProjectA&amp;gt; grunt

    Running &amp;quot;ts:build&amp;quot; (ts) task
    Compiling...
    Cleared fast compile cache for target: build
    Fast compile will not work when --out is specified. Ignoring fast compilation
    Using tsc v1.0.1

    TypeScript compilation complete: 4.51s for 1 typescript files

    Running &amp;quot;uglify:min&amp;quot; (uglify) task
    &amp;gt;&amp;gt; 1 file created.

    Running &amp;quot;copy:builds&amp;quot; (copy) task
    Copied 4 files

    Done, without errors.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Done了，没有错误！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>AS2TS：ActionScript3在线转为TypeScript</title>
    <id>http://nshen.net/project/2014-11-21/as2ts</id>
    <link href="http://nshen.net/project/2014-11-21/as2ts"/>
    <updated>2014-11-21T10:35:00.000Z</updated>
    <content>&lt;p&gt;做Flash很少用正则表达式，所以一直都不会写。。这几天恶补了一下，由于之前研究过&lt;a href="http://www.nshen.net/article/2013-05-18/as3-to-typescript/"&gt;ActionScript与TypeScript的区别&lt;/a&gt;，作为练习写了个ActionScript转TypeScript的小程序，純html5的。&lt;/p&gt;
&lt;h2 id="-"&gt;试用: &lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.nshen.net/as2ts/"&gt;https://github.nshen.net/as2ts/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="-fork-"&gt;源码(请fork我吧): &lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/nshen/as2ts"&gt;https://github.com/nshen/as2ts&lt;/a&gt; &lt;/p&gt;
&lt;h2 id="-"&gt;转换列表：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Boolean&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uint&lt;/code&gt; / &lt;code&gt;int&lt;/code&gt; / &lt;code&gt;Number&lt;/code&gt; to &lt;code&gt;number&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:*&lt;/code&gt; to &lt;code&gt;:any&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package&lt;/code&gt; to &lt;code&gt;module&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;comment out &lt;code&gt;import&lt;/code&gt; statements ?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public class&lt;/code&gt; to &lt;code&gt;export class&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public function class_name(...):void&lt;/code&gt; to &lt;code&gt;constructor(...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;internal&lt;/code&gt; to &lt;code&gt;public&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static (public|private|protected)&lt;/code&gt; to  &lt;code&gt;(public|private|protected) static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(private|public|protected) var&lt;/code&gt; to &lt;code&gt;(private|public|protected)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(private|public|protected) const&lt;/code&gt; to &lt;code&gt;(private|public|protected)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(override) (private|public|protected) function&lt;/code&gt; to &lt;code&gt;(private|public|protected)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(private|public|protected) static var&lt;/code&gt; to &lt;code&gt;(private|public|protected) static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(private|public|protected) static const&lt;/code&gt; to &lt;code&gt;(private|public|protected) static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(private|public|protected) static function&lt;/code&gt; to &lt;code&gt;(private|public|protected) static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;local &lt;code&gt;const&lt;/code&gt; to &lt;code&gt;var&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A as B&lt;/code&gt; to &lt;code&gt;&amp;lt;B&amp;gt; A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:Array&lt;/code&gt; to &lt;code&gt;:any[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:Vector.&amp;lt;type&amp;gt; =&lt;/code&gt; to &lt;code&gt;type[] =&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:Vector.&amp;lt;type&amp;gt;;&lt;/code&gt; to &lt;code&gt;type[];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;: Vector.&amp;lt;type&amp;gt; {&lt;/code&gt; to &lt;code&gt;type[] {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new Vector.&amp;lt;type&amp;gt;(7,true)&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new &amp;lt;type&amp;gt;[1,2,3]&lt;/code&gt; to &lt;code&gt;[1,2,3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector.&amp;lt;type&amp;gt;([1, 2, 3])&lt;/code&gt; to &lt;code&gt;[1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trace&lt;/code&gt; to &lt;code&gt;console.log&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id="-"&gt;常见问题：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;问：AS3程序能转为TS程序了？&lt;/li&gt;
&lt;li&gt;答：不能，这只是常见&lt;strong&gt;语法&lt;/strong&gt;的转换，具体运行环境不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-"&gt;版本历史：&lt;/h2&gt;
&lt;p&gt;as2ts v0.1 : 2014-11-21 最初版本,实现基本功能&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Stage3D各种投影矩阵的推导</title>
    <id>http://nshen.net/article/2014-10-16/stage3d-projection-matrix</id>
    <link href="http://nshen.net/article/2014-10-16/stage3d-projection-matrix"/>
    <updated>2014-10-16T13:55:10.000Z</updated>
    <content>&lt;p&gt;本文将对Stage3D提供的10个投影矩阵逐个推导一遍，能力有限，如有错误请猛喷。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="-"&gt;前期准备&lt;/h2&gt;
&lt;p&gt;我的推导原理是基于下边几个教程的，这些是我搜遍全网找到的最好的教程，只不过大都是OpenGL的，而我这里要基于他们的原理推导一遍Stage3D和WebGL的（下一篇再写WebGL的）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/popy007/article/details/1797121"&gt;深入探索透视投影变换&lt;/a&gt;&lt;br&gt;&lt;a href="http://blog.csdn.net/popy007/article/details/4091967"&gt;深入探索透视投影变换(续)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最详细的矩阵投影3部曲：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://scratchapixel.com/lessons/3d-advanced-lessons/perspective-and-orthographic-projection-matrix/perspective-projection-matrix/"&gt;1. Perspective Projection Matrix&lt;/a&gt;&lt;br&gt;&lt;a href="http://scratchapixel.com/lessons/3d-advanced-lessons/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix/"&gt;2. OpenGL Perspective Projection Matrix&lt;/a&gt;&lt;br&gt;&lt;a href="http://scratchapixel.com/lessons/3d-advanced-lessons/perspective-and-orthographic-projection-matrix/orthographic-projection/"&gt;3. Orthographic Projection&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenGL 投影矩阵详细推导过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.songho.ca/opengl/gl_projectionmatrix.html"&gt;OpenGL Projection Matrix&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我只写推导过程，不会详细解释原理，因为原理实在太难说清楚了，不过上边这些教程解释的非常清楚，你可能需要先看一遍再来看我的推导。如果不看，至少要知道这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左右手坐标系&lt;/li&gt;
&lt;li&gt;透视投影和正交投影是什么&lt;/li&gt;
&lt;li&gt;相似三角形&lt;/li&gt;
&lt;li&gt;矩阵乘法&lt;/li&gt;
&lt;li&gt;线性插值&lt;/li&gt;
&lt;li&gt;其次坐标转普通坐标&lt;/li&gt;
&lt;li&gt;NDC（Normalized Device Coordinates） &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-stage3d-"&gt;观察Stage3D投影矩阵&lt;/h2&gt;
&lt;p&gt;先观察一下Stage3D的&lt;a href="https://github.com/adobe-flash/graphicscorelib/blob/master/src/com/adobe/utils/PerspectiveMatrix3D.as"&gt;PerspectiveMatrix3D&lt;/a&gt;类提供的投影矩阵。&lt;/p&gt;
&lt;p&gt;左手：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. perspectiveOffCenterLH(left:Number, right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number)
2. perspectiveLH(width:Number, height:Number, zNear:Number, zFar:Number)
3. perspectiveFieldOfViewLH(fieldOfViewY:Number, aspectRatio:Number, zNear:Number, zFar:Number)
4. orthoOffCenterLH(left:Number, right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number)
5. orthoLH(width:Number,height:Number,zNear:Number,zFar:Number)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;右手：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6. perspectiveOffCenterRH(left:Number, right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number)
7. perspectiveRH(width:Number, height:Number, zNear:Number, zFar:Number)
8. perspectiveFieldOfViewRH(fieldOfViewY:Number, aspectRatio:Number, zNear:Number, zFar:Number)
9. orthoOffCenterRH(left:Number, right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number)
10. orthoRH(width:Number,height:Number,zNear:Number,zFar:Number)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仔细观察后，根据参数不同一共提供了3种透视投影和2种正交投影生成方式，分为左右手两个版本，共10款，总有一款适合你。&lt;/p&gt;
&lt;p&gt;提供左右手两个版本说明在眼空间可以任意使用左右手坐标系，只要在最后投影时选择合适的投影矩阵即可。&lt;/p&gt;
&lt;h2 id="-"&gt;开始推导&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;免责声明：不会打公式，全手写，字丑勿怪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先推导左手坐标系的5个矩阵，函数名和参数太长，眼花了，我来用首字母把参数简写一下。&lt;br&gt;例如： &lt;code&gt;right -&amp;gt; r&lt;/code&gt;  , &lt;code&gt;width -&amp;gt; w&lt;/code&gt; ，&lt;code&gt;zNear -&amp;gt; n&lt;/code&gt; , &lt;code&gt;zFar -&amp;gt; f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/1.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;发现参数都有near和far，区别只在于前几个参数。&lt;br&gt;其实只要推出参数最多的2个典型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
1. perspectiveOffCenterLH(left:Number,right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number)    
4. orthoOffCenterLH(left:Number, right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他的都只是他们的变种而已。&lt;br&gt;从1号典型开始，看最终能否得到&lt;a href="https://github.com/adobe-flash/graphicscorelib/blob/master/src/com/adobe/utils/PerspectiveMatrix3D.as"&gt;官方提供的&lt;/a&gt;矩阵：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;public function perspectiveOffCenterLH(left:Number, right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number):void 
{
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0*zNear/(right-left), 0.0, 0.0, 0.0,
        0.0, -2.0*zNear/(bottom-top), 0.0, 0.0,
        -1.0-2.0*left/(right-left), 1.0+2.0*top/(bottom-top), -zFar/(zNear-zFar), 1.0,
        0.0, 0.0, (zNear*zFar)/(zNear-zFar), 0.0
    ]));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-1-perspectiveoffcenterlh"&gt;推导 1. perspectiveOffCenterLH&lt;/h3&gt;
&lt;p&gt;点p投影到p&amp;#39;，N为近平面 ，左手坐标系，所以近平面在正z轴方向，画图&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/2.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;根据大小两个相似三角形，得到&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/3.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;求出x&amp;#39;为&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/4.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;同理 y&amp;#39;为&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/5.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;当点P投影到近平面，z&amp;#39;自然永远等于近平面&lt;strong&gt;N&lt;/strong&gt;，所以先不要算他了，后边再说。x&amp;#39; y&amp;#39;已经是投影后的坐标了，但显卡需要的是NDC坐标，所以我们要根据线性插值把x&amp;#39; y&amp;#39;插值到NDC范围内， 结果记为xn yn。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：Stage3D的NDC范围在(-1,-1,0)到(1,1,1)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;已知 left, right,bottom,top ，简写为 l, r, b, t  ，投影后的点为x&amp;#39;,根据线性插值公式求出缩放后的Xn.&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/6.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;同理yn等于&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/7.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;把上边的求得的投影点x&amp;#39;,y&amp;#39;带入xn,yn，整理。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/8.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;为啥整理成这种形式呢？因为这是一个巧妙的安排，毕竟我们最终要用&lt;strong&gt;一个矩阵乘法&lt;/strong&gt; + &lt;strong&gt;一个其次坐标转普通坐标&lt;/strong&gt; 来完成整个转换，把z放到分母可以方便后边做其次坐标转普通坐标，后边会看到两个分子也可以方便的带入矩阵。&lt;/p&gt;
&lt;p&gt;同理yn等于&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/9.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;好啦，现在改成矩阵形式，投影前的点&lt;strong&gt;[x,y,z,1]&lt;/strong&gt;乘以一个矩阵&lt;strong&gt;M&lt;/strong&gt;  得到的其次坐标，再除以w转成普通坐标后，应该得到的结果为&lt;strong&gt;[xn，yn，zn,1]&lt;/strong&gt;求这个矩阵。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：Stage3D使用行向量右乘列矩阵&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上边我们求得的结果，已经可以猜出矩阵部分元素了&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/10.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;就差z坐标了，z坐标投影后永远等于近平面n，保存他没有意义了，我们要用z来保存转换之前的深度，并线性插值到NDC范围内提供给设备，&lt;strong&gt;注意Stage3D中zn的NDC范围在0~1之间&lt;/strong&gt;，但按照之前xy线性插值的方法，我推不出来 , 需要换种想法了，之前提到的教程里也都是这种方法。&lt;/p&gt;
&lt;p&gt;看上边的图，&lt;strong&gt;[x,y,z,1]&lt;/strong&gt;点乘&lt;strong&gt;[?,?,?,?]&lt;/strong&gt; 应该等于转换后的其次坐标z ， 由于z与x,y无关，所以把这两个位置都写成0，借助后两个元素A，B来解决线性插值。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/11.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;[x,y,z,1] 点乘[?,?,?,?] 就变成了  [x,y,z,1]点乘[0,0,A,B]&lt;/p&gt;
&lt;p&gt;zn其次坐标就等于 x &lt;em&gt; 0 + y &lt;/em&gt; 0 + A &lt;em&gt; z + 1 &lt;/em&gt; B&lt;/p&gt;
&lt;p&gt;其次转普通坐标&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/12.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;zn的NDC范围在 0~1之间，说明在zNear时为0，zFar时为1，so&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/13.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;解方程组求A，B&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/14.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;带入矩阵，最终结果&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/15.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;对比一下官方的结果，&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function perspectiveOffCenterLH(left:Number, right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number):void 
{
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0*zNear/(right-left), 0.0, 0.0, 0.0,
        0.0, -2.0*zNear/(bottom-top), 0.0, 0.0,
        -1.0-2.0*left/(right-left), 1.0+2.0*top/(bottom-top), -zFar/(zNear-zFar), 1.0,
        0.0, 0.0, (zNear*zFar)/(zNear-zFar), 0.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好像除了第3行第1列和第2列不一样，其他都一样的。&lt;/p&gt;
&lt;p&gt;仔细看看官方给的第3行，第1列&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-1.0-2.0*left/(right-left)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/16.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;原来跟我们的一样，而且我们的版本更简洁一些：）&lt;/p&gt;
&lt;p&gt;第3行第2列也一样，就不写了。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-2-perspectivelh"&gt;推导 2. perspectiveLH&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
perspectiveLH(width:Number, height:Number, zNear:Number, zFar:Number)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个是以视口的中心做投影，所以&lt;/p&gt;
&lt;p&gt;left = - right&lt;br&gt;top = - bottom&lt;/p&gt;
&lt;p&gt;也就是说 &lt;/p&gt;
&lt;p&gt;r + l = 0&lt;br&gt;r - l = width&lt;/p&gt;
&lt;p&gt;t + b = 0&lt;br&gt;t - b = height&lt;/p&gt;
&lt;p&gt;直接带入上一个推导的矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/15.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;把上边的矩阵简化，得到&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/17.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;正好是官方的这个，一模一样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function perspectiveLH(width:Number, height:Number, zNear:Number, zFar:Number):void 
{
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0*zNear/width, 0.0, 0.0, 0.0,
        0.0, 2.0*zNear/height, 0.0, 0.0,
        0.0, 0.0, zFar/(zFar-zNear), 1.0,
        0.0, 0.0, zNear*zFar/(zNear-zFar), 0.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-3-perspectivefieldofviewlh"&gt;推导 3. perspectiveFieldOfViewLH&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
perspectiveFieldOfViewLH(fieldOfViewY:Number,aspectRatio:Number,zNear:Number,zFar:Number) 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有了两个新参数&lt;strong&gt;fov&lt;/strong&gt;和&lt;strong&gt;aspect&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/18.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;经过研究，这里的 fov 如图所示，是指YZ平面，top和bottom之间的夹角。&lt;/p&gt;
&lt;p&gt;看看能不能把这两个参数转成width和height表示，这样就可以直接带入上一个推出的矩阵得到新矩阵了&lt;/p&gt;
&lt;p&gt;fov，aspect 与 w ，h是什么关系？&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/19.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;这样就可以把h和w求出来了&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/20.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;带入上一个矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/17.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;得到&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/21.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;仔细看一下正好与官方提供的一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function perspectiveFieldOfViewLH(fieldOfViewY:Number,aspectRatio:Number,zNear:Number,zFar:Number):void {
    var yScale:Number = 1.0/Math.tan(fieldOfViewY/2.0);
    var xScale:Number = yScale / aspectRatio;
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        xScale, 0.0, 0.0, 0.0,
        0.0, yScale, 0.0, 0.0,
        0.0, 0.0, zFar/(zFar-zNear), 1.0,
        0.0, 0.0, (zNear*zFar)/(zNear-zFar), 0.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-4-orthooffcenterlh"&gt;推导 4. orthoOffCenterLH&lt;/h3&gt;
&lt;p&gt;很难想象这么重要的一个类，官方给的orthoOffCenterLH矩阵居然是错的，而且adobe已经停止支持这个库了，&lt;a href="http://github.com/thibaultimbert/graphicscorelib/issues/5"&gt;有人提交了错误，也已经没人回应了&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;正确的应该是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function orthoOffCenterLH(left:Number,right:Number, bottom:Number, top:Number, zNear:Number, zFar:Number):void {
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0/(right-left), 0.0, 0.0, 0.0,
        0.0, 2.0/(top-bottom), 0.0, 0.0,
        0.0, 0.0, 1.0/(zFar-zNear), 0.0,
        (left+right)/(left-right), (bottom+top)/(bottom-top), zNear/(zNear-zFar), 1.0
]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推导比透视投影简单，因为是正交投影则，所以 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = x&amp;#39;
y = y&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只需要各个方向缩放到NDC范围内就好了，跟之前一样，线性插值&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/22.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;放到矩阵里&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/23.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;Az+B 在近裁剪面为0，远裁剪面为1，so&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A n + B = 0 
A f + B = 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解得：&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/24.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;放入矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/25.jpg" alt=""&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function orthoOffCenterLH(left:Number,right:Number, bottom:Number, top:Number, zNear:Number, zFar:Number):void {
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0/(right-left), 0.0, 0.0, 0.0,
        0.0, 2.0/(top-bottom), 0.0, 0.0,
        0.0, 0.0, 1.0/(zFar-zNear), 0.0,
        (left+right)/(left-right), (bottom+top)/(bottom-top), zNear/(zNear-zFar), 1.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-5-ortholh"&gt;推导 5. orthoLH&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
orthoLH(width:Number,height:Number,zNear:Number,zFar:Number)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于是以视口为中心的正交投影矩阵，所以：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;left = - right
top = - bottom
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说&lt;/p&gt;
&lt;p&gt;r + l = 0&lt;br&gt;r - l = width&lt;/p&gt;
&lt;p&gt;t + b = 0&lt;br&gt;t - b = height&lt;/p&gt;
&lt;p&gt;带入刚才求得的这个矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/25.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2/w, 0, 0, 0,
0, 2/h, 0, 0,
0, 0, 1/f-n, 0,
0, 0, n/n-f, 1 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对比官方的版本，是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function orthoLH(width:Number,height:Number,zNear:Number,zFar:Number):void {
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0/width, 0.0, 0.0, 0.0,
        0.0, 2.0/height, 0.0, 0.0,
        0.0, 0.0, 1.0/(zFar-zNear), 0.0,
        0.0, 0.0, zNear/(zNear-zFar), 1.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此左手5个已经推导完毕，右手的类似，要加快速度了。&lt;/p&gt;
&lt;h3 id="-6-perspectiveoffcenterrh"&gt;推导 6. perspectiveOffCenterRH&lt;/h3&gt;
&lt;p&gt;从参数最多的开始&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
perspectiveOffCenterRH(left:Number, right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点p投影到p&amp;#39; ，N为近平面 ，右手坐标系，所以近平面在负z轴方向，这次换个方向画图吧&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/26.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;先求投影点x&amp;#39; y&amp;#39;,然后插值到NDC范围-1~1之间， 结果记为xn yn。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/27.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;分母都是-z 说明在做透视除法时w为-z ，所以猜到矩阵为&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/28.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;处理z&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/29.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;AB带入矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/30.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;对比官方提供的，稍微整理一下正负号就一模一样了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function perspectiveOffCenterRH(left:Number,right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number):void {
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0*zNear/(right-left), 0.0, 0.0, 0.0,
        0.0, -2.0*zNear/(bottom-top), 0.0, 0.0,
        1.0+2.0*left/(right-left), -1.0-2.0*top/(bottom-top), zFar/(zNear-zFar), -1.0,
        0.0, 0.0, (zNear*zFar)/(zNear-zFar), 0.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这个，后边两个变种就容易了&lt;/p&gt;
&lt;h3 id="-7-perspectiverh"&gt;推导 7. perspectiveRH&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
perspectiveRH(width:Number,height:Number,zNear:Number,zFar:Number)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以视口的中心做投影，所以&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;left = - right
top = - bottom
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r + l = 0
r - l = width
t + b = 0
t - b = height
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接带入上一个推导的矩阵，得到的结果跟官方一模一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function perspectiveRH(width:Number,height:Number,zNear:Number,zFar:Number):void {
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0*zNear/width, 0.0, 0.0, 0.0,
        0.0, 2.0*zNear/height, 0.0, 0.0,
        0.0, 0.0, zFar/(zNear-zFar), -1.0,
        0.0, 0.0, zNear*zFar/(zNear-zFar), 0.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-8-perspectivefieldofviewrh"&gt;推导 8. perspectiveFieldOfViewRH&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
perspectiveFieldOfViewRH(fieldOfViewY:Number,aspectRatio:Number,zNear:Number,zFar:Number)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟左手差不多，z轴相反，就不画图了&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/31.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;带入上个矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/32.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;对比，一模一样：）&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function perspectiveFieldOfViewRH(fieldOfViewY:Number,aspectRatio:Number,zNear:Number,zFar:Number):void {
    var yScale:Number = 1.0/Math.tan(fieldOfViewY/2.0);
    var xScale:Number = yScale / aspectRatio;
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        xScale, 0.0, 0.0, 0.0,
        0.0, yScale, 0.0, 0.0,
        0.0, 0.0, zFar/(zNear-zFar), -1.0,
        0.0, 0.0, (zNear*zFar)/(zNear-zFar), 0.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-9-orthooffcenterrh"&gt;推导 9. orthoOffCenterRH&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
orthoOffCenterRH(left:Number,right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个官方提供的矩阵也错了，正确的应该这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function orthoOffCenterRH(left:Number,right:Number,bottom:Number,top:Number,zNear:Number, zFar:Number):void {
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0/(right-left), 0.0, 0.0, 0.0,
        0.0, 2.0/(top-bottom), 0.0, 0.0,
        0.0, 0.0, 1.0/(zNear-zFar), 0.0,
        (left+right)/(left-right), (bottom+top)/(bottom-top), zNear/(zNear-zFar), 1.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为正交投影，则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = x&amp;#39;
y = y&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接线性插值到 -1 ~ 1之间&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/33.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;推出矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/34.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;求变换后的Zn&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/stage3d-projection-matrix/35.jpg" alt=""&gt;&lt;/p&gt;
&lt;h3 id="-10-orthorh"&gt;推导 10. orthoRH&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
orthoRH(width:Number,height:Number,zNear:Number,zFar:Number)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一个视口中心投影 ，这个官方提供的矩阵也有一个笔误 @_@，第3行第3列:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.0/(zNear-zNear)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应该为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.0/(zNear-zFar)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开始推导：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r = - l
b = -t
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;so&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r - l = w
r + l = 0
t - b = h
t + b = 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;带入上边矩阵，很明显得到&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
public function orthoRH(width:Number,height:Number,zNear:Number,zFar:Number):void {
    this.copyRawDataFrom(Vector.&amp;lt;Number&amp;gt;([
        2.0/width, 0.0, 0.0, 0.0,
        0.0, 2.0/height, 0.0, 0.0,
        0.0, 0.0, 1.0/(zNear-zFar), 0.0,
        0.0, 0.0, zNear/(zNear-zFar), 1.0
    ]));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全文完。 &lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>读书《Stage3D Game Programming Beginner》</title>
    <id>http://nshen.net/article/2013-07-28/stage3d-game-programming-beginner</id>
    <link href="http://nshen.net/article/2013-07-28/stage3d-game-programming-beginner"/>
    <updated>2013-07-28T02:30:31.000Z</updated>
    <content>&lt;p&gt;这篇笔记一年半前读书时发到豆瓣上了，去豆瓣搜过书的应该都看见过，这是我入门3d看的第一本书，现在把原文复制过来简单排版和整理了一下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id="-let-s-make-a-game-using-molehill"&gt;第一章，Let&amp;#39;s Make a Game Using Molehill&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;介绍什么是molehil。。略 。此书面针对了解AS3，但不太了解3d的读者。&lt;/p&gt;
&lt;h3 id="3d-"&gt;3d术语：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mesh：3d游戏中的模型就叫一个mesh。模型一般用3d studiomax 等软件做的，一个场景可以有几百个mesh组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Polygon：mesh可以由成百上千的多边形组成，多边形可以是三角形，也可以是四边形，一个3d立方体由6个面片组成，每个面片叫做一个poly。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vertex：每个poly有3个或以上角，每个角的顶点就是一个vertex。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Texture：想象成墙纸，可以是一个jpg或png的图片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Shaders：shader是视觉风格的定义，它定义怎样渲染某物，在stage3d中，shaders存在Program3D类中。创建一个shader，需要创建一个vertex program，和一个fragment program 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fragment program：在molehill中是处理mesh视觉渲染的一系列命令。也叫像素着色器。fragment programs描述一个给定的表面材质和对光照的反应，不同的材质对光照有不同的反应方式取决于反射和透明度等，需要不同的代码来模拟。每个模型都需要一个fragment program，否则就不会渲染出来，它可以是一个简单的texture，也可以是复杂的2个texture混合外加灯光反射。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vertex program：molehill常用 vertex program计算mesh的形状，影响每个vertex在3d世界中的位置。这样可以把mesh缩放，扭曲，做变形动画。也可以分配任意数量的数据到mesh中的每个vertex，不只是xyz坐标，可以是rgb颜色uv等。每个模型的渲染都需要个vertex program，可以是简单的在原始位置渲染或复杂到让mesh做变形动画。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vectors：Vector3D描述空间中的位置，在geom包里&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import flash.geom.Vector3D;
var putTheTreeHere:Vector3D = new Vector3D(0,0,0);
var locationOfTreasure:Vector3D = new Vector3D(1000,0,-15000);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Normals：仅用来指明方向，length等于1的单位向量，可以简单的用Vector3D类的normalize()方法获得。&lt;/p&gt;
&lt;p&gt;  var aNormalPointingUp:Vector3D = new Vector3D(0,1,0);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Matrices：是向量的集合，Matrix3D是4×4的矩阵，用来方便的移动，旋转，缩放对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一章结束，总结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vector3D: containing an x, y, and z component&lt;/li&gt;
&lt;li&gt;Normal: a Vector3D that has a length of one&lt;/li&gt;
&lt;li&gt;Matrix: a 4x4 group of vectors with position, rotation,and scale&lt;/li&gt;
&lt;li&gt;Vertex: a point in space that is the corner of a polygon&lt;/li&gt;
&lt;li&gt;Polygon: a shape defined by multiple vertex coordinates&lt;/li&gt;
&lt;li&gt;Mesh: a group of polygons (polies) that make up a model&lt;/li&gt;
&lt;li&gt;Texture: a bitmap image that is like a wallpaper for a mesh&lt;/li&gt;
&lt;li&gt;Vertex program: commands affecting the shape of a mesh&lt;/li&gt;
&lt;li&gt;Fragment program: commands affecting the look of a mesh&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-2-blueprint-of-a-molehill"&gt;第2章，Blueprint of a Molehill&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;原来为什么慢，因为之前DisplayList全部CPU，molehill为什么快，因为molehill是完全GPU加速的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Molehill will rely on DirectX 9 on Windows machines and OpenGL 1.3 on both Mac OS-X and Linux. On mobile devices such as tablets, televisions, and phones, Molehill will rely upon OpenGL ES2.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DisplayList在stage3d之上，可以组合stage3d和原始的flash显示列表一起做东东.&lt;/p&gt;
&lt;h3 id="molehill-"&gt;Molehill程序结构&lt;/h3&gt;
&lt;p&gt;stage3d已不在显示列表里，不能addchild了.&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/molehill_book01.jpg" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Context3D：可以想象成&amp;quot;引擎&amp;quot;，所有3d数据都要传给他。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;This Context3D is the object that you send all your textures, vertex buffers, and&lt;br&gt;vertex/fragment programs to. The Context3D is the base class that holds all of your game&lt;br&gt;data and does all the work.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;VertexBuffer3D：VertexBuffer3D是一个numbers的数组，用来保存第一章提到的vertex坐标，但不限于顶点坐标，还可以保存rgb，uv等值。初始化游戏的时候要把这个vertexBuffer3D传给Contex3D，之后Contex3D会把这些数据直接传给显卡的RAM或VRAM，渲染时会用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IndexBuffer3D：由于顶点数据是一大坨VertexBuffer3D，Molehill需要知道每组数据的起始和结束，所以有了index buffer做索引，如下图，表示3个顶点，每个有6个元素 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="/image/molehill_book02.jpg" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Program3D：Vertex programs和 fragment programs也叫shaders 与前边的buffer同样传给contex3d，他是从一种类似汇编语言编译成的，他们告诉gpu怎样根据上边提供的buffer画mesh。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-stage3d-"&gt;一个stage3d程序的流程图&lt;/h3&gt;
&lt;p&gt;分2部分，setup 和 render loop&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setup&lt;/strong&gt;：&lt;br&gt;所有buffers和programs被编译并发送到显卡。这只做1次。一旦setup，molehill可以在不同位置重复画meshes而不需要其他初始化。&lt;/p&gt;
&lt;p&gt;setup详细过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Request a Context3D instance from Stage3D&lt;/li&gt;
&lt;li&gt;Set up the Context3D (telling it how big it is, and so on)&lt;/li&gt;
&lt;li&gt;Create a VertexBuffer (one for each mesh you intend to use)&lt;/li&gt;
&lt;li&gt;Create an IndexBuffer (each will correspond to a VertexBuffer)&lt;/li&gt;
&lt;li&gt;Upload this data to the Context3D (send it to your GPU)&lt;/li&gt;
&lt;li&gt;&amp;quot;Compile&amp;quot; a VertexProgram (turn your shader source code into bytes)&lt;/li&gt;
&lt;li&gt;&amp;quot;Compile&amp;quot; a FragmentProgram (turn your shader source code into bytes)&lt;/li&gt;
&lt;li&gt;Create a Program3D which will use the preceding shaders (can be used by more than one mesh)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这8步一般只需要一次，偶尔由于3d环境丢失的关系需要重新来一次，例如因为计算机睡眠等原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;render loop&lt;/strong&gt;：一般是监听ENTER_FRAME事件重复执行的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clear the Context3D (erase the old view)&lt;/li&gt;
&lt;li&gt;Tell the Context3D which Program3D to use (for example, a shader that looks&lt;br&gt;like steel)&lt;/li&gt;
&lt;li&gt;Tell the Context3D which VertexBuffer to use (for example, a spaceship)&lt;/li&gt;
&lt;li&gt;Setup data for you your shaders (variables, such as the new location of a spaceship)&lt;/li&gt;
&lt;li&gt;Draw some triangles (tell the Context3D to do some drawing)&lt;/li&gt;
&lt;li&gt;Update the screen with your drawn triangles (show the user the new scene)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结：这章讲了什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The old fashioned way: 2D Flash using DisplayObjects&lt;/li&gt;
&lt;li&gt;The Molehill way: Stage3Ds containing Context3Ds&lt;/li&gt;
&lt;li&gt;Why Molehill is so fast: Hardware 3D, baby&lt;/li&gt;
&lt;li&gt;Combining 2D and 3D: You can use old and new Flash objects together&lt;/li&gt;
&lt;li&gt;Flowchart of a Molehill game: Setup first, then a render loop&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-3-fire-up-the-engines"&gt;第3章，Fire up the Engines&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;这章是前边两章内容的一个实例，直接看代码就行了，书里好像也么讲什么新内容，代码倒是注释的很详细&lt;br&gt;除了shader代码要后边章节详细讲，其他的配合帮助文档应该都看懂了。&lt;/p&gt;
&lt;p&gt;详见 &lt;a href="/image/Ch3_Stage3dGame.as" target="_blank"&gt;Stage3dGame.as&lt;/a&gt;类&lt;/p&gt;
&lt;p&gt;本章总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;we learned how to obtain Flash 11 for our browser, we got all the tools ready&lt;br&gt;to compile Stage3D games, we learned how to initialize the Stage3D API, how to upload&lt;br&gt;mesh and texture data to the video card, and how to animate a simple 3D scene&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="-4-basic-shaders"&gt;第4章，Basic Shaders&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;AGAL: Adobe Graphics Assembly Language&lt;/p&gt;
&lt;p&gt;前边讲过shaders就是vertex program （vertex shaders）和 fragment program（pixel shaders）。&lt;br&gt;由于他们在gpu中执行，所以很快，每帧可以数百万次，flash的一帧中，mesh中每个顶点都要执行一次vertex program！ fragment shade更厉害，每个像素都执行一次！。&lt;/p&gt;
&lt;p&gt;agal语句是什么样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;opcode&amp;gt; &amp;lt;destination&amp;gt; &amp;lt;source 1&amp;gt; &amp;lt;source 2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;agal只有30个opcodes，完整列表在Stage3D的文档里找.&lt;br&gt;例如  mov v0, va1  把va1的值copy到v0.&lt;/p&gt;
&lt;p&gt;常见agal opcode:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mov (copies data from source1 to destination)
add (destination = source1 plus source2)
sub (destination = source1 minus source2)
mul (destination = source1 multiplied by source2)
div (destination = source1 divided by source2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;什么是寄存器 （register）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上边提到的&amp;quot;source&amp;quot; 和 &amp;quot;destinations&amp;quot;叫寄存器，你可以把它们当成变量，存储数据的地方。他们代表显存中的一小块，为速度而优化过的。寄存器都是包含4个128位的浮点数 ，用as3的话说就是4个Number。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寄存器的组成部分&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;4个值中的每一个都是一个组成部分，可以通过xyzw或者rgba访问&lt;br&gt;va1.x和va1.r一样都是寄存器的第一个组成部分。&lt;br&gt;一般在vertex里用xyzw，fragment里用rgba。&lt;br&gt;opcode一般四个组件同时运算，例如以add opcode为例 source1是一个 Vector3D  (10,100,50,0) 然后source2 是 (5,1,3,0),结果会是(15,101,53,0).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同的寄存器有不同的功用&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/molehill_book03.jpg" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;顶点属性寄存器 Vertex Attribute Registers：va0...va7&lt;br&gt;有8个va寄存器，分别是va0, va1, va2, va3, va4, va5, va6 , va7&lt;br&gt;只在vertex shader里可用，用来指定VertexBuffer中的位置。可以包含x,y,z,或uv坐标，rgb值等。&lt;br&gt;用 Context3D:setVertexBufferAt() 来把VertexBuffer分段分配给属性寄存器。然后在shader里用语法 va&lt;n&gt;访问，n就是属性索引。&lt;br&gt;记住一共有8个寄存器，每个保存4个浮点数，所以每个顶点可以保存32个数字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常量寄存器 Constant registers: vc0..vc127 and fc0..fc27&lt;br&gt;as中通过Context3D::setProgramConstants()系列函数来设置&lt;br&gt;在vertex shader中用vc&lt;n&gt;访问，pixel shader中fc&lt;n&gt;访问&lt;br&gt;vertex shaders里一共有128个常量寄存器，pixel shaders里有28个常量寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;临时寄存器 Temporary registers: vt0..vt7 and ft0..ft7&lt;br&gt;这些寄存器是用来在shader里临时计算用的，可以当成临时变量。 这样访问：&lt;br&gt;vt&lt;n&gt; (vertex programs) ， ft&lt;n&gt; (fragment programs)&lt;br&gt;vertex 和pixel shaders各8个临时寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输出寄存器 Output registers: op在vertex shader里用来输出位置，oc在pixel shader里用来输出颜色。 vertex shader的输出就是顶点的clip space 位置，pixel shader输出的就是就是像素颜色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Varying registers: v0..v7  呃这个不知道中文名了&lt;br&gt;这些寄存器是用来从vertex shaders向pixel shaders传递数据的。，典型应用是从vertex shader传递顶点颜色或纹理的uv坐标到pixel shader。一共有8个，用v&lt;n&gt;访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;纹理采样寄存器Texture samplers: fs0..fs7&lt;br&gt;这8个纹理采样寄存器，只可以用在fragment program里，是用来基于uv坐标从textures里提取颜色的。这个寄存器比较特殊，有它独有的规则&lt;br&gt;，采样的纹理，需要提前在as中用Context3D::setTextureAt()指定.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;shader里语法是这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fs&amp;lt;n&amp;gt; &amp;lt;flags&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;flags是逗号分隔的字符串，类似这样 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tex ft1, v0, fs0 &amp;lt;2d,linear,nomip&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于参数的解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;texture dimension: 2d, 3d, or cube. A 2D texture is the most commonly used format, a rectangular bitmap. A 3D texture has length, width, and depth, and takes up a lot of texture RAM but is great for 3D materials such as wood, grain, or marble. It is rarely used. A cube texture is a specially encoded group of six rectangular bitmaps and is usually used for reflections, as each of these six images maps to a particular direction like the sides on the inside of a box.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mip mapping: nomip, mipnone, mipnearest, or miplinear. If your texture has mip maps (successively smaller versions of itself, generated to avoid jaggies during rendering), then you can instruct Stage3D to smoothly interpolate the texture using them. Mip mapped textures are very useful to increase render quality and avoid the &amp;quot;moiree effect&amp;quot; (flickering) when viewed from far away.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;texture filtering: nearest or linear. If you prefer a retro, then pixilated look you can use nearest here to tell Stage3D not to interpolate the values smoothly, resulting in blocky textures when viewed up close, for example. If you use linear, when zoomed into a texture it will be blurry and will have smoother edges.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;texture repeat: repeat, wrap, or clamp. If you want the texture tile properly, then you use repeathere. If you are not tiling the texture and run into problems with edge pixels being the color of the opposite edge (which often happens in transparent billboard particles and when rendering bitmap fonts in 3d), then specify clampto force Stage3D not to blur adjacent edge pixels.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-"&gt;下面开始实例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// the simplest possible vertex program
m44 op, va0, vc0 // pos to clipspace
mov v0, va1 // copy uv
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;m44是4×4矩阵相乘，顶点坐标存储在 va0 ，乘以mesh相对于camera的位置矩阵vc0&lt;br&gt;第二行copy va1到v0.&lt;br&gt;关于vc0后边章节会讲，现在知道他MVP矩阵，这个这本书里没有仔细讲，要看点其他数学书了：（&lt;/p&gt;
&lt;p&gt;最简单的fragment program&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// a simple fragment program
tex ft1, v0, fs0 &amp;lt;2d,linear,nomip&amp;gt;
mov oc, ft1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从fs0取样到ft1，v0是来自顶点shader的uv坐标&lt;br&gt;把 ft1输出.&lt;/p&gt;
&lt;p&gt;编译 AGAL 代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var vertexShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
vertexShaderAssembler.assemble(
Context3DProgramType.VERTEX,
&amp;quot;m44 op, va0, vc0\n&amp;quot; +
&amp;quot;mov v0, va1&amp;quot;
);
var fragmentShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
fragmentShaderAssembler.assemble(
Context3DProgramType.FRAGMENT,
&amp;quot;tex ft1, v0, fs0 &amp;lt;2d,linear, nomip&amp;gt;;\n&amp;quot; +
&amp;quot;mov oc, ft1&amp;quot;
);
var program:Program3D = context3D.createProgram();
program.upload(
vertexShaderAssembler.agalcode,
fragmentShaderAssembler.agalcode
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;渲染！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clear the Context3D, erasing the previous frame&lt;/li&gt;
&lt;li&gt;Select which vertex buffers to use&lt;/li&gt;
&lt;li&gt;Select which texture to use&lt;/li&gt;
&lt;li&gt;Set the current shader program&lt;/li&gt;
&lt;li&gt;Apply a matrix for use in your shaders to calculate the location&lt;/li&gt;
&lt;li&gt;Render the mesh&lt;/li&gt;
&lt;li&gt;Repeat steps 2 through 6 for every mesh&lt;/li&gt;
&lt;li&gt;Present the final image to the user&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际代码来了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clear your viewport to the background color:
context3D.clear ( 1, 1, 1, 1 );
// vertex position to attribute register 0 (va0)
context3D.setVertexBufferAt (0, vertexbuffer, 0,
Context3DVertexBufferFormat.FLOAT_3);
// uv coordinates to attribute register 1 (va1)
context3D.setVertexBufferAt(1, vertexbuffer, 3,
Context3DVertexBufferFormat.FLOAT_2);
// assign texture to texture sampler 0 (fs0)
context3D.setTextureAt( 0, texture );
// assign shader program
context3D.setProgram( program );
// Note how the two vertex buffer streams,
// vertex positions and uv coordinates,
// get assigned to two different attribute registers.
// The texture is assigned to a specific texture sampler.
// Pass on your transform matrix to the shader.
var m:Matrix3D = new Matrix3D();
m.appendRotation(getTimer()/50, Vector3D.Z_AXIS);
context3D.setProgramConstantsFromMatrix(
Context3DProgramType.VERTEX, 0, m, true);
// The matrix gets stored into constant register 0 here,
// for the Vertex Shader to use.
// To render, call drawTriangles passing in the index buffer.
context3D.drawTriangles(indexBuffer);
// You may do additional drawTriangle calls in the frame
// one for each mesh you want rendered.
// You can use the same or different programs for each meshes.
// Once all meshes have been drawn, display them on screen:
context3D.present();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后边全在分块的讲代码，有点晕，都不知道讲到哪了，其实直接看完整的代码就可以了，注释非常全。要费点精力了，我先略了。&lt;/p&gt;
&lt;p&gt;详见 &lt;a href="/image/ch4_Stage3dGame.as" target="_blank"&gt;Stage3dGame.as&lt;/a&gt;类&lt;/p&gt;
&lt;h3 id="-5-making-stuff-happen-"&gt;第5章，Making Stuff Happen!&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;面片真是太面了，这章要显示真正的模型了。&lt;/p&gt;
&lt;p&gt;.OBJ是模型文件，主流3d软件都应该可以导出这种格式。&lt;br&gt;还有贴图可以photoshop做，具体怎么做的看不懂，等看完了这本书小弟就准备学习学习3d软件了。&lt;br&gt;.obj文件格式类似这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v -0.257 0.191 0.423
vt 0.623 0.227
f 1/1 2/2 3/3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一行是顶点坐标，第2行是uv坐标，第3行是面的定义，用来产生index buffer，复杂的obj文件会有成百上千行。&lt;br&gt;理论就在这些。&lt;/p&gt;
&lt;p&gt;下边开始主要讲解析obj文件&lt;a href="/image/Stage3dObjParser.as" target="_blank"&gt;Stage3dObjParser.as&lt;/a&gt;类&lt;/p&gt;
&lt;p&gt;第一步readClass把embed进来的obj文件转成字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private function readClass(f:Class):String
{
    var bytes:ByteArray = new f();
    return bytes.readUTFBytes(bytes.bytesAvailable);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后每行解析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Split data in to lines and parse all lines.
var lines:Array = definition.split(LINE_FEED);
var loop:uint = lines.length;
for(var i:uint = 0; i &amp;lt; loop; ++i)
    parseLine(lines[i]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后根据firstWord分别解析不同数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private function parseLine(line:String):void
{
        // Split line into words.
        var words:Array = line.split(SPACE);

        // Prepare the data of the line.
        if (words.length &amp;gt; 0)
            var data:Array = words.slice(1);
        else
            return;

        // Check first word and delegate remainder to proper parser.
        var firstWord:String = words[0];
        switch (firstWord)
        {
            case VERTEX:
                parseVertex(data);
                break;
            case NORMAL:
                parseNormal(data);
                break;
            case UV:
                parseUV(data);
                break;
            case INDEX_DATA:
                parseIndex(data);
                break;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;难点在解析index，这里就略了。&lt;/p&gt;
&lt;p&gt;如果软件可以不导出normal，则可以大大减小文件体积，可以用下边函数计算出normal&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public function restoreNormals():void
{    // utility function
    _rawNormalsBuffer = _cachedRawNormalsBuffer.concat();
}

public function get3PointNormal(
    p0:Vector3D, p1:Vector3D, p2:Vector3D):Vector3D
{    // utility function
    // calculate the normal from three vectors
    var p0p1:Vector3D = p1.subtract(p0);
    var p0p2:Vector3D = p2.subtract(p0);
    var normal:Vector3D = p0p1.crossProduct(p0p2);
    normal.normalize();
    return normal;
}

public function forceNormals():void
{    // utility function
    // useful for when the OBJ file doesn&amp;#39;t have normal data
    // we can calculate it manually by calling this function
    _cachedRawNormalsBuffer = _rawNormalsBuffer.concat();
    var i:uint, index:uint;
    // Translate vertices to vector3d array.
    var loop:uint = _rawPositionsBuffer.length/3;
    var vertices:Vector.&amp;lt;Vector3D&amp;gt; = new Vector.&amp;lt;Vector3D&amp;gt;();
    var vertex:Vector3D;
    for(i = 0; i &amp;lt; loop; ++i)
    {
        index = 3*i;
        vertex = new Vector3D(_rawPositionsBuffer[index],
            _rawPositionsBuffer[index + 1], 
            _rawPositionsBuffer[index + 2]);
        vertices.push(vertex);
    }
    // Calculate normals.
    loop = vertices.length;
    var p0:Vector3D, p1:Vector3D, p2:Vector3D, normal:Vector3D;
    _rawNormalsBuffer = new Vector.&amp;lt;Number&amp;gt;();
    for(i = 0; i &amp;lt; loop; i += 3)
    {
        p0 = vertices[i];
        p1 = vertices[i + 1];
        p2 = vertices[i + 2];
        normal = get3PointNormal(p0, p1, p2);
        _rawNormalsBuffer.push(normal.x, normal.y, normal.z);
        _rawNormalsBuffer.push(normal.x, normal.y, normal.z);
        _rawNormalsBuffer.push(normal.x, normal.y, normal.z);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此.OBJ解析部分完成了。&lt;/p&gt;
&lt;p&gt;上传Mipmaps代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public function uploadTextureWithMipmaps(dest:Texture, src:BitmapData):void
{
     var ws:int = src.width;
     var hs:int = src.height;
     var level:int = 0;
     var tmp:BitmapData;
     var transform:Matrix = new Matrix();
     var tmp2:BitmapData;
     tmp = new BitmapData( src.width, src.height, true, 0x00000000);
     while ( ws &amp;gt;= 1 &amp;amp;&amp;amp; hs &amp;gt;= 1 )
     {                                
          tmp.draw(src, transform, null, null, null, true);    
          dest.uploadFromBitmapData(tmp, level);
          transform.scale(0.5, 0.5);
          level++;
          ws &amp;gt;&amp;gt;= 1;
          hs &amp;gt;&amp;gt;= 1;
          if (hs &amp;amp;&amp;amp; ws) 
          {
               tmp.dispose();
               tmp = new BitmapData(ws, hs, true, 0x00000000);
          }
     }
     tmp.dispose();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;巨型实例，结束本章&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package
{
import com.adobe.utils.*;
import flash.display.*;
import flash.display3D.*;
import flash.display3D.textures.*;
import flash.events.*;
import flash.geom.*;
import flash.utils.*;
import flash.text.*;
[SWF(width=&amp;quot;640&amp;quot;, height=&amp;quot;480&amp;quot;, frameRate=&amp;quot;60&amp;quot;, backgroundColor=&amp;quot;#FFFFFF&amp;quot;)]    
public class Stage3dGame extends Sprite
{
// used by the GUI
private var fpsLast:uint = getTimer();
private var fpsTicks:uint = 0;
private var fpsTf:TextField;
private var scoreTf:TextField;
private var score:uint = 0;
// constants used during inits
private const swfWidth:int = 640;
private const swfHeight:int = 480;
// for this demo, ensure ALL textures are 512x512
private const textureSize:int = 512;
// the 3d graphics window on the stage
private var context3D:Context3D;
// the compiled shaders used to render our mesh
private var shaderProgram1:Program3D;
private var shaderProgram2:Program3D;
private var shaderProgram3:Program3D;
private var shaderProgram4:Program3D;
// matrices that affect the mesh location and camera angles
private var projectionmatrix:PerspectiveMatrix3D = new PerspectiveMatrix3D();
private var modelmatrix:Matrix3D = new Matrix3D();
private var viewmatrix:Matrix3D = new Matrix3D();
private var terrainviewmatrix:Matrix3D = new Matrix3D();
private var modelViewProjection:Matrix3D = new Matrix3D();
// a simple frame counter used for animation
private var t:Number = 0;
// a reusable loop counter
private var looptemp:int = 0;
/* TEXTURES: Pure AS3 and Flex version:
 * if you are using Adobe Flash CS5 
 * comment out the following: */
[Embed (source = &amp;quot;art/spaceship_texture.jpg&amp;quot;)] 
private var myTextureBitmap:Class;
private var myTextureData:Bitmap = new myTextureBitmap();
[Embed (source = &amp;quot;art/terrain_texture.jpg&amp;quot;)] 
private var terrainTextureBitmap:Class;
private var terrainTextureData:Bitmap = new terrainTextureBitmap();
/* TEXTURE: Flash CS5 version:
 * add the jpgs to your library (F11)
 * right click and edit the advanced properties
 * so it is exported for use in Actionscript 
 * and call them myTextureBitmap and terrainTextureBitmap
 * if you are using Flex/FlashBuilder/FlashDevelop/FDT
 * comment out the following: */
//private var myBitmapDataObject:myTextureBitmapData = 
//    new myTextureBitmapData(textureSize, textureSize);
//private var myTextureData:Bitmap = 
//    new Bitmap(myBitmapDataObject);
//private var terrainBitmapDataObject:terrainTextureBitmapData = 
//    new terrainTextureBitmapData(textureSize, textureSize);
//private var terrainTextureData:Bitmap = 
//    new Bitmap(terrainBitmapDataObject);
// The Stage3d Texture that uses the above myTextureData
private var myTexture:Texture;
private var terrainTexture:Texture;
// The spaceship mesh data
[Embed (source = &amp;quot;art/spaceship.obj&amp;quot;, mimeType = &amp;quot;application/octet-stream&amp;quot;)] 
private var myObjData:Class;
private var myMesh:Stage3dObjParser;
// The terrain mesh data
[Embed (source = &amp;quot;art/terrain.obj&amp;quot;, mimeType = &amp;quot;application/octet-stream&amp;quot;)] 
private var terrainObjData:Class;
private var terrainMesh:Stage3dObjParser;
public function Stage3dGame() 
{
    if (stage != null) 
        init();
    else 
        addEventListener(Event.ADDED_TO_STAGE, init);
}
private function init(e:Event = null):void 
{
    if (hasEventListener(Event.ADDED_TO_STAGE))
        removeEventListener(Event.ADDED_TO_STAGE, init);
    stage.scaleMode = StageScaleMode.NO_SCALE;
    stage.align = StageAlign.TOP_LEFT;
    // add some text labels
    initGUI();
    // and request a context3D from Stage3d
    stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, onContext3DCreate);
    stage.stage3Ds[0].requestContext3D();
}
private function updateScore():void
{
    // for now, you earn points over time
    score++;
    // padded with zeroes
    if (score &amp;lt; 10) scoreTf.text = &amp;#39;Score: 00000&amp;#39; + score;
    else if (score &amp;lt; 100) scoreTf.text = &amp;#39;Score: 0000&amp;#39; + score;
    else if (score &amp;lt; 1000) scoreTf.text = &amp;#39;Score: 000&amp;#39; + score;
    else if (score &amp;lt; 10000) scoreTf.text = &amp;#39;Score: 00&amp;#39; + score;
    else if (score &amp;lt; 100000) scoreTf.text = &amp;#39;Score: 0&amp;#39; + score;
    else scoreTf.text = &amp;#39;Score: &amp;#39; + score;
}
private function initGUI():void
{
    // a text format descriptor used by all gui labels
    var myFormat:TextFormat = new TextFormat();  
    myFormat.color = 0xFFFFFF;
    myFormat.size = 13;
    // create an FPSCounter that displays the framerate on screen
    fpsTf = new TextField();
    fpsTf.x = 0;
    fpsTf.y = 0;
    fpsTf.selectable = false;
    fpsTf.autoSize = TextFieldAutoSize.LEFT;
    fpsTf.defaultTextFormat = myFormat;
    fpsTf.text = &amp;quot;Initializing Stage3d...&amp;quot;;
    addChild(fpsTf);
    // create a score display
    scoreTf = new TextField();
    scoreTf.x = 560;
    scoreTf.y = 0;
    scoreTf.selectable = false;
    scoreTf.autoSize = TextFieldAutoSize.LEFT;
    scoreTf.defaultTextFormat = myFormat;
    scoreTf.text = &amp;quot;000000&amp;quot;;
    addChild(scoreTf);
    // add some labels to describe each shader
    var label1:TextField = new TextField();
    label1.x = 100;
    label1.y = 180;
    label1.selectable = false;  
    label1.autoSize = TextFieldAutoSize.LEFT;  
    label1.defaultTextFormat = myFormat;
    label1.text = &amp;quot;Shader 1: Textured&amp;quot;;
    addChild(label1);
    var label2:TextField = new TextField();
    label2.x = 400;
    label2.y = 180;
    label2.selectable = false;  
    label2.autoSize = TextFieldAutoSize.LEFT;  
    label2.defaultTextFormat = myFormat;
    label2.text = &amp;quot;Shader 2: Vertex RGB&amp;quot;;
    addChild(label2);
    var label3:TextField = new TextField();
    label3.x = 80;
    label3.y = 440;
    label3.selectable = false;  
    label3.autoSize = TextFieldAutoSize.LEFT;  
    label3.defaultTextFormat = myFormat;
    label3.text = &amp;quot;Shader 3: Vertex RGB + Textured&amp;quot;;
    addChild(label3);
    var label4:TextField = new TextField();
    label4.x = 340;
    label4.y = 440;
    label4.selectable = false;  
    label4.autoSize = TextFieldAutoSize.LEFT;  
    label4.defaultTextFormat = myFormat;
    label4.text = &amp;quot;Shader 4: Textured + setProgramConstants&amp;quot;;
    addChild(label4);
}
public function uploadTextureWithMipmaps(dest:Texture, src:BitmapData):void
{
     var ws:int = src.width;
     var hs:int = src.height;
     var level:int = 0;
     var tmp:BitmapData;
     var transform:Matrix = new Matrix();
     var tmp2:BitmapData;
     tmp = new BitmapData( src.width, src.height, true, 0x00000000);
     while ( ws &amp;gt;= 1 &amp;amp;&amp;amp; hs &amp;gt;= 1 )
     {                                
          tmp.draw(src, transform, null, null, null, true);    
          dest.uploadFromBitmapData(tmp, level);
          transform.scale(0.5, 0.5);
          level++;
          ws &amp;gt;&amp;gt;= 1;
          hs &amp;gt;&amp;gt;= 1;
          if (hs &amp;amp;&amp;amp; ws) 
          {
               tmp.dispose();
               tmp = new BitmapData(ws, hs, true, 0x00000000);
          }
     }
     tmp.dispose();
}
private function onContext3DCreate(event:Event):void 
{
    // Remove existing frame handler. Note that a context
    // loss can occur at any time which will force you
    // to recreate all objects we create here.
    // A context loss occurs for instance if you hit
    // CTRL-ALT-DELETE on Windows.            
    // It takes a while before a new context is available
    // hence removing the enterFrame handler is important!
    if (hasEventListener(Event.ENTER_FRAME))
        removeEventListener(Event.ENTER_FRAME,enterFrame);
    // Obtain the current context
    var t:Stage3D = event.target as Stage3D;                    
    context3D = t.context3D;     
    if (context3D == null) 
    {
        // Currently no 3d context is available (error!)
        return;
    }
    // Disabling error checking will drastically improve performance.
    // If set to true, Flash sends helpful error messages regarding
    // AGAL compilation errors, uninitialized program constants, etc.
    context3D.enableErrorChecking = true;
    // Initialize our mesh data
    initData();
    // The 3d back buffer size is in pixels (2=antialiased)
    context3D.configureBackBuffer(swfWidth, swfHeight, 2, true);
    // assemble all the shaders we need
    initShaders();
    myTexture = context3D.createTexture(textureSize, textureSize, Context3DTextureFormat.BGRA, false);
    uploadTextureWithMipmaps(myTexture, myTextureData.bitmapData);
    terrainTexture = context3D.createTexture(textureSize, textureSize, Context3DTextureFormat.BGRA, false);
    uploadTextureWithMipmaps(terrainTexture, terrainTextureData.bitmapData);
    // create projection matrix for our 3D scene
    projectionmatrix.identity();
    // 45 degrees FOV, 640/480 aspect ratio, 0.1=near, 100=far
    projectionmatrix.perspectiveFieldOfViewRH(45.0, swfWidth / swfHeight, 0.01, 5000.0);
    // create a matrix that defines the camera location
    viewmatrix.identity();
    // move the camera back a little so we can see the mesh
    viewmatrix.appendTranslation(0,0,-3);
    // tilt the terrain a little so it is coming towards us
    terrainviewmatrix.identity();
    terrainviewmatrix.appendRotation(-60,Vector3D.X_AXIS);
    // start the render loop!
    addEventListener(Event.ENTER_FRAME,enterFrame);
}
// create four different shaders
private function initShaders():void
{
    // A simple vertex shader which does a 3D transformation
    // for simplicity, it is used by all four shaders
    var vertexShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
    vertexShaderAssembler.assemble
    ( 
        Context3DProgramType.VERTEX,
        // 4x4 matrix multiply to get camera angle    
        &amp;quot;m44 op, va0, vc0\n&amp;quot; +
        // tell fragment shader about XYZ
        &amp;quot;mov v0, va0\n&amp;quot; +
        // tell fragment shader about UV
        &amp;quot;mov v1, va1\n&amp;quot; +
        // tell fragment shader about RGBA
        &amp;quot;mov v2, va2\n&amp;quot;
    );            
    // textured using UV coordinates
    var fragmentShaderAssembler1:AGALMiniAssembler = new AGALMiniAssembler();
    fragmentShaderAssembler1.assemble
    ( 
        Context3DProgramType.FRAGMENT,    
        // grab the texture color from texture 0 
        // and uv coordinates from varying register 1
        // and store the interpolated value in ft0
        &amp;quot;tex ft0, v1, fs0 &amp;lt;2d,linear,repeat,miplinear&amp;gt;\n&amp;quot;+
        // move this value to the output color
        &amp;quot;mov oc, ft0\n&amp;quot;
    );
    // no texture, RGBA from the vertex buffer data
    var fragmentShaderAssembler2:AGALMiniAssembler = new AGALMiniAssembler();
    fragmentShaderAssembler2.assemble
    ( 
        Context3DProgramType.FRAGMENT,    
        // grab the color from the v2 register
        // which was set in the vertex program
        &amp;quot;sub ft0, v2, fc1\n&amp;quot; + ///这句应该删掉？
        &amp;quot;mov oc, v2\n&amp;quot;
    );
    // textured using UV coordinates AND colored by vertex RGB
    var fragmentShaderAssembler3:AGALMiniAssembler = new AGALMiniAssembler();
    fragmentShaderAssembler3.assemble
    ( 
        Context3DProgramType.FRAGMENT,    
        // grab the texture color from texture 0 
        // and uv coordinates from varying register 1
        &amp;quot;tex ft0, v1, fs0 &amp;lt;2d,linear,repeat,miplinear&amp;gt;\n&amp;quot; +    
        // multiply by the value stored in v2 (the vertex rgb)
        &amp;quot;mul ft1, v2, ft0\n&amp;quot; +
        // move this value to the output color
        &amp;quot;mov oc, ft1\n&amp;quot;
    );
    // textured using UV coordinates and 
    // tinted using a fragment constant
    var fragmentShaderAssembler4:AGALMiniAssembler = new AGALMiniAssembler();
    fragmentShaderAssembler4.assemble
    ( 
        Context3DProgramType.FRAGMENT,    
        // grab the texture color from texture 0 
        // and uv coordinates from varying register 1
        &amp;quot;tex ft0, v1, fs0 &amp;lt;2d,linear,repeat,miplinear&amp;gt;\n&amp;quot; +    
        // multiply by the value stored in fc0
        &amp;quot;mul ft1, fc0, ft0\n&amp;quot; +
        // move this value to the output color
        &amp;quot;mov oc, ft1\n&amp;quot;
    );
    // combine shaders into a program which we then upload to the GPU
    shaderProgram1 = context3D.createProgram();
    shaderProgram1.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler1.agalcode);
    shaderProgram2 = context3D.createProgram();
    shaderProgram2.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler2.agalcode);
    shaderProgram3 = context3D.createProgram();
    shaderProgram3.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler3.agalcode);
    shaderProgram4 = context3D.createProgram();
    shaderProgram4.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler4.agalcode);
}
private function initData():void 
{
    // parse the OBJ file and create buffers
    myMesh = new Stage3dObjParser(myObjData, context3D, 1, true, true);
    // parse the terrain mesh as well
    terrainMesh = new Stage3dObjParser(terrainObjData, context3D, 1, true, true);
}        
private function renderTerrain():void
{
    context3D.setTextureAt(0, terrainTexture);
    // simple textured shader
    context3D.setProgram ( shaderProgram1 );
    // position
    context3D.setVertexBufferAt(0, terrainMesh.positionsBuffer, 
        0, Context3DVertexBufferFormat.FLOAT_3);
    // tex coord
    context3D.setVertexBufferAt(1, terrainMesh.uvBuffer, 
        0, Context3DVertexBufferFormat.FLOAT_2);
    // vertex rgba
    context3D.setVertexBufferAt(2, terrainMesh.colorsBuffer, 
        0, Context3DVertexBufferFormat.FLOAT_4);
    // set up camera angle
    modelmatrix.identity();
    // make the terrain face the right way
    modelmatrix.appendRotation( -90, Vector3D.Y_AXIS);
    // slowly move the terrain around
    modelmatrix.appendTranslation(
        Math.cos(t/300)*1000,Math.cos(t/200)*1000 + 500,-130); 
    // clear the matrix and append new angles
    modelViewProjection.identity();
    modelViewProjection.append(modelmatrix);
    modelViewProjection.append(terrainviewmatrix);
    modelViewProjection.append(projectionmatrix);    
    // pass our matrix data to the shader program
    context3D.setProgramConstantsFromMatrix(
        Context3DProgramType.VERTEX, 
        0, modelViewProjection, true );
    context3D.drawTriangles(terrainMesh.indexBuffer, 
        0, terrainMesh.indexBufferCount);        
}
private function enterFrame(e:Event):void 
{
    // clear scene before rendering is mandatory
    context3D.clear(0,0,0); 
    // move or rotate more each frame
    t += 2.0;
    // scroll and render the terrain once
    renderTerrain();
    // how far apart each of the 4 spaceships is
    var dist:Number = 0.8; 
    // loop through each mesh we want to draw
    for (looptemp = 0; looptemp &amp;lt; 4; looptemp++)
    {
        // clear the transformation matrix to 0,0,0
        modelmatrix.identity();
        // each mesh has a different texture, 
        // shader, position and spin speed
        switch(looptemp)
        {
            case 0:
                context3D.setTextureAt(0, myTexture);
                context3D.setProgram ( shaderProgram1 );
                modelmatrix.appendRotation(t*0.7, Vector3D.Y_AXIS);
                modelmatrix.appendRotation(t*0.6, Vector3D.X_AXIS);
                modelmatrix.appendRotation(t*1.0, Vector3D.Y_AXIS);
                modelmatrix.appendTranslation(-dist, dist, 0);
                break;
            case 1:
                context3D.setTextureAt(0, null);
                context3D.setProgram ( shaderProgram2 );
                modelmatrix.appendRotation(t*-0.2, Vector3D.Y_AXIS);
                modelmatrix.appendRotation(t*0.4, Vector3D.X_AXIS);
                modelmatrix.appendRotation(t*0.7, Vector3D.Y_AXIS);
                modelmatrix.appendTranslation(dist, dist, 0);
                break;
            case 2:
                context3D.setTextureAt(0, myTexture);
                context3D.setProgram ( shaderProgram3 );
                modelmatrix.appendRotation(t*1.0, Vector3D.Y_AXIS);
                modelmatrix.appendRotation(t*-0.2, Vector3D.X_AXIS);
                modelmatrix.appendRotation(t*0.3, Vector3D.Y_AXIS);
                modelmatrix.appendTranslation(-dist, -dist, 0);
                break;
            case 3:
                context3D.setProgramConstantsFromVector(
                    Context3DProgramType.FRAGMENT, 0, Vector.&amp;lt;Number&amp;gt;
                    ([ 1, Math.abs(Math.cos(t/50)), 0, 1 ]) );
                context3D.setTextureAt(0, myTexture);
                context3D.setProgram ( shaderProgram4 );
                modelmatrix.appendRotation(t*0.3, Vector3D.Y_AXIS);
                modelmatrix.appendRotation(t*0.3, Vector3D.X_AXIS);
                modelmatrix.appendRotation(t*-0.3, Vector3D.Y_AXIS);
                modelmatrix.appendTranslation(dist, -dist, 0);
                break;
        }
        // clear the matrix and append new angles
        modelViewProjection.identity();
        modelViewProjection.append(modelmatrix);
        modelViewProjection.append(viewmatrix);
        modelViewProjection.append(projectionmatrix);
        // pass our matrix data to the shader program
        context3D.setProgramConstantsFromMatrix(
            Context3DProgramType.VERTEX, 
            0, modelViewProjection, true );
        // draw a spaceship mesh
        // position
        context3D.setVertexBufferAt(0, myMesh.positionsBuffer, 
            0, Context3DVertexBufferFormat.FLOAT_3);
        // tex coord
        context3D.setVertexBufferAt(1, myMesh.uvBuffer, 
            0, Context3DVertexBufferFormat.FLOAT_2);
        // vertex rgba
        context3D.setVertexBufferAt(2, myMesh.colorsBuffer, 
            0, Context3DVertexBufferFormat.FLOAT_4);
        // render it
        context3D.drawTriangles(myMesh.indexBuffer, 
            0, myMesh.indexBufferCount);        
    }
    // present/flip back buffer
    // now that all meshes have been drawn
    context3D.present();
    // update the FPS display
    fpsTicks++;
    var now:uint = getTimer();
    var delta:uint = now - fpsLast;
    // only update the display once a second
    if (delta &amp;gt;= 1000) 
    {
        var fps:Number = fpsTicks / delta * 1000;
        fpsTf.text = fps.toFixed(1) + &amp;quot; fps&amp;quot;;
        fpsTicks = 0;
        fpsLast = now;
    }
    // update the rest of the GUI
    updateScore();
}
} // end of class
} // end of package
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="-6-textures-making-things-look-pretty"&gt;第6章，Textures: Making Things Look Pretty&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;贴图必须满足2次方&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;textures must have a length and width that fall into these values: 2,4,8,16,32,64,128,256,512,1024 and so on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;UV坐标&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The coordinate U is the left-right axis in a texture, while V represents the up-down axis. Therefore, the bottom of a texture has V of 1 and the far right would have U of 1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="/image/molehill_book04.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;透明Textures&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also use a .PNG file, complete with variable transparency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Animating UVs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如水的特效，可以让uv不断增加一点点，然后uv_offsets传到shader里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// increment the x axis of a vector3D
uv_offsets.x += 0.01;
// send this vector to the AGAL variable vc4
context3D.setProgramConstantsFromVector(Context3DProgramType.VERTEX,4, uv_offsets, true );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在shader里把uv做加法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add v1, va1, vc4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Texture Atlases&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A great technique to increase your game&amp;#39;s framerate and allow more meshes to be rendered&lt;br&gt;using the same shader is to pack multiple textures into a large bitmap called a texture atlas. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是提升效率的很重要手段，因为可以把很多不同贴图的模型，放在一次draw call 里。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using texture atlases is definitely the best practice for rendering fonts in your 3D world .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="/image/molehill_book04.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Animated Textures&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一种方法：in your render loop you could switch the texture you send to context3D.setTextureAt() every few frames.&lt;/p&gt;
&lt;p&gt;第2种方法：simple send a new offset in a setProgramConstantsFromVector() call to shift the texture coordinates over to the next frame&lt;/p&gt;
&lt;p&gt;显然第一种方法是很慢很蠢的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Manipulating Texture Data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以每帧调用uploadFromBitmapData()，但这样效率是很低的，要避免这么做。&lt;br&gt;如果决定非要这么做了的话，还可以给bitmapdata加滤镜Anything AS3 code you have around that can generate bitmapdata can be used to as the source pixels for your textures。&lt;/p&gt;
&lt;h2 id="render-states-blend-modes-backface-culling-depth-testing"&gt;Render States：Blend modes, backface culling, depth testing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Backface Culling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，效率关系只显示mesh可以看见的那一面。如果想两面都显示要这样不做背面裁剪&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;context3D.setCulling(Context3DTriangleFace.NONE);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可选的参数包括&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Context3DTriangleFace.NONE (不裁剪),
Context3DTriangleFace.BACK (默认情况，背面被裁剪),
Context3DTriangleFace.FRONT (与正常情况相反，正面被裁减)
Context3DTriangleFace.BOTH (没什么用，全裁剪，不渲染任何东西).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Depth Testing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;stage3d在每个在屏幕上的像素都保存一个深度值叫做zbuffer，默认molehill只渲染离camera近的像素，但当你不想为某个mesh保存深度信息（比如爆炸特效或者透明区域例如窗户）就要设置 setDepthTest（）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For example, if you are going to render a transparent mesh like a window that you don&amp;#39;t want to draw on the zbuffer (so that other objects are always visible behind it) but you DO want it to be obscured by furniture in the room that is in front of it, simply use:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;context3D.setDepthTest(false, Context3DCompareMode.LESS);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第1个boolean值为true表示下一个要渲染的mesh写入depth buffer，反之不写入。&lt;br&gt;第2个参数可以是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Context3DCompareMode.ALWAYS
 Context3DCompareMode.EQUAL
 Context3DCompareMode.GREATER
 Context3DCompareMode.GREATER_EQUAL
 Context3DCompareMode.LESS
 Context3DCompareMode.LESS_EQUAL
 Context3DCompareMode.NEVER
 Context3DCompareMode.NOT_EQUAL
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;The pixel in question will only be rendered when a comparison between it and the&lt;br&gt;destination pixel are TRUE based on the preceding criteria. The default in Stage3D is to only&lt;br&gt;render pixels that have a depth value that is LESS than what is already on the screen, closer&lt;br&gt;to the camera.&lt;br&gt;The preceding example is handy if you are going to render a transparent mesh like a window&lt;br&gt;that you don&amp;#39;t want to draw on the zbuffer (so that other objects are always visible behind&lt;br&gt;it), but you DO want it to be obscured by furniture in the room that is in front of it.&lt;br&gt;Like with other render states, this will be in effect until you set it to something else. You only&lt;br&gt;need to call it once and that criteria will be used until you instruct Flash otherwise.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Blend Modes&lt;/strong&gt;&lt;br&gt;混合模式影响如何渲染texture&lt;/p&gt;
&lt;p&gt;在画mesh之前调用Context3D.setBlendFactors()，传递两个乘数给flash，告诉molehill用什么颜色渲染texture。&lt;/p&gt;
&lt;p&gt;可选参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Context3DBlendFactor.DESTINATION_ALPHA
Context3DBlendFactor.DESTINATION_COLOR
Context3DBlendFactor.ONE
Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA
Context3DBlendFactor.ONE_MINUS_DESTINATION_COLOR
Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA
Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR
Context3DBlendFactor.SOURCE_ALPHA
Context3DBlendFactor.SOURCE_COLOR
Context3DBlendFactor.ZERO
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;渲染公式： framebuffercolor = (fragmentcolor &lt;em&gt; srcBlend) + (framebuffercolor &lt;/em&gt; destBlend).&lt;/p&gt;
&lt;p&gt;这是stage3d默认参数，完全不透明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// this is the Molehill default: nice for opaque textures
// all of the color on screen comes from the fragment color
context3D.setBlendFactors(Context3DBlendFactor.ONE,Context3DBlendFactor.ZERO);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常见的使用透明贴图的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// this is the proper setting to use .png textures
// that have transparent regions
// perfect for foliage/fences/fonts
context3D.setBlendFactors(
Context3DBlendFactor.SOURCE_ALPHA,
Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加亮：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// this setting makes it lighten the scene only
// good for particles stored as .jpg
// (only white sections add to the screen - black is not drawn)
context3D.setBlendFactors(
Context3DBlendFactor.SOURCE_COLOR,
Context3DBlendFactor.ONE);
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Blend modes, backface culling, and depth testing are all render states, meaning that you&lt;br&gt;only have to set them once and that behavior continues to be in effect until you set it to&lt;br&gt;something else.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效率：&lt;/p&gt;
&lt;p&gt;不透明的jpg贴图效率更高，避免overdraw，看不到的不draw，多用zbuffer，从近到远的顺序draw，避免statechange（backface culling ,depth testing,blendmodes），尽量短的shader，越少mesh越好，组合mesh让drawTriangles()调用次数越少越好，只渲染实际可见的mesh（这就要用到PVS算法，quad-trees, BSP trees, and portals了）&lt;/p&gt;
&lt;p&gt;最后做了demo，具体看Stage3dGame.as代码了&lt;/p&gt;
&lt;p&gt;本章总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In this chapter, we focused primarily upon three functions that affect how your meshes are&lt;br&gt;rendered: setBlendFactors, setCulling, and setDepthTest. Creative use of these&lt;br&gt;special render states open your game world up to all sorts of special effects.&lt;br&gt;In implementing this new functionality, we achieved a few milestones. Our game engine is&lt;br&gt;now using multiple textures and several meshes; we have code for rendering textures using&lt;br&gt;new blend modes which allow us to render special effects such as explosions and smoke.&lt;br&gt;We can change whether backfaces are culled on meshes, so that we can draw the insides of&lt;br&gt;transparent objects, we can ignore or use the zbuffer as desired, and we are now detecting&lt;br&gt;key presses for user control of the action.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="-7-timers-inputs-and-entities-gameplay-goodness-"&gt;第7章，Timers, Inputs, and Entities: Gameplay Goodness!&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;前边介绍了两个3d不相关的类&lt;br&gt;GameTimer&lt;br&gt;GameInput&lt;/p&gt;
&lt;p&gt;后面抽象出了一个Stage3dEntity基类.&lt;br&gt;介绍了一个技巧就是设置dirty flag，然后下一帧渲染的时候一起更新transform矩阵。&lt;/p&gt;
&lt;p&gt;其他很多数学方法并没有详细介绍原理。&lt;/p&gt;
&lt;p&gt;本章总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;We now have a class that measures time for use in animations&lt;/li&gt;
&lt;li&gt;We also have a new class that detects the player keyboard and mouse input&lt;/li&gt;
&lt;li&gt;We created a game entity class for use by all in-game objects&lt;/li&gt;
&lt;li&gt;We programmed a simple chase camera with mouse-look&lt;/li&gt;
&lt;li&gt;We upgraded our game to include a heads-up-display overlay and many new in-game models and effects&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id="-8-eye-candy-aplenty"&gt;第8章，Eye-Candy Aplenty&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;粒子是两个mesh型变做法不是很通用的粒子做法，可用性不高，略了，不过这种做法用AGAL做顶点动画的部分还是值得看一下的。&lt;/p&gt;
&lt;h3 id="-9-a-world-filled-with-action"&gt;第9章，A World Filled with Action&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;深入到游戏细节了，已经没有stage3d的内容了，碰撞检测和可视过滤都是算圆形距离的，不够深入。还有些ui什么的参杂在里边，代码细节太多实在没心情仔细看了。&lt;/p&gt;
&lt;h3 id="-10-chapter-10-3-2-1-action-"&gt;第10章，Chapter 10: 3... 2... 1... ACTION!&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;貌似是重构一些代码? 都是游戏逻辑，没有stage3d内容了，我就没看了。&lt;/p&gt;
&lt;h2 id="-"&gt;总结&lt;/h2&gt;
&lt;p&gt;书还不错，我确实入门了，遗憾是数学部分没有专门讲解， 如果有本续集，深度一些就好了。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>ObjectSocket-让Flash与Nodejs更方便的交互</title>
    <id>http://nshen.net/project/2013-06-03/object-socket</id>
    <link href="http://nshen.net/project/2013-06-03/object-socket"/>
    <updated>2013-06-03T14:56:31.000Z</updated>
    <content>&lt;p&gt;flash与nodejs通过socket直接互相发送json object，解决粘包分包等问题。&lt;/p&gt;
&lt;h3 id="-"&gt;项目地址&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/nshen/ObjectSocket"&gt;https://github.com/nshen/ObjectSocket&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="-"&gt;测试代码&lt;/h2&gt;
&lt;h3 id="flash-"&gt;Flash端&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
/**
    * @author nshen.net
    * @date 2013/5/31 15:47
    */

package  
{
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.ProgressEvent;
    import flash.net.Socket;
    import flash.utils.ByteArray;
    import flash.utils.Endian;
    import flash.utils.setInterval;

    public class Main extends Sprite
    {
        private var _socket:ObjectSocket ;
        public function Main() 
        {
                _socket = new ObjectSocket(onData); //ObjectSocket是Socket的子类
                _socket.addEventListener(Event.CONNECT,onConnect);//侦听连接事件 
                _socket.addEventListener(Event.CLOSE, onClose);
                _socket.connect(&amp;#39;127.0.0.1&amp;#39;,2345);//连接服务端 
        }

        //收到服务器传来的object会回调到这里
        private function onData(obj:Object):void 
        {
                trace(&amp;quot;receive object: &amp;quot;,obj.num, obj.name, obj.b , obj.arr);
        }

        private function onClose(e:Event):void 
        {
            trace(&amp;quot;onClose&amp;quot;)
        }

        private static var sendnum:uint = 0;
        private function onConnect(e:Event):void 
        {
            trace(&amp;#39;连接成功&amp;#39;); 

            //开始以每隔5毫秒的速度疯狂向服务器发送Object
            setInterval(function():void { 
                var obj:Object = {
                    num: sendnum++,
                    name: (&amp;quot;client&amp;quot; + Math.random().toString()),
                    b: Math.random() &amp;gt; 0.5,
                    arr: [ 1, 2, 3, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;]
                    }

                _socket.sendObject(obj); //向服务器发送obj

            } , 3);

        }

    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="nodejs-typescript-"&gt;nodejs端(Typescript)&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
/// &amp;lt;reference path=&amp;quot;./d/node/node.d.ts&amp;quot; /&amp;gt;

import net = module(&amp;quot;net&amp;quot;);
import n = module(&amp;quot;./ObjectSocket&amp;quot;);

var objSocket: n.ObjectSocket;

var server: net.Server = net.createServer(function (socket: net.NodeSocket): void {
    console.log(&amp;quot;connect&amp;quot;);
    objSocket = new n.ObjectSocket(socket);    

    objSocket.on(&amp;quot;data&amp;quot;, function (obj:any) { //客户端传来了Object
        console.log(&amp;quot;receive object: &amp;quot;,obj.num, obj.name, obj.b , obj.arr);
    })

    objSocket.on(&amp;quot;end&amp;quot;, function () {
        console.log(&amp;quot;on end&amp;quot;)
    })

    //开始以每隔5毫秒的速度疯狂向客户端发送Object
    sendPackages(objSocket);
})

var sendnum:number = 0;
function sendPackages(socket:n.ObjectSocket): void
{
    setInterval(function () {
        var obj: any = {
            num: sendnum++,
            name: (&amp;quot;server&amp;quot; + Math.random().toString()),
            b: Math.random() &amp;gt; 0.5,
            arr: [&amp;lt;any&amp;gt; 1, 2, 3, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;]
        }
        socket.sendObject(obj); //向客户端发送obj
    }, 5);
}

server.listen(2345, &amp;quot;localhost&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>从 ActionScript3 到 TypeScript</title>
    <id>http://nshen.net/article/2013-05-18/as3-to-typescript</id>
    <link href="http://nshen.net/article/2013-05-18/as3-to-typescript"/>
    <updated>2013-05-18T14:56:31.000Z</updated>
    <content>&lt;p&gt;以下是我总结的笔记，只涉及语法部分，有错漏请指正。&lt;/p&gt;
&lt;p&gt;PS.我曾经用正则表达式写过一个AS3转TypeScript的&lt;a href="http://nshen.net/project/2014-11-21/as2ts/"&gt;在线转换器&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="-"&gt;基本类型&lt;/h2&gt;
&lt;p&gt;基础类型只有这么几种，与AS3对比&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;TypeScript&lt;/th&gt;
&lt;th style="text-align:center"&gt;ActionScript3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td style="text-align:center"&gt;Number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td style="text-align:center"&gt;String&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean(0.8以前为bool)&lt;/td&gt;
&lt;td style="text-align:center"&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;td style="text-align:center"&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;undefined&lt;/td&gt;
&lt;td style="text-align:center"&gt;undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td style="text-align:center"&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!-- more --&gt;
&lt;!--
&lt;table &gt;
  &lt;tr&gt;&lt;td&gt;&lt;B&gt;TypeScript&lt;/B&gt;&lt;/td&gt;&lt;td&gt;&lt;B&gt;ActionScript3&lt;/B&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;number&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;boolean(0.8以前为bool)&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;any&lt;/td&gt;&lt;td&gt;*&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;undefined&lt;/td&gt;&lt;td&gt;undefined&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;null&lt;/td&gt;&lt;td&gt;null&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
--&gt;
&lt;h2 id="-"&gt;任意类型&lt;/h2&gt;
&lt;p&gt;ActionScript3 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;var anyType : * = ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;var anyType : any = ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;变量修饰符&lt;/h2&gt;
&lt;p&gt;TS类似AS3 但不用写&amp;quot;var&amp;quot; ， &lt;del&gt;没有protected (未来也许会添加)&lt;/del&gt; &lt;strong&gt;TypeScript 1.3 加入了protected关键字，与AS3用法一致&lt;/strong&gt;，默认为public。&lt;/p&gt;
&lt;p&gt;ActionScript3 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;private var str: String = &amp;quot;abc&amp;quot;;
public  var num: Number = 123;
var num2 :Number = 456;
static var bo: Boolean = true;
public var createTime: String;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;private str: string = &amp;quot;abc&amp;quot;;    // private property
public  num: number = 123;      // public property
num2 :number = 456;             // 不写默认也为public
static bo: boolean = true;         // static
public createTime: string;      //createTime 类型为string，值为 undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;变量类型转换&lt;/h2&gt;
&lt;p&gt;ActionScript3 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;var str:String = &amp;quot;abc&amp;quot;;
var strNum:Number = Number(str);
var strNum:Number = str as Number;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;var str : string = &amp;quot;abc&amp;quot;;
var strNum: number = &amp;lt;number&amp;gt; str; //编译报错 Cannot convert &amp;#39;string&amp;#39; to &amp;#39;number&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现使用any类型会编译通过：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;var str2 :any = &amp;quot;abc&amp;quot;; //any类型
var strNum2 :number = &amp;lt;number&amp;gt; str2; //通过
strNum2 += 5; // abc5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用 instanceof 判断类型&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;// instanceof
function CalculateArea(shape : Shape) : number {
    if (shape instanceof Square) {
        return (&amp;lt;Square&amp;gt;shape).x * (&amp;lt;Square&amp;gt;shape).y;
    }
    if (shape instanceof Ellipse) {
        return (&amp;lt;Ellipse&amp;gt;shape).r1 * (&amp;lt;Ellipse&amp;gt;shape).r2 * Math.PI;
    }
    if (shape instanceof Triangle) {
        return 0.5 * (&amp;lt;Triangle&amp;gt;shape).x * (&amp;lt;Triangle&amp;gt;shape).y;
    }
    throw new TypeError(&amp;quot;Unsupported type!&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;数组&lt;/h2&gt;
&lt;p&gt;Typescript数组的写法比AS3漂亮很多&lt;/p&gt;
&lt;p&gt;ActionScript3 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
var arr:Array = [1,2,3,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]; // 任意类型数组
var strArray:Vector.&amp;lt;String&amp;gt; = Vector.&amp;lt;String&amp;gt;([&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]); //固定类型数组

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
var arr: any[] = new Array(); // 任意类型数组
var strArr: string[] = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot; ]; //固定类型数组

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二维数组&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
var array2d: string[][] = [
    [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;],
    [&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;]
];

// or

var array2d: string[][] = new Array();
array2d.push([&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]);
array2d.push([&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;]);

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="object-types"&gt;Object Types&lt;/h3&gt;
&lt;p&gt;当AS3调用这样一个函数时，会有下面一个问题。&lt;/p&gt;
&lt;p&gt;ActionScript3 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
function CalculateArea ( rect : Object ):Number
{
    return rect.width * rect.height;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时编译器并不知道rect这个Object里到底有没有width和height，只能等到runtime时才会知道。&lt;/p&gt;
&lt;p&gt;TypeScript 引入&lt;strong&gt;Object Types&lt;/strong&gt;解决这一问题，可以指定Object参数的具体内容，相当于让Object参数实现了interface&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
function CalculateArea(rect: {width: number; height: number;}): number
{
    return rect.width * rect.height;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时如果调用&lt;strong&gt;CalculateArea({w:123,h:456});&lt;/strong&gt;  编译器不会通过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Object Types&lt;/strong&gt; 还支持”?&amp;quot;表示可选参数&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
function CalculateArea(rect: {width:number; height:number; depth?:number;}): number
{
    if(rect.depth)
    {
        return rect.width * rect.height * rect.depth;
    }
    return rect.width * rect.height;
    }

    CalculateArea({w:123,h:456}); //编译器报错
    CalculateArea({width:123,height:456}); // 通过
    CalculateArea({width:123,height:456,depth:789}); // 通过

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以这样声明一个Object&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;    var example: {
        name: string;
        id: number;
        collection: string[]; 
    } = {
        name: &amp;#39;Example&amp;#39;,
        id: 5,
        collection: [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ActionScript3 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
    var fun:Function;
    var fun2:Function = someFunction;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript 可以指定Function需要的参数和返回值类型，叫做函数签名，所以变成了这样&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
    var fun : (str: string) =&amp;gt; void;   // fun是输入为string，没有输出的函数
    var fun2 : (num: number) =&amp;gt; number = someFnction;  //someFnction函数必须输入输出都为number类型

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;eg.指定callback函数为string输入，any输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
function vote(candidate: string, callback: (result: string) =&amp;gt; any) {
// ...
}

vote(&amp;quot;BigPig&amp;quot;,
    function(result: string) {
        if (result === &amp;quot;BigPig&amp;quot;) {
            // ...
        }
    });

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript 这样的语法虽然使Function更清晰了，但也带来麻烦，比如一个简单的输入输出都是string的函数就要写好长不易阅读&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
var sayHello: (input: string) =&amp;gt; string = function (s: string) {
    return &amp;quot;Hello &amp;quot; + s;
}

//保存函数的数组也写很长
var strArray: { (s: string): string; }[] = [sayHello, function aa(str: string) { return str; }];    //两个输入输出都为string的函数

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以引入了 函数接口&lt;/p&gt;
&lt;h2 id="-"&gt;函数接口&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
//定义输入输出都是字符串的函数的接口
interface IStringFunction {
    (input: string) : string;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边很长的都可以这么写了&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
var sayHello: IStringFunction = function (s: string) {
    return &amp;quot;Hello &amp;quot; + s;
}
var strArray: IStringFunction[];
strArray.push(sayHello);

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;可选参数加&amp;quot;?&amp;quot;&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
//带默认值
function func (a: number, b?: bool = false): number
    {
    if (b) { return a + b };
    return a;
}

//不带默认值，要自己判断了
function func (a: number,b?: bool): number 
{
    if ( b !== null &amp;amp;&amp;amp; b !== undefined )
    {
    if ( b) { return a + b };
    }
    return a;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="rest-paramname-paramtype-"&gt;rest参数 ...paramName[:paramType]&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
function CountDwarvesTallerThan(minHeight: number, ...dwarves: Dwarf[]) : number 
{
    var count: number = 0;
    for (var i = 0; i &amp;lt; dwarves.length; i++) {
        if (dwarves[i].height &amp;gt; minHeight) {
            count++;
        }
    }
    return count;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="arrow-function"&gt;Arrow Function&lt;/h2&gt;
&lt;p&gt;关于this作用域的问题，AS1时代经常用到的一个技巧：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
var _this = this

var messenger = {
    message: &amp;quot;Hello World&amp;quot;,
    start: function() {
    var _this = this;
    setTimeout(function() { 
        alert(_this.message); 
        }, 3000);
    }
};
messenger.start();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript把这个技巧封装到语言里了，叫&lt;strong&gt;Arrow Function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法格式为 &lt;code&gt;()=&amp;gt;{}&lt;/code&gt;，例子：&lt;/p&gt;
&lt;p&gt;TypeScript：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
var messenger = {
    message: &amp;quot;Hello World&amp;quot;,
    start: function() {
        setTimeout(() =&amp;gt; { alert(this.message); }, 3000);
    }
};
messenger.start();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译后的JavaScript跟上边的一样&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;
var messenger = {
    message: &amp;quot;Hello World&amp;quot;,
    start: function () {
        var _this = this;
        setTimeout(function () {
            alert(_this.message);
        }, 3000);
    }
};
messenger.start();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;网上找到的一个例子，&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
//declare var 为环境声明，用来告诉编译器已知的变量类型，例如浏览器定义的一些变量类型

declare var menu: HTMLElement;       
declare var sideBar: HTMLElement;

class UITester {
    menuTouches: number;
    sidebarTouches: number;

    beginMenuTest(): void {
        this.menuTouches = 0;   // Right!!
        menu.onmouseenter = function (e) {
            this.menuTouches++;  // Wrong!! 
        }
    }

    beginSidebarTest(): void {
        this.sidebarTouches = 0;  // Right!!
        sideBar.onmousemove = e =&amp;gt; {  
            this.sidebarTouches++;  // Still right!!
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;语法中用了(e)=&amp;gt;{} ,将e传给后边的函数，并且省略了e的括号，会编译成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;
var UITester = (function () {
    function UITester() { }
    UITester.prototype.beginMenuTest = function () {
        this.menuTouches = 0;
        menu.onmouseenter = function (e) {
            this.menuTouches++;
        };
    };
    UITester.prototype.beginSidebarTest = function () {
        var _this = this;
        this.sidebarTouches = 0;
        sideBar.onmousemove = function (e) {
            _this.sidebarTouches++;
        };
    };
    return UITester;
})();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有篇教程详细解释了这个语法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.codebelt.com/typescript/arrow-function-typescript-tutorial/"&gt;http://www.codebelt.com/typescript/arrow-function-typescript-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="-"&gt;类相关的&lt;/h2&gt;
&lt;p&gt;TypeScript中的module相当于ActionScript3中的Package&lt;/p&gt;
&lt;p&gt;TypeScript中构造函数的函数名用&lt;strong&gt;constructor&lt;/strong&gt; ，而不用类名。&lt;/p&gt;
&lt;p&gt;TypeScript:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
module net.nshen { 
    export class Test1
    {
        private str: string = &amp;quot;abc&amp;quot;;    // private property
        public  num: number = 123;      //public property

        public createTime: string;      //createTime = undefined

        constructor() // constructor
        {
            this.createTime = new Date().toUTCString();
        }

        static traceDate(): void
        {
            var currentDate: Date = new Date(); 
            console.log(currentDate.toUTCString());
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用Static方法&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
net.nshen.Test1.traceDate();

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="module-"&gt;module原理&lt;/h2&gt;
&lt;p&gt;module始终是要编译成JS代码的，写一个简单的module看一下原理：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
module M {
    var s = &amp;quot;hello&amp;quot;;
    export function f() {
        return s;
        }
}

M.f();
M.s;  // Error, s is not exported

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译后的JS代码&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;
var M;
(function(M) {
    var s = &amp;quot;hello&amp;quot;;
    function f() {
    return s;
    }
    M.f = f;
})(M||(M={}));

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;据说这是js界很流行的写法，叫做&lt;strong&gt;JavaScript module pattern&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="-"&gt;函数重载&lt;/h2&gt;
&lt;p&gt;AS3和JS都是不支持函数重载的，TypeScript以一种鸡肋的方式支持着。&lt;/p&gt;
&lt;p&gt;先写一些同名的函数声明，最后在一个同名函数里写出实现（要自己判断参数类型）：&lt;/p&gt;
&lt;p&gt;TypeScript:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
function attr(name: string): string;
function attr(name: string, value: string): Accessor;
function attr(map: any): Accessor;

function attr(nameOrMap: any, value?: string): any {
    if (nameOrMap &amp;amp;&amp;amp; typeof nameOrMap === &amp;quot;object&amp;quot;) {
        // handle map case
    }
    else {
        // handle string case
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终会编译成一个JS方法：&lt;/p&gt;
&lt;p&gt;JavaScript：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;
function attr(nameOrMap, value) {
    if (nameOrMap &amp;amp;&amp;amp; typeof nameOrMap === &amp;quot;object&amp;quot;) {
    } else {
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;2014/12/07 补充 : js判断类型也是个很大的坑,详见 &lt;a href="http://tobyho.com/2011/01/28/checking-types-in-javascript/"&gt;http://tobyho.com/2011/01/28/checking-types-in-javascript/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TypeScript 允许多个类在同一个文件里，但如果类与类在不同的文件，需要这种写法，相当于AS3 的 import&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
/// &amp;lt;reference path=&amp;quot;SimpleWebSocket.ts&amp;quot;/&amp;gt;
class ComplexWebSocket extends SimpleWebSocket {
...
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;override方法子类不需要写关键字，直接同名方法即可 ，可调用super.xxx()&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
class Base {

    public test():number
    {
        return 1;
    }

    public test2():number
    {
        return 2;
    }
}

class Derived extends Base {

    public test():number
    {
        return 3;
    }

    public test2():number
    {
        return super.test();
    }

}

var d:Derived = new Derived();
console.log(d.test()); // 3
console.log(d.test2());// 1

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="enum"&gt;Enum&lt;/h2&gt;
&lt;p&gt;TypeScript支持enum关键字&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;
enum Color { Red, Green, Blue }
console.log(Color.Red); // 0
var c:number = Color.Green;
console.log(Color[c])  //Green

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成对应的js&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;
var Color;
(function (Color) {
    Color[Color[&amp;quot;Red&amp;quot;] = 0] = &amp;quot;Red&amp;quot;;
    Color[Color[&amp;quot;Green&amp;quot;] = 1] = &amp;quot;Green&amp;quot;;
    Color[Color[&amp;quot;Blue&amp;quot;] = 2] = &amp;quot;Blue&amp;quot;;
})(Color || (Color = {}));
console.log(Color.Red);
var c = Color.Green;
console.log(Color[c]);//Green

&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>读书《黑客与画家》如何创造财富</title>
    <id>http://nshen.net/article/2012-04-09/how-to-make-money</id>
    <link href="http://nshen.net/article/2012-04-09/how-to-make-money"/>
    <updated>2012-04-09T14:56:31.000Z</updated>
    <content>&lt;h1 id="-"&gt;如何创造财富&lt;/h1&gt;
&lt;p&gt;《黑客与画家》第8章笔记&lt;br&gt;&lt;!-- more --&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/image/howToMakeMoney.png" target="_blank" &gt;图片过大，新窗口打开&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/image/howToMakeMoney.png" alt="如何创造财富"&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>基于AIR的跨平台小游戏《阿鼻地狱》</title>
    <id>http://nshen.net/project/2011-10-05/go-to-hell</id>
    <link href="http://nshen.net/project/2011-10-05/go-to-hell"/>
    <updated>2011-10-05T14:56:31.000Z</updated>
    <content>&lt;p&gt;本是用来参加腾讯和天地会举办的flash手机游戏开发大赛的游戏，完整代码见最下边。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;使用Flixel游戏引擎开发，像素图+程序一手操办，AIR3.0打包，可以跨IOS，Android的。&lt;/p&gt;
&lt;p&gt;当时在iphone4上测试基本维持在30帧。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="2011-10-05-"&gt;2011-10-05发布剪辑的视频：&lt;/h3&gt;
&lt;embed src="http://player.youku.com/player.php/sid/XMzA5OTI2NDYw/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="610" height="500"&gt;&lt;/embed&gt;

&lt;hr&gt;
&lt;h3 id="2011-10-06-iphone4-"&gt;2011-10-06发布iphone4实机测试视频:&lt;/h3&gt;
&lt;embed src="http://player.youku.com/player.php/sid/XMzEwMzE2Njky/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="610" height="500"&gt;&lt;/embed&gt;


&lt;hr&gt;
&lt;h3 id="-"&gt;实机拍摄环境比较简陋&lt;/h3&gt;
&lt;p&gt;是用我老婆的g7手机拍的，效果不太好，没办法先这样吧&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/hell01.jpg" alt=""&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-"&gt;概念涂鸦一张&lt;/h3&gt;
&lt;p&gt;&lt;img src="/image/hell02.jpg" alt=""&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://github.com/nshen/goToHell" target="_blank"&gt;完整代码：https://github.com/nshen/goToHell &lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>AS3与数据结构</title>
    <id>http://nshen.net/article/2011-08-25/as3-data-structure</id>
    <link href="http://nshen.net/article/2011-08-25/as3-data-structure"/>
    <updated>2011-08-25T14:56:31.000Z</updated>
    <content>&lt;p&gt;时至今日国内外都还没有一本专讲AS3与数据结构的书，对于我这种非科班毕业的社会闲杂人等来说，入门数据结构太难了，我参考了各方代码，经过一段时间的恶补，整理了一下目前Flash开发中有可能遇得到的数据结构。完整代码在文章结尾有下载，如有错漏请直接指出谢谢。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="-"&gt;数组&lt;/h2&gt;
&lt;p&gt;Array类应该是Flash里最常用的数据结构了。比其他语言的数组高级和灵活许多，随意装入任何数据类型，不用固定长度。&lt;br&gt;访问速度快，从后方添加(push)和删除(pop)快，但从中间或开头删除会很慢。&lt;/p&gt;
&lt;p&gt;从100万长度的数组开头删除500个元素在我的机器上差不多要1秒钟。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;var arr:Array = []
for(var i:uint= 0 ;i&amp;lt;1000000;i++)arr[i]=i ;
var startT:Number = getTimer()
var num:uint = 500
while(num&amp;gt;0)
{
    arr.splice(0,1)
    num--
}
trace(&amp;quot;time:&amp;quot;,getTimer() - startT)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果数组没有顺序的话，快速删除法1000个在我机器上才需要1毫秒。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;var arr:Array = []
for(var i:uint= 0 ;i&amp;lt;1000000;i++)arr[i]=i ;

var startT:Number = getTimer()
var num:uint = 1000
while(num&amp;gt;0)
{
    arr[0] =arr[arr.length-1]
    arr.length -=1
    num--
}
trace(getTimer() - startT)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vector：Vector是Array的升级版。如果想追求效率，恰巧数组中的元素类型是固定的，或者长度是固定的，就可以将Array换成Vector类提升效率。&lt;/p&gt;
&lt;h2 id="-"&gt;堆栈&lt;/h2&gt;
&lt;p&gt;堆栈是先进后出的结构，像子弹梭子一样，由于数组的push() pop()非常快，所以数组本身就是最好的堆栈。&lt;/p&gt;
&lt;h2 id="-"&gt;队列&lt;/h2&gt;
&lt;p&gt;队列是先进先出，数组也可以做队列，但是从数组前端删除数据比较慢，下边10万条数据我的机器运行差不多需要2秒。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;var startT:Number = getTimer()
var queue:Array = []
for(var i:int = 0 ; i&amp;lt;100000 ;i++)
{
    queue.push(i);
}
for(var i:int = 0 ; i&amp;lt;100000 ;i++)
{
    queue.shift()
}
trace(getTimer() - startT)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我参考as3ds改写了个链表（DLinkedList） ，实现了数组一样的 push() pop() shift() unshift() 四个方法。用这个链表只需要改一行代码，同样操作在我的机器上只要100多毫秒。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;var startT:Number = getTimer()
var queue:DLinkedList = new DLinkedList()
for(var i:int = 0 ; i&amp;lt;100000 ;i++)
{
    queue.push(i);
}
for(var i:int = 0 ; i&amp;lt;100000 ;i++)
{
    queue.shift()
}
trace(getTimer() - startT)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个链表是一个双向链表，可以当作各种队列也可以当作堆栈，效率都不错。&lt;/p&gt;
&lt;h2 id="-"&gt;链表&lt;/h2&gt;
&lt;p&gt;这个链表实现的是一个双向链表，因为删除数据会快些，单链表优点就是省一点点内存，但删除会慢很多，用处不大，所以没有实现。&lt;br&gt;我觉得除了把链表当成队列使用，平时几乎用不到。如果非要使用就要使用Iterator了，Iterator是一种设计模式，不懂可以搜索一下。&lt;br&gt;下边是对链表所有操作的演示。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
var l:DLinkedList = new DLinkedList()
l.push(1)
l.push(2)
l.push(3)
trace(l,l.head,l.tail) //[1,2,3] 1 3
l.pop()
trace(l,l.head,l.tail) //[1,2] 1 2
l.unshift(0)
trace(l,l.head,l.tail) //[0,1,2] 0 2
l.shift()
trace(l,l.head,l.tail) //[1,2] 1 2
l.push(3)
trace(l,l.head,l.tail) //[1,2,3] 1 3

//遍历,输出  1,2,3
var it:DListIterator = l.getIterator()
for(it.start() ; it.hasNext(); it.next())
{
    trace(it.node.data)
}
it.start()  // 索引归0
it.next()
l.remove(it) //remove 2
l.remove(it) //remove 3
trace(l,l.head,l.tail) //[1] 1 1
l.insert(it,2)
trace(l,l.head,l.tail) //[1,2] 1 2
l.insert(it,3)
trace(l,l.head,l.tail) //[1,3,2] 1 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;哈希表&lt;/h2&gt;
&lt;p&gt;哈希表应该就是Object？ 在Flash里Object是动态的，赋值就 obj.abc = 123 ,删除就 delete obj.abc&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
var o:Object = {}
o[&amp;quot;key&amp;quot;] = obj   //插入
delete o[&amp;quot;key&amp;quot;]  //删除
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果追求Object做key可以用flash.utils.Dictionary类代替Object。&lt;/p&gt;
&lt;h2 id="-"&gt;树&lt;/h2&gt;
&lt;p&gt;上边数组和链表都叫线性结构，树是典型的非线性数据结构，普通的树也不常用，但作为一个基础必须掌握，这里的树使用上边提到的双向链表存储子树。操作树要用TreeIterator，下边是演示。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;var tree:Tree = new Tree(0);
var itr:TreeIterator = tree.getIterator()
itr.appendChild(1)
itr.appendChild(2)

      0
     / \
    1   2

itr.down()
itr.appendChild(3)

         0
        / \
       1   2
      /
     3

itr.up()
itr.appendChild(4)

          0
        / | \
       1  2  4
      /
     3

itr.childEnd()
itr.down()
itr.prependChild(5)
itr.prependChild(6)

          0
        / | \
       1  2  4
      /      /\
     3      6  5

trace(tree.dump())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边的代码输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-markup"&gt;[TreeNode &amp;gt;(root) has 2 child nodes, data=room1]
+---[TreeNode &amp;gt; has 2 child nodes, data=room2]
|    +---[TreeNode &amp;gt;(leaf), data=room4]
|    +---[TreeNode &amp;gt;(leaf), data=room5]
+---[TreeNode &amp;gt;(leaf), data=room3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我实现了一个toXML方法，如果把tree.toXML(tree)赋给Flex的Tree组件的dataProvider属性，就会是这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/tree01.jpg" alt="/image/tree01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;树的遍历分为前序遍历和后序遍历，演示：&lt;/p&gt;
&lt;embed src="/image/TreeTraversal.swf" type="application/x-shockwave-flash" width="600" height="380" &gt;&lt;/embed&gt;

&lt;p&gt;&lt;a href="http://lab.polygonal.de/2007/05/15/data-structures-example-the-tree-class/" target="_blank"&gt;上边是直接来自as3ds的演示，了解更多点击这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码实现看着很简单，但很需要费脑子的，是递归实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
/**
* 前序遍历
*/
public function preorder(Node:Tree,Process:Function):void
{
    Process(Node)
    var itr:DListIterator = Node.children.getIterator()
    while(itr.hasNext())
    {
        preorder(Tree(itr.node.data),Process)
        itr.next();
    }
}

/**
* 后序遍历
*/
public function postorder(Node:Tree,Process:Function):void
{
    var itr:DListIterator =  Node.children.getIterator()
    while(itr.hasNext())
    {
        postorder(Tree(itr.node.data),Process)
    }
    Process(Node)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;二叉堆与优先队列&lt;/h2&gt;
&lt;p&gt;优先队列是一种特殊的队列，它不是先入先出，而是入队的元素会自动按你指定顺序排列，先出队的永远是你指定的顺序里排最前面的。&lt;br&gt;当然这个优先队列可以用数组实现，每次入队就push后排一次序，出队pop就可以了，但是这样效率不佳，我们的优先队列是使用二叉堆实现的。&lt;/p&gt;
&lt;p&gt;首先了解二叉树是只有2个子节点的树 ，二叉堆是一种特殊的二叉树，他的每个父节点都比子节点大。&lt;br&gt;里边用了些特殊的算法，让元素入队出队时效率更好。后边的A*寻路也用这个二叉堆来优化效率。具体算法见代码&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;var priorityQueue:Heap =new Heap() //新建二叉堆，默认从大到小排列
priorityQueue.enqueue(2) //入队9个数字
priorityQueue.enqueue(6)
priorityQueue.enqueue(5)
priorityQueue.enqueue(8)
priorityQueue.enqueue(7)
priorityQueue.enqueue(4)
priorityQueue.enqueue(1)
priorityQueue.enqueue(3)
priorityQueue.enqueue(9)

trace(priorityQueue)  //输出9,8,5,7,6,4,1,2,3   ，发现并不是按顺序排列的
trace(priorityQueue.dequeue())  //9 但出队时就已经是排序好的了
trace(priorityQueue.dequeue())  //8
trace(priorityQueue.dequeue())  //7
trace(priorityQueue.dequeue())  //6
trace(priorityQueue.dequeue())  //5
trace(priorityQueue.dequeue())  //4
trace(priorityQueue.dequeue())  //3
trace(priorityQueue.dequeue())  //2
trace(priorityQueue.dequeue())  //1

//如果想要逆序排列，只需要提供一个compare Function，这个跟数组sort方法里的compareFunction参数一样，如下：

var f:Function = function(a:int,b:int):int{return b-a}
var p:Heap =new Heap(f)
p.enqueue(2)
p.enqueue(6)
p.enqueue(5)
p.enqueue(8)
p.enqueue(7)
p.enqueue(4)
p.enqueue(1)
p.enqueue(3)
p.enqueue(9)

trace(p.dequeue()) //1
trace(p.dequeue()) //2
trace(p.dequeue()) //3
trace(p.dequeue()) //4
trace(p.dequeue()) //5
trace(p.dequeue()) //6
trace(p.dequeue()) //7
trace(p.dequeue()) //8
trace(p.dequeue()) //9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实Heap内部也是由数组存储的，它的算法有两个关键&lt;/p&gt;
&lt;p&gt;1) 如何用数组储存二叉树结构&lt;/p&gt;
&lt;p&gt;比如原树状结构为：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-markup"&gt;          4
         / \
        3   0
       /\
      1  2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则存储成数组为：&lt;code&gt;[4,3,0,1,2]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2) 如何永远保持parent比child大&lt;/p&gt;
&lt;p&gt;这点比较麻烦具体可以参考我的代码，或者找本书看看。&lt;/p&gt;
&lt;h2 id="-"&gt;四叉树&lt;/h2&gt;
&lt;p&gt;四叉树通常用于2d游戏碰撞检测。假设屏幕上有500个mc，每2个之间都要进行碰撞检测，那么每一个mc都要与其他499个mc进行一次碰撞检测，那每帧总共就接近做500×500 = 250000次检测。&lt;br&gt;如果是小球还好办，用半径法，如果碰上复杂的mc需要位图碰撞检测，那每帧检测25万次flash是吃不消的。&lt;br&gt;一个优化的办法就是只与有可能碰撞的mc进行碰撞检测，这时四叉树就派上用场了。&lt;/p&gt;
&lt;p&gt;移动鼠标会发现，只有红色的方块是有可能与鼠标拖动的方块产生碰撞的，你只要将鼠标方块与红色的方块逐个进行检测就好了，大大提升了效率&lt;/p&gt;
&lt;embed src="/image/QuadTree_retrieve.swf" type="application/x-shockwave-flash" width="500" height="500" &gt;&lt;/embed&gt;

&lt;p&gt;四叉树首先通过一个建树的过程将屏幕上的物体分配到，左上，右上，左下，右下四个象限中，这四个象限对应树的四个节点，每个象限还可以继续分成四个象限，根据具体情况考虑分配几层达到一个查找最快效果。&lt;/p&gt;
&lt;p&gt;对比一下速度，下边是数组遍历，250个Sprite，两两碰撞在我机器上就惨不忍睹了。 （放上鼠标开始）&lt;/p&gt;
&lt;embed src="/image/Array_collition.swf" type="application/x-shockwave-flash" width="500" height="600" wmode="transparent"&gt;&lt;/embed&gt;

&lt;blockquote&gt;
&lt;p&gt;四叉树版本，500个Sprite，2倍精灵的数量两两碰撞仍然跑的流畅（放上鼠标开始）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;embed src="/image/QuadTree_collition.swf" type="application/x-shockwave-flash" width="600" height="500"&gt;&lt;/embed&gt;

&lt;p&gt;四叉树的思想就是先屏幕分割，然后过滤出离自己很近的，有可能产生碰撞的进行碰撞检测。Flash界使用四叉树最出名的应该就是&lt;a href="http://flixel.org" target="_blank"&gt;Flixel游戏引擎&lt;/a&gt;，它把四叉树隐藏在碰撞检测的API里，用户不需要直接操作四叉树。&lt;br&gt;调用碰撞检测的同时，引擎内部就自动建树了。大家都看到Flixel引擎的效率是非常高的，各种大小相差几倍的精灵放在一起检测也没有问题，这也是四叉树分区相比网格分区的一个优势。可惜Flixel里的四叉树&lt;br&gt;经过了各种优化，已经不是传统四叉树的样子了，很难分离出来。as3ds包里也没有四叉树的实现，所以我又google了一下，在网上看到一个写的比较清晰的JavaScript版本&lt;a href="http://www.mikechambers.com/blog/2011/03/21/javascript-quadtree-implementation/" target="_blank"&gt;JavaScript QuadTree Implementation&lt;/a&gt;&lt;br&gt;又无意中搜到&lt;a href="http://code.google.com/p/ghostcat/source/browse/trunk/GhostCat/src/ghostcat/algorithm/QuadTree.as?r=584" target="_blank"&gt;GhostCat里也有一个四叉树类&lt;/a&gt;，GhostCat的这个版本是我看到写的最简洁的四叉树，很是佩服作者。&lt;br&gt;不过经过研究，他们有一个共同的问题就是只能把点(point)添加到树中，这对子弹或者小球的碰撞检测还好，但通常游戏中不论是MC还是Bitmap大都是有宽高的方形。如果把他们按照点来分配进树的话，就会有漏检查的情况出现。&lt;br&gt;下图是我将上边提到的，mikechambers写的JavaScript版本转成AS3后发现的问题，mike虽然已经将压线的矩形作为有可能碰撞的对象返回，但百密一疏，由于他是按照点来分配的，始终会有漏检&lt;/p&gt;
&lt;p&gt;&lt;img src="/image/tree02.jpg" alt="/image/tree02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;所以我又回头看Flixel里的四叉树是怎么插入的，最后综合以上所有版本，我写了我的这个四叉树类。就是上边演示的那个，代码在文章末尾下载包里，太长就不贴了，我记得应该是写了很多注释。大家可以研究讨论一下。&lt;/p&gt;
&lt;h2 id="-"&gt;图&lt;/h2&gt;
&lt;p&gt;图由节点node和指针arc组成，图的遍历与树差不多，分为广度优先遍历(与树的后序遍历)，和深度优先遍历（与树的前序遍历)。&lt;/p&gt;
&lt;p&gt;图在游戏中通常用作保存地图，网上流行的页游地图都是tilemap的，区块其实就是简化了指针之后的图，所以他们的理论是相通的。&lt;/p&gt;
&lt;p&gt;请看基于图的A*算法演示：&lt;/p&gt;
&lt;p&gt;因为我用了Adobe kuler配了一下色，所以漂亮了许多 ：）&lt;/p&gt;
&lt;embed src="/image/GraphTest.swf" type="application/x-shockwave-flash" width="700" height="700"&gt;&lt;/embed&gt;

&lt;blockquote&gt;
&lt;p&gt;QuadTree_collition&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么要用A*寻路而不是广度或深度遍历寻路呢？因为他们本身是很傻很执着的，由于不知道终点位置而盲目扫描整个图，这会浪费效能，而A星之所以叫做启发式寻路，是因为它事先预测了终点的大概方向而向那个方向扫描，这样增加了效率。&lt;/p&gt;
&lt;p&gt;我是照着这篇很有名的A Star入门教程写的代码：&lt;a href="http://www.vckbase.com/document/viewdoc/?id=1422" target="_blank"&gt;A*寻路初探&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为他是基于区块的，所以要改动一下，而需要改变的只有一个地方，他的文章里是循环检查 &lt;strong&gt;周围相邻的8格&lt;/strong&gt; ，而我们改成  &lt;strong&gt;连通的所有节点&lt;/strong&gt;  就ok了。&lt;/p&gt;
&lt;p&gt;我的Astar类已经按照教程逐句做了注释，对照教程应该很容易理解了。&lt;/p&gt;
&lt;p&gt;与教程不同的地方就是：&lt;/p&gt;
&lt;p&gt;1) 我使用了上边提到Heap优先队列来优化了open列表，使F值最小的始终在列表最上方，这个在教程后边也有讲。&lt;/p&gt;
&lt;p&gt;2）改用了 &lt;strong&gt;距离的启发值函数&lt;/strong&gt; 计算H值，而原教程使用的 &lt;em&gt;曼哈顿距离启发值函数&lt;/em&gt; 也有提供，可以替换，只是貌似没有距离的效果好,大家可以自己试一下。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-actionscript"&gt;
package examples.Astar
{
    import ds.Graph;
    import ds.GraphArc;
    import ds.GraphNode;
    import ds.Heap;
    public class Astar
    {
        /**
        *   距离启发函数
        */
        public static function distance(startNode:GraphNode,endNode:GraphNode):Number
        {
            return  Math.sqrt( (endNode.data.x - startNode.data.x)*(endNode.data.x - startNode.data.x) + (endNode.data.y - startNode.data.y)*(endNode.data.y - startNode.data.y))
        }
        /**
        *  曼哈顿启发函数
        */
        public static function manhattan(startNode:GraphNode,endNode:GraphNode):Number
        {
            return  Math.abs(endNode.data.x - startNode.data.x)+Math.abs(endNode.data.y - endNode.data.y);
        }

        /**
        *  寻路
        */
        public static function find(graph:Graph , startIndex:int,endIndex:int):Array
        {
            //还原值
            for each (var n:AstarNode in graph.nodes)
            {
                n.f = n.g = n.f = 0
                n.parent = null
            }

            //根据f值升序排列
            var open:Heap = new Heap(function(a:AstarNode,b:AstarNode):Number{return b.f - a.f});

            var close:Array = []
            //1，把起始节点添加到开启列表。
            AstarNode(graph.getNode(startIndex)).f = 0
            open.enqueue(graph.getNode(startIndex));
            //2，重复如下的工作：
            while(open.heap.length&amp;gt;0)
            {
                //a) 寻找开启列表中F值最低的节点。我们称它为当前节点。
                var cur:AstarNode = AstarNode(open.dequeue())
                if(cur==graph.getNode(endIndex))return  Astar.getPath(cur)
                //把目标格添加进了关闭列表，这时候路径被找到

                //b) 把它切换到关闭列表。
                close.push(cur)
                //c) 对相邻的格中的每一个？
                for each(var i:GraphArc in cur.arcs)
                {
                    var test:AstarNode = AstarNode(i.targetNode)
                    //如果它不可通过或者已经在关闭列表中，略过它。
                    if(close.indexOf(test)&amp;gt;=0)continue
                    //如果它不在开启列表中，把它添加进去。
                    //把当前格作为这一格的父节点。记录这一格的F,G,和H值。

                    if(open.heap.indexOf(test)&amp;lt;0)
                    {
                        test.parent =cur
                        test.g = cur.getArc(test).weight
                        test.h = Astar.distance(test,graph.getNode(endIndex))
                        // 这里使用距离启发值，原教程使用的曼哈顿启发函数
                                        //可以替换成这句  Astar.manhattan(test,graph.getNode(endIndex))
                        test.f = test.g + test.h
                        open.enqueue(test);
                    }else
                    {
                        //如果它已经在开启列表中，用G值为参考检查新的路径是否更好。
                                    //更低的G值意味着更好的路径。
                        //如果是这样，就把这一格的父节点改成当前格，并且重新计算这一格的G和F值。
                                    //如果你保持你的开启列表按F值排序,改变之后你可能需要重新对开启列表排序。
                        if( cur.g+ cur.getArc(test).weight &amp;lt; test.g)
                        {
                            test.parent = cur
                            test.g = cur.g+ cur.getArc(test).weight
                            test.f = test.h+test.g
                            open.modify(test,test);
                        }
                    }
                }
            }
            return []
        }

        public static function getPath(node:AstarNode):Array
        {
            var arr:Array = [node]
            while(node.parent)
            {
                arr.push(node.parent)
                node = node.parent
            }
            return arr
        }

    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是我目前了解到的对于flash开发还比较实用的数据结构了，欢迎补充，以供我继续学习。&lt;/p&gt;
&lt;p&gt;&lt;a href="/image/ds1_0.zip" target="_blank"&gt;最初代码在此下载 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nshen/as3DataStructure/tree/dev" target="_blank"&gt;后期修了一些bug，最新的代码点此直达github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的版本很多方法都是直接抄自&lt;a href="http://lab.polygonal.de/as3ds/" target="_blank"&gt;as3ds&lt;/a&gt; ，有些方法却改成比较容易理解的方式，提供的方法也少很多，仅供学习参考.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>读书《版本控制之道--使用Git》</title>
    <id>http://nshen.net/article/2011-08-03/git-note</id>
    <link href="http://nshen.net/article/2011-08-03/git-note"/>
    <updated>2011-08-03T13:30:20.000Z</updated>
    <content>&lt;p&gt;我认为每个学过Git的人都应该做过类似这种笔记，因为Git命令太多看着看着就把前边看过的忘了，之前我也看过Git，但是一直没用，现在一看几乎没有印象了，所以这次我要把我看到的命令记下来给我自己备忘。&lt;/p&gt;
&lt;p&gt;Git已经是最流行的版本控制系统了，网上相关的免费学习资源很多，我见过的中文书籍就有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://gitbook.liuhui998.com/index.html" target="_blank"&gt;Git Community Book 中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://progit.org/book/zh/" target="_blank"&gt;Pro Git 中文版 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank"&gt;Git Magic 中文版 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但我是买的一本纸质书叫做《版本控制之道--使用Git》，下边是我记录的几乎是整本书讲过的所有命令，后期又添加了点其他内容，方便以后查阅。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="-"&gt;设置&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git config --global --list # 查看所有设置
git config --global user.name &amp;quot;Nshen&amp;quot; # 必须
git config --global user.email &amp;quot;nshen121@gmail.com&amp;quot; # 必须
git config --global color.ui &amp;quot;always&amp;quot;
# 或者&amp;quot;auto&amp;quot;, always不仅Base环境是彩色，Dos里也是彩色的。
git config --global core.autocrlf input
# autocrlf 设置为 true 时会让 windows 下 push 代码时自动将 CRLF 转换为 LF ，并在 pull 代码时再转换回 CRLF
# 但如果你的编辑器已经支持 LF 了就不需要 pull 时再转回 CRLF 了，只要保证 push 时都是 LF 即可，所以要把 autocrlf 设置为 input

git config --global core.editor notepad.exe # 修改commit工具为windows记事本，不常用
git config --global alias.ci &amp;quot;commit&amp;quot; # 别名缩写，不常用
git config --global merge.tool # 可以设置合并工具，不常用

# 设置代理，只能http和https协议，git和ssh设置比较麻烦。
git config --global https.proxy 127.0.0.1:1080
git config --global https.proxy 127.0.0.1:1080
git config --global --unset http.proxy # 取消代理
git config --global --unset https.proxy # 取消https代理

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实最后这些设置都保存在&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;C:\Documents and Settings\用户名\.gitconfig 文件下（xp）
C:\Users\用户名\.gitconfig （win7）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;查看帮助：&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git help command
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;初始化&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;纳入版本控制&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git add *.txt   # 添加所有txt文件
git add README  # 添加单个文件
git add .        # 添加所有文件包括子目录，但不包括空目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add命令是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等,注意每次修改后都要重新add,不然就会提交之前add时的版本。&lt;/p&gt;
&lt;p&gt;下边这两个模式，不常见&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git add -i  # 进入交互式add
git add -p # 直接进入补丁模式，可以暂存修改的一部分。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;提交&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git commit -m &amp;quot;initial project version&amp;quot;
git commit -m &amp;quot;something&amp;quot; someFile  # 提交指定文件
git commit -C HEAD -a --amend  # 复用HEAD留言，增补提交（修改小错误，而不增加提交记录，掩盖自己的小马虎）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;参数的意思&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;-m &amp;quot;提交的说明&amp;quot;&lt;br&gt;-a 动把所有已经跟踪过的文件暂存,并提交.(工作目录中修改过的文件都提交到版本库，不需一个一个手动add了)&lt;br&gt;--amend 增补提交&lt;br&gt;-C 复用指定提交的提交留言&lt;br&gt;-c 打开编辑器在已有的提交基础上编辑修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;e.g 修改最后一次提交:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git commit -m &amp;#39;initial commit&amp;#39;
git add forgotten_file
git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有修改就相当于更改提交说明,上边3个命令得到一个提交.&lt;/p&gt;
&lt;h2 id="-"&gt;忽略提交的文件&lt;/h2&gt;
&lt;p&gt;所有人都需要忽略的文件要写在&lt;code&gt;.gitignore&lt;/code&gt;文件里，而只有自己的个人偏好需要忽略的文件要写在&lt;code&gt;.git/info/exclude&lt;/code&gt;文件中&lt;/p&gt;
&lt;h3 id="-"&gt;语法&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;# 此为注释 – 将被 Git 忽略
*.a       # 忽略所有 .a 结尾的文件
!lib.a    # 但 lib.a 除外
*.[oa]    #忽略以.o或.a结尾的文件
*~        #忽略以~结尾的文件
/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/    # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;查看文件改动：&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git diff   #  比较工作目录与缓存区的区别
git diff --cached 或者 git diff --staged  # 缓存区与版本库里的区别
git diff HEAD # 三者的区别
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，单单 git diff 不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。&lt;br&gt;所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git diff 18f822e        # 18f822e这个版本与当前目录的区别
git diff aaaaa..bbbbb  # 比较aaaaa与bbbbb之间差别
git diff --stat        # 可以统计数据，比较特别的命令

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;重命名，移动，删除文件：&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git mv file_from file_to  # 改名或移动
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ git mv README.txt README
$ git status
# On branch master
# Your branch is ahead of &amp;#39;origin/master&amp;#39; by 1 commit.
#
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       renamed:    README.txt -&amp;gt; README
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，运行 git mv 就相当于运行了下面三条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ mv README.txt README
$ git rm README.txt
$ git add README
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;必须调用 &lt;code&gt;git rm 文件名&lt;/code&gt;  ,从暂存区移除,并且文件也被删除&lt;/p&gt;
&lt;p&gt;如果只是手工删除了文件,运行git status时会出现&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;
# Changed but not updated:
#   (use &amp;quot;git add/rm &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#       deleted:    grit.gemspec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时必须再运行 &lt;code&gt;git rm 文件名&lt;/code&gt;，才会在提交时候不再纳入版本管理。&lt;/p&gt;
&lt;p&gt;如果删除之前修改过并且已经add到缓存区了的话,则必须强制删除 -f&lt;/p&gt;
&lt;p&gt;另外一种情况是，我们想把文件从Git仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆.a编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 --cached 选项即可。&lt;/p&gt;
&lt;h2 id="-"&gt;查看状态：&lt;/h2&gt;
&lt;h3 id="-git-status"&gt;查看当前状态 &lt;strong&gt;git status&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ git status
# On branch master
# Changes to be committed:  # 只要在这行后边的,说明放入暂存区了
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage) # 想取消放入缓存 git reset HEAD README
#
#     new file:   README
# Changed but not updated:  # 跟踪文件内容改变,但还没有放到暂存区,需要git add 命令才会放到暂存区
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
#    # 删除修改,恢复到之前版本,有危险 (如果想保留并且回退版本用stashing 和分支来处理)
#     modified:   benchmarks.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-git-log"&gt;查看提交历史 &lt;strong&gt;git log&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这时“j”向下浏览，“k”向上浏览，“q”退出&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git log --pretty=oneline    # 一行显示
        --pretty=&amp;quot;%h %s&amp;quot;   # 以各种格式输出

git log –p -2    # -p显示每次提交的内容差异  -2表示最近2次更改
git log --since &amp;quot;5 hours&amp;quot;
        --since &amp;quot;3 hours&amp;quot;
        --since &amp;quot;1 minute&amp;quot;
        --before =&amp;quot;2008-10.01&amp;quot;

git log 27j34j3j..03u43u23  # 最老版本..最新版本（不包括起点只包括终点）
git log 34j4j4..HEAD
git log fhfs8fh..           # 省略HEAD
git log &amp;quot;HEAD^^&amp;quot;..&amp;quot;HEAD^&amp;quot;     # windows必须加引号表示回溯上一个提交
git log -1 HEAD~1  # 相当于git log -1 HEAD^
git log --graph # 图形化显示分支
git log --graph --pretty=oneline # 一行图形化显示分支
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在windows下还可以&lt;code&gt;gitk&lt;/code&gt;打开图形界面查看&lt;/p&gt;
&lt;h3 id="-"&gt;问责：查明谁修改了代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git blame hello.html # 你也可以用&amp;quot;-L&amp;quot;参数在命令(blame)中指定开始和结束行:
git blame -L 12,+10 hello.html  # 12到22行
blame还可以跟踪内容复制，文件复制，略，见版本控制之道 79页
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;撤销：&lt;/h2&gt;
&lt;h3 id="-commit-"&gt;撤销缓存区的修改（没有commit的）&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git checkout head 文件名 # 撤销暂存区的修改
git checkout head readme.txt todo.txt
git checkout head *.txt
git checkout head .  # 撤销所有
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-commit-"&gt;复位：还没有commit，让工作目录回到上次提交时的状态&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git reset --hard HEAD   # 所有未提交的内容清空，这会让&amp;quot;git diff&amp;quot; 和&amp;quot;git diff --cached&amp;quot;命令的显示法都变为空
git reset --soft HEAD  # 复位版本库，暂存差异，便于提交中发现错误需要更改时有用（例如私人密码放到里边了）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;反转提交：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git revert HEAD  # 创建一个反向的新提交抵消原来的提交改动
# 如果需要反转多个，必须从最后的开始反转, 加 -n可以不马上提交，之后一起提交。
git revert -n HEAD
git revert -n 54efhds
git commit -m &amp;quot;revert head and 54efhds&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;分支：&lt;/h2&gt;
&lt;h3 id="-"&gt;在当前分支末梢建立分支：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git branch RB_1.0 #（建立分支不会自动切换过去）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;切换分支：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git checkout #RB_1.0（切换到RB_1.0分支）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;创建并切换分支：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git checkout -b RB_1.0  #（简化上边2步操作）

git checkout -b dev origin/dev # 创建分支并且跟踪远程分支
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;删除分支：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git branch -d RB_1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-"&gt;基于某次提交、分支或标签创建新分支:&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git branch RB_1.0 master
git branch RB_1.0 6fe57de0
git branch Rb_1.01 1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;查看分支：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git branch # 列出本地分支
    iss53
* master  # *号表示当前所在分支
    testing


git branch -r # 显示远程分支
git branch -a # 列出所有分支
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;分支重命名：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git branch -m master mymaster    
            -M 大写M会覆盖同名的分支
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;合并分支：&lt;/h3&gt;
&lt;h4 id="-"&gt;直接合并：&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git merge --no-ff somebranch # 最推荐的合并分支方式，会生成一个新的commit，不会丢掉分支信息
git merge 想合并到当前分支的源分支名
git merge --no-commit 分支 # 合并但不提交
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-"&gt;压合合并&lt;/h4&gt;
&lt;p&gt;将分支压合成一条commit记录，并合并过来&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git merge --squash 某bug分支
git commit -m &amp;quot;修复某bug&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="-"&gt;拣选合并&lt;/h4&gt;
&lt;p&gt;只合并一个提交&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git cherry-pick 321d76f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要连续拣选，就需要加&lt;code&gt;-n&lt;/code&gt;参数&lt;br&gt;然后再git commit ，但不要加&lt;code&gt;-m&lt;/code&gt;参数，编辑器就会使用刚拣选的提交留言作为现在的留言。&lt;/p&gt;
&lt;h2 id="-tag"&gt;标签Tag&lt;/h2&gt;
&lt;h3 id="-"&gt;查看标签&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git tag
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;创建标签：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git tag 1.0  # 在当前分支最后一次提交创建标签
git tag 1.0 RB_1.0 # 基于RB_1.0分支的最新踢脚创建标签
git tag 1.0 ae468d8kt # 为某次提交创建标签
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;检出标签：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git checkout 1.0 
# 检出标签与检出分支一样操作，但检出标签后用git branch查看本地分支会发现你现在不再任何分支上 
# 这时你不应该修改，而应该立即基于此标签创建一个分支
git checkout -b from-1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;变基：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;git rebase RB_1.01 # 也许修改过一个bug，希望新版本变基到RB_1.01分支上&lt;/li&gt;
&lt;li&gt;手动解决冲突         # 如果解决不了直接git rebase --skip或--abort来跳过特定提交或完全放弃变基&lt;/li&gt;
&lt;li&gt;git add xxx.html # 冲突解决&lt;/li&gt;
&lt;li&gt;git rebase --continue&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git rebase --onto HEAD^^ HEAD^ HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;--onto参数可以改写历史抹掉中间的参数，将倒数第一个参数变基到倒数第3个参数，为防止出错建议在试验性分支上先试验。&lt;/p&gt;
&lt;p&gt;rebase -i 可以排序历史记录，多个提交合并为1个，一个提交分解成多个提交 ，&lt;br&gt;详见版本控制之道p86 ，需要编辑器支持，windows记事本不行&lt;/p&gt;
&lt;h2 id="-"&gt;远程相关&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git clone git://github.com/schacon/grit.git   # 从现有仓库克隆
git clone git://github.com/schacon/grit.git mygrit # 换名,唯一区别就是新建的目录成了mygrit,其他都一样
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;添加远程仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git remote add pb git://github.com/paulboone/ticgit.git
# clone会默认添加origin仓库，如果原本用git init创建的版本库，后来又想提交到远程版本库，就可以用下边的办法
git remote add origin git@example.com:/xxxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;查看远程分支：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git remote  -v # 查看远程仓库,默认clone后,应该有一个origin仓库,-v显示对应的clone地址
git remote show origin # 查看远程仓库信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;远程仓库重命名和删除:&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git remote rename pb paul
git remote rm paul
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;远程仓库重命名&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git remote set-url origin 新地址
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="-"&gt;获取数据：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git fetch [remote-name] 拉取远程仓库到本地远程仓库,不自动合并    # $ git fetch origin
$ git fetch pb
remote: Counting objects: 58, done.
remote: Compressing objects: 100% (41/41), done.
remote: Total 44 (delta 24), reused 1 (delta 0)
Unpacking objects: 100% (44/44), done.
From git://github.com/paulboone/ticgit
* [new branch]      master     -&amp;gt; pb/master
* [new branch]      ticgit     -&amp;gt; pb/ticgit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在pb/master可以在本地访问了,你可以合并到自己的某个分支,或者切换到这个分支看看有什么有趣的更新&lt;/p&gt;
&lt;p&gt;git pull 抓取数据合并到工作目录中当前分支&lt;/p&gt;
&lt;p&gt;如果提示tracking information什么不对,可以这样指定本地examples分支跟随远端examples分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch --set-upstream-to=origin/examples examples
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="-"&gt;推送数据：&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git push [remote-name] [branch-name]  # 默认为 git push origin master
git push origin serverfix   # 推送分支，其实是下边一句的简化,提取我的 serverfix 并更新到远程仓库的 serverfix
git push origin serverfix:serferfix
git push origin :serverfix # 这个语法用于删除,只要把分号前留空
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;其他：&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git gc  # 垃圾回收，每隔一段时间例如一个月运行一次可以减少磁盘占用空间。
git reflog # 最后的保障,列出误删的东东
git bisect # 二分查找，版本控制之道p124页，略
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="-"&gt;归档版本库，导出压缩包:&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git archive --format=格式 --prefix=目录/ 版本&amp;gt;压缩包.zip
git archive --format=zip head&amp;gt;test.zip
git archive --format=tar --prefix=mysite-1.0/ 1.0 | gzip&amp;gt;mysite-1.0.tar.gz
git archive --format=zip --prefix=mysite-1.0/ 1.0 &amp;gt;mysie-1.0.zip
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>基于AIR的跨平台小游戏《TinyKingdom》</title>
    <id>http://nshen.net/project/2011-07-05/tiny-kingdom</id>
    <link href="http://nshen.net/project/2011-07-05/tiny-kingdom"/>
    <updated>2011-07-05T14:56:31.000Z</updated>
    <content>&lt;p&gt;目前在iphone4和Android的g7上运行效果差不多，具体见视频。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;对游戏机制设计不是很满意，做了10多关，现暂停开发中。&lt;/p&gt;
&lt;h3 id="2011-07-05-g7-"&gt;2011-07-05在G7上测试视频：&lt;/h3&gt;
&lt;embed src="http://www.tudou.com/v/WYv-ljAL1xs/&amp;rpid=9086081/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="480" height="400"&gt;&lt;/embed&gt;


&lt;hr&gt;
&lt;p&gt;烂尾了，代码： &lt;a href="https://github.com/nshen/TinyKindom"&gt;https://github.com/nshen/TinyKindom&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
</feed>