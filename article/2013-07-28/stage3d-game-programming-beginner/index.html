<!doctype html>
<html>

<head>
    <title> 读书《Stage3D Game Programming Beginner》 | N神的研究所</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Stage3D 学习笔记">
    
    <meta name="keywords" content="Flash,读书">
    <meta name="author" content="Nshen <nshen121@gmail.com>">

    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="bookmark" href="/favicon.ico" />

    <link rel="stylesheet" href="/assets/css/normalize.css">  
    <link rel="stylesheet" href="/assets/css/github.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
    <link rel="stylesheet" href="/assets/css/site.css">
    <link rel="stylesheet" href="/assets/css/share.min.css">
</head>

<body>
  <div id="container">
    <header>
        <div id="header_inner" class="center">
            <div id="main_logo">
                <a id="logo" href="/">N神的研究所</a>
            </div>
            <nav id="main_nav">
                <a id="main_nav_link" href="/articles">学习（输入）</a>
                <a id="main_nav_link" href="/projects">实践（输出）</a>
                <a id="main_nav_link" href="/about">关于</a>
                <a id="main_nav_link" href="/links">友情链接</a>
            </nav>
        </div>
    </header>        <main >
          <div class="contents" >
            <div class="article_title">
              <h1>读书《Stage3D Game Programming Beginner》</h1>
            </div>
 
            <div class="article_date">
              <p>发表于 2013年7月28日 </p>
            </div>
     
            <div class="markdown-body markdown-contents">
              <p>这篇笔记一年半前读书时发到豆瓣上了，去豆瓣搜过书的应该都看见过，这是我入门3d看的第一本书，现在把原文复制过来简单排版和整理了一下。</p>
<!-- more -->
<h3 id="-let-s-make-a-game-using-molehill">第一章，Let&#39;s Make a Game Using Molehill</h3>
<hr>
<p>介绍什么是molehil。。略 。此书面针对了解AS3，但不太了解3d的读者。</p>
<h3 id="3d-">3d术语：</h3>
<ul>
<li><p>Mesh：3d游戏中的模型就叫一个mesh。模型一般用3d studiomax 等软件做的，一个场景可以有几百个mesh组成。</p>
</li>
<li><p>Polygon：mesh可以由成百上千的多边形组成，多边形可以是三角形，也可以是四边形，一个3d立方体由6个面片组成，每个面片叫做一个poly。</p>
</li>
<li><p>Vertex：每个poly有3个或以上角，每个角的顶点就是一个vertex。</p>
</li>
<li><p>Texture：想象成墙纸，可以是一个jpg或png的图片。</p>
</li>
<li><p>Shaders：shader是视觉风格的定义，它定义怎样渲染某物，在stage3d中，shaders存在Program3D类中。创建一个shader，需要创建一个vertex program，和一个fragment program 。</p>
</li>
<li><p>Fragment program：在molehill中是处理mesh视觉渲染的一系列命令。也叫像素着色器。fragment programs描述一个给定的表面材质和对光照的反应，不同的材质对光照有不同的反应方式取决于反射和透明度等，需要不同的代码来模拟。每个模型都需要一个fragment program，否则就不会渲染出来，它可以是一个简单的texture，也可以是复杂的2个texture混合外加灯光反射。</p>
</li>
<li><p>Vertex program：molehill常用 vertex program计算mesh的形状，影响每个vertex在3d世界中的位置。这样可以把mesh缩放，扭曲，做变形动画。也可以分配任意数量的数据到mesh中的每个vertex，不只是xyz坐标，可以是rgb颜色uv等。每个模型的渲染都需要个vertex program，可以是简单的在原始位置渲染或复杂到让mesh做变形动画。</p>
</li>
<li><p>Vectors：Vector3D描述空间中的位置，在geom包里</p>
</li>
</ul>
<pre><code>import flash.geom.Vector3D;
var putTheTreeHere:Vector3D = new Vector3D(0,0,0);
var locationOfTreasure:Vector3D = new Vector3D(1000,0,-15000);
</code></pre><ul>
<li><p>Normals：仅用来指明方向，length等于1的单位向量，可以简单的用Vector3D类的normalize()方法获得。</p>
<p>  var aNormalPointingUp:Vector3D = new Vector3D(0,1,0);</p>
</li>
<li><p>Matrices：是向量的集合，Matrix3D是4×4的矩阵，用来方便的移动，旋转，缩放对象。</p>
</li>
</ul>
<p>第一章结束，总结</p>
<ul>
<li>Vector3D: containing an x, y, and z component</li>
<li>Normal: a Vector3D that has a length of one</li>
<li>Matrix: a 4x4 group of vectors with position, rotation,and scale</li>
<li>Vertex: a point in space that is the corner of a polygon</li>
<li>Polygon: a shape defined by multiple vertex coordinates</li>
<li>Mesh: a group of polygons (polies) that make up a model</li>
<li>Texture: a bitmap image that is like a wallpaper for a mesh</li>
<li>Vertex program: commands affecting the shape of a mesh</li>
<li>Fragment program: commands affecting the look of a mesh</li>
</ul>
<h3 id="-2-blueprint-of-a-molehill">第2章，Blueprint of a Molehill</h3>
<hr>
<p>原来为什么慢，因为之前DisplayList全部CPU，molehill为什么快，因为molehill是完全GPU加速的。</p>
<blockquote>
<p>Molehill will rely on DirectX 9 on Windows machines and OpenGL 1.3 on both Mac OS-X and Linux. On mobile devices such as tablets, televisions, and phones, Molehill will rely upon OpenGL ES2.</p>
</blockquote>
<p>DisplayList在stage3d之上，可以组合stage3d和原始的flash显示列表一起做东东.</p>
<h3 id="molehill-">Molehill程序结构</h3>
<p>stage3d已不在显示列表里，不能addchild了.</p>
<p><img src="/image/molehill_book01.jpg" alt=""></p>
<ul>
<li>Context3D：可以想象成&quot;引擎&quot;，所有3d数据都要传给他。</li>
</ul>
<blockquote>
<p>This Context3D is the object that you send all your textures, vertex buffers, and<br>vertex/fragment programs to. The Context3D is the base class that holds all of your game<br>data and does all the work.</p>
</blockquote>
<ul>
<li><p>VertexBuffer3D：VertexBuffer3D是一个numbers的数组，用来保存第一章提到的vertex坐标，但不限于顶点坐标，还可以保存rgb，uv等值。初始化游戏的时候要把这个vertexBuffer3D传给Contex3D，之后Contex3D会把这些数据直接传给显卡的RAM或VRAM，渲染时会用。</p>
</li>
<li><p>IndexBuffer3D：由于顶点数据是一大坨VertexBuffer3D，Molehill需要知道每组数据的起始和结束，所以有了index buffer做索引，如下图，表示3个顶点，每个有6个元素 。</p>
</li>
</ul>
<p><img src="/image/molehill_book02.jpg" alt=""></p>
<ul>
<li>Program3D：Vertex programs和 fragment programs也叫shaders 与前边的buffer同样传给contex3d，他是从一种类似汇编语言编译成的，他们告诉gpu怎样根据上边提供的buffer画mesh。</li>
</ul>
<h3 id="-stage3d-">一个stage3d程序的流程图</h3>
<p>分2部分，setup 和 render loop</p>
<p><strong>setup</strong>：<br>所有buffers和programs被编译并发送到显卡。这只做1次。一旦setup，molehill可以在不同位置重复画meshes而不需要其他初始化。</p>
<p>setup详细过程：</p>
<ol>
<li>Request a Context3D instance from Stage3D</li>
<li>Set up the Context3D (telling it how big it is, and so on)</li>
<li>Create a VertexBuffer (one for each mesh you intend to use)</li>
<li>Create an IndexBuffer (each will correspond to a VertexBuffer)</li>
<li>Upload this data to the Context3D (send it to your GPU)</li>
<li>&quot;Compile&quot; a VertexProgram (turn your shader source code into bytes)</li>
<li>&quot;Compile&quot; a FragmentProgram (turn your shader source code into bytes)</li>
<li>Create a Program3D which will use the preceding shaders (can be used by more than one mesh)</li>
</ol>
<p>这8步一般只需要一次，偶尔由于3d环境丢失的关系需要重新来一次，例如因为计算机睡眠等原因。</p>
<p><strong>render loop</strong>：一般是监听ENTER_FRAME事件重复执行的</p>
<ol>
<li>Clear the Context3D (erase the old view)</li>
<li>Tell the Context3D which Program3D to use (for example, a shader that looks<br>like steel)</li>
<li>Tell the Context3D which VertexBuffer to use (for example, a spaceship)</li>
<li>Setup data for you your shaders (variables, such as the new location of a spaceship)</li>
<li>Draw some triangles (tell the Context3D to do some drawing)</li>
<li>Update the screen with your drawn triangles (show the user the new scene)</li>
</ol>
<p>总结：这章讲了什么？</p>
<ul>
<li>The old fashioned way: 2D Flash using DisplayObjects</li>
<li>The Molehill way: Stage3Ds containing Context3Ds</li>
<li>Why Molehill is so fast: Hardware 3D, baby</li>
<li>Combining 2D and 3D: You can use old and new Flash objects together</li>
<li>Flowchart of a Molehill game: Setup first, then a render loop</li>
</ul>
<h3 id="-3-fire-up-the-engines">第3章，Fire up the Engines</h3>
<hr>
<p>这章是前边两章内容的一个实例，直接看代码就行了，书里好像也么讲什么新内容，代码倒是注释的很详细<br>除了shader代码要后边章节详细讲，其他的配合帮助文档应该都看懂了。</p>
<p>详见 <a href="/image/Ch3_Stage3dGame.as" target="_blank">Stage3dGame.as</a>类</p>
<p>本章总结：</p>
<blockquote>
<p>we learned how to obtain Flash 11 for our browser, we got all the tools ready<br>to compile Stage3D games, we learned how to initialize the Stage3D API, how to upload<br>mesh and texture data to the video card, and how to animate a simple 3D scene</p>
</blockquote>
<h3 id="-4-basic-shaders">第4章，Basic Shaders</h3>
<hr>
<p>AGAL: Adobe Graphics Assembly Language</p>
<p>前边讲过shaders就是vertex program （vertex shaders）和 fragment program（pixel shaders）。<br>由于他们在gpu中执行，所以很快，每帧可以数百万次，flash的一帧中，mesh中每个顶点都要执行一次vertex program！ fragment shade更厉害，每个像素都执行一次！。</p>
<p>agal语句是什么样的</p>
<pre><code>&lt;opcode&gt; &lt;destination&gt; &lt;source 1&gt; &lt;source 2&gt;
</code></pre><p>agal只有30个opcodes，完整列表在Stage3D的文档里找.<br>例如  mov v0, va1  把va1的值copy到v0.</p>
<p>常见agal opcode:</p>
<pre><code>mov (copies data from source1 to destination)
add (destination = source1 plus source2)
sub (destination = source1 minus source2)
mul (destination = source1 multiplied by source2)
div (destination = source1 divided by source2)
</code></pre><p><strong>什么是寄存器 （register）</strong></p>
<p>上边提到的&quot;source&quot; 和 &quot;destinations&quot;叫寄存器，你可以把它们当成变量，存储数据的地方。他们代表显存中的一小块，为速度而优化过的。寄存器都是包含4个128位的浮点数 ，用as3的话说就是4个Number。</p>
<p><strong>寄存器的组成部分</strong>：</p>
<p>4个值中的每一个都是一个组成部分，可以通过xyzw或者rgba访问<br>va1.x和va1.r一样都是寄存器的第一个组成部分。<br>一般在vertex里用xyzw，fragment里用rgba。<br>opcode一般四个组件同时运算，例如以add opcode为例 source1是一个 Vector3D  (10,100,50,0) 然后source2 是 (5,1,3,0),结果会是(15,101,53,0).</p>
<p><strong>不同的寄存器有不同的功用</strong>：</p>
<p><img src="/image/molehill_book03.jpg" alt=""></p>
<ul>
<li><p>顶点属性寄存器 Vertex Attribute Registers：va0...va7<br>有8个va寄存器，分别是va0, va1, va2, va3, va4, va5, va6 , va7<br>只在vertex shader里可用，用来指定VertexBuffer中的位置。可以包含x,y,z,或uv坐标，rgb值等。<br>用 Context3D:setVertexBufferAt() 来把VertexBuffer分段分配给属性寄存器。然后在shader里用语法 va<n>访问，n就是属性索引。<br>记住一共有8个寄存器，每个保存4个浮点数，所以每个顶点可以保存32个数字。</p>
</li>
<li><p>常量寄存器 Constant registers: vc0..vc127 and fc0..fc27<br>as中通过Context3D::setProgramConstants()系列函数来设置<br>在vertex shader中用vc<n>访问，pixel shader中fc<n>访问<br>vertex shaders里一共有128个常量寄存器，pixel shaders里有28个常量寄存器。</p>
</li>
<li><p>临时寄存器 Temporary registers: vt0..vt7 and ft0..ft7<br>这些寄存器是用来在shader里临时计算用的，可以当成临时变量。 这样访问：<br>vt<n> (vertex programs) ， ft<n> (fragment programs)<br>vertex 和pixel shaders各8个临时寄存器。</p>
</li>
<li><p>输出寄存器 Output registers: op在vertex shader里用来输出位置，oc在pixel shader里用来输出颜色。 vertex shader的输出就是顶点的clip space 位置，pixel shader输出的就是就是像素颜色。</p>
</li>
<li><p>Varying registers: v0..v7  呃这个不知道中文名了<br>这些寄存器是用来从vertex shaders向pixel shaders传递数据的。，典型应用是从vertex shader传递顶点颜色或纹理的uv坐标到pixel shader。一共有8个，用v<n>访问。</p>
</li>
<li><p>纹理采样寄存器Texture samplers: fs0..fs7<br>这8个纹理采样寄存器，只可以用在fragment program里，是用来基于uv坐标从textures里提取颜色的。这个寄存器比较特殊，有它独有的规则<br>，采样的纹理，需要提前在as中用Context3D::setTextureAt()指定.</p>
</li>
</ul>
<p>shader里语法是这样</p>
<pre><code>fs&lt;n&gt; &lt;flags&gt;
</code></pre><p>flags是逗号分隔的字符串，类似这样 </p>
<pre><code>tex ft1, v0, fs0 &lt;2d,linear,nomip&gt;
</code></pre><p>关于参数的解释：</p>
<ol>
<li><p>texture dimension: 2d, 3d, or cube. A 2D texture is the most commonly used format, a rectangular bitmap. A 3D texture has length, width, and depth, and takes up a lot of texture RAM but is great for 3D materials such as wood, grain, or marble. It is rarely used. A cube texture is a specially encoded group of six rectangular bitmaps and is usually used for reflections, as each of these six images maps to a particular direction like the sides on the inside of a box.</p>
</li>
<li><p>mip mapping: nomip, mipnone, mipnearest, or miplinear. If your texture has mip maps (successively smaller versions of itself, generated to avoid jaggies during rendering), then you can instruct Stage3D to smoothly interpolate the texture using them. Mip mapped textures are very useful to increase render quality and avoid the &quot;moiree effect&quot; (flickering) when viewed from far away.</p>
</li>
<li><p>texture filtering: nearest or linear. If you prefer a retro, then pixilated look you can use nearest here to tell Stage3D not to interpolate the values smoothly, resulting in blocky textures when viewed up close, for example. If you use linear, when zoomed into a texture it will be blurry and will have smoother edges.</p>
</li>
<li><p>texture repeat: repeat, wrap, or clamp. If you want the texture tile properly, then you use repeathere. If you are not tiling the texture and run into problems with edge pixels being the color of the opposite edge (which often happens in transparent billboard particles and when rendering bitmap fonts in 3d), then specify clampto force Stage3D not to blur adjacent edge pixels.</p>
</li>
</ol>
<h3 id="-">下面开始实例</h3>
<pre><code>// the simplest possible vertex program
m44 op, va0, vc0 // pos to clipspace
mov v0, va1 // copy uv
</code></pre><p>m44是4×4矩阵相乘，顶点坐标存储在 va0 ，乘以mesh相对于camera的位置矩阵vc0<br>第二行copy va1到v0.<br>关于vc0后边章节会讲，现在知道他MVP矩阵，这个这本书里没有仔细讲，要看点其他数学书了：（</p>
<p>最简单的fragment program</p>
<pre><code>// a simple fragment program
tex ft1, v0, fs0 &lt;2d,linear,nomip&gt;
mov oc, ft1
</code></pre><p>从fs0取样到ft1，v0是来自顶点shader的uv坐标<br>把 ft1输出.</p>
<p>编译 AGAL 代码</p>
<pre><code>var vertexShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
vertexShaderAssembler.assemble(
Context3DProgramType.VERTEX,
&quot;m44 op, va0, vc0\n&quot; +
&quot;mov v0, va1&quot;
);
var fragmentShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
fragmentShaderAssembler.assemble(
Context3DProgramType.FRAGMENT,
&quot;tex ft1, v0, fs0 &lt;2d,linear, nomip&gt;;\n&quot; +
&quot;mov oc, ft1&quot;
);
var program:Program3D = context3D.createProgram();
program.upload(
vertexShaderAssembler.agalcode,
fragmentShaderAssembler.agalcode
);
</code></pre><p>渲染！</p>
<ol>
<li>Clear the Context3D, erasing the previous frame</li>
<li>Select which vertex buffers to use</li>
<li>Select which texture to use</li>
<li>Set the current shader program</li>
<li>Apply a matrix for use in your shaders to calculate the location</li>
<li>Render the mesh</li>
<li>Repeat steps 2 through 6 for every mesh</li>
<li>Present the final image to the user</li>
</ol>
<p>实际代码来了：</p>
<pre><code>// clear your viewport to the background color:
context3D.clear ( 1, 1, 1, 1 );
// vertex position to attribute register 0 (va0)
context3D.setVertexBufferAt (0, vertexbuffer, 0,
Context3DVertexBufferFormat.FLOAT_3);
// uv coordinates to attribute register 1 (va1)
context3D.setVertexBufferAt(1, vertexbuffer, 3,
Context3DVertexBufferFormat.FLOAT_2);
// assign texture to texture sampler 0 (fs0)
context3D.setTextureAt( 0, texture );
// assign shader program
context3D.setProgram( program );
// Note how the two vertex buffer streams,
// vertex positions and uv coordinates,
// get assigned to two different attribute registers.
// The texture is assigned to a specific texture sampler.
// Pass on your transform matrix to the shader.
var m:Matrix3D = new Matrix3D();
m.appendRotation(getTimer()/50, Vector3D.Z_AXIS);
context3D.setProgramConstantsFromMatrix(
Context3DProgramType.VERTEX, 0, m, true);
// The matrix gets stored into constant register 0 here,
// for the Vertex Shader to use.
// To render, call drawTriangles passing in the index buffer.
context3D.drawTriangles(indexBuffer);
// You may do additional drawTriangle calls in the frame
// one for each mesh you want rendered.
// You can use the same or different programs for each meshes.
// Once all meshes have been drawn, display them on screen:
context3D.present();
</code></pre><p>后边全在分块的讲代码，有点晕，都不知道讲到哪了，其实直接看完整的代码就可以了，注释非常全。要费点精力了，我先略了。</p>
<p>详见 <a href="/image/ch4_Stage3dGame.as" target="_blank">Stage3dGame.as</a>类</p>
<h3 id="-5-making-stuff-happen-">第5章，Making Stuff Happen!</h3>
<hr>
<p>面片真是太面了，这章要显示真正的模型了。</p>
<p>.OBJ是模型文件，主流3d软件都应该可以导出这种格式。<br>还有贴图可以photoshop做，具体怎么做的看不懂，等看完了这本书小弟就准备学习学习3d软件了。<br>.obj文件格式类似这样</p>
<pre><code>v -0.257 0.191 0.423
vt 0.623 0.227
f 1/1 2/2 3/3
</code></pre><p>第一行是顶点坐标，第2行是uv坐标，第3行是面的定义，用来产生index buffer，复杂的obj文件会有成百上千行。<br>理论就在这些。</p>
<p>下边开始主要讲解析obj文件<a href="/image/Stage3dObjParser.as" target="_blank">Stage3dObjParser.as</a>类</p>
<p>第一步readClass把embed进来的obj文件转成字符串</p>
<pre><code>private function readClass(f:Class):String
{
    var bytes:ByteArray = new f();
    return bytes.readUTFBytes(bytes.bytesAvailable);
}
</code></pre><p>然后每行解析</p>
<pre><code>// Split data in to lines and parse all lines.
var lines:Array = definition.split(LINE_FEED);
var loop:uint = lines.length;
for(var i:uint = 0; i &lt; loop; ++i)
    parseLine(lines[i]);
</code></pre><p>然后根据firstWord分别解析不同数据</p>
<pre><code>private function parseLine(line:String):void
{
        // Split line into words.
        var words:Array = line.split(SPACE);

        // Prepare the data of the line.
        if (words.length &gt; 0)
            var data:Array = words.slice(1);
        else
            return;

        // Check first word and delegate remainder to proper parser.
        var firstWord:String = words[0];
        switch (firstWord)
        {
            case VERTEX:
                parseVertex(data);
                break;
            case NORMAL:
                parseNormal(data);
                break;
            case UV:
                parseUV(data);
                break;
            case INDEX_DATA:
                parseIndex(data);
                break;
        }
}
</code></pre><p>难点在解析index，这里就略了。</p>
<p>如果软件可以不导出normal，则可以大大减小文件体积，可以用下边函数计算出normal</p>
<pre><code>public function restoreNormals():void
{    // utility function
    _rawNormalsBuffer = _cachedRawNormalsBuffer.concat();
}

public function get3PointNormal(
    p0:Vector3D, p1:Vector3D, p2:Vector3D):Vector3D
{    // utility function
    // calculate the normal from three vectors
    var p0p1:Vector3D = p1.subtract(p0);
    var p0p2:Vector3D = p2.subtract(p0);
    var normal:Vector3D = p0p1.crossProduct(p0p2);
    normal.normalize();
    return normal;
}

public function forceNormals():void
{    // utility function
    // useful for when the OBJ file doesn&#39;t have normal data
    // we can calculate it manually by calling this function
    _cachedRawNormalsBuffer = _rawNormalsBuffer.concat();
    var i:uint, index:uint;
    // Translate vertices to vector3d array.
    var loop:uint = _rawPositionsBuffer.length/3;
    var vertices:Vector.&lt;Vector3D&gt; = new Vector.&lt;Vector3D&gt;();
    var vertex:Vector3D;
    for(i = 0; i &lt; loop; ++i)
    {
        index = 3*i;
        vertex = new Vector3D(_rawPositionsBuffer[index],
            _rawPositionsBuffer[index + 1], 
            _rawPositionsBuffer[index + 2]);
        vertices.push(vertex);
    }
    // Calculate normals.
    loop = vertices.length;
    var p0:Vector3D, p1:Vector3D, p2:Vector3D, normal:Vector3D;
    _rawNormalsBuffer = new Vector.&lt;Number&gt;();
    for(i = 0; i &lt; loop; i += 3)
    {
        p0 = vertices[i];
        p1 = vertices[i + 1];
        p2 = vertices[i + 2];
        normal = get3PointNormal(p0, p1, p2);
        _rawNormalsBuffer.push(normal.x, normal.y, normal.z);
        _rawNormalsBuffer.push(normal.x, normal.y, normal.z);
        _rawNormalsBuffer.push(normal.x, normal.y, normal.z);
    }
}
</code></pre><p>至此.OBJ解析部分完成了。</p>
<p>上传Mipmaps代码</p>
<pre><code>public function uploadTextureWithMipmaps(dest:Texture, src:BitmapData):void
{
     var ws:int = src.width;
     var hs:int = src.height;
     var level:int = 0;
     var tmp:BitmapData;
     var transform:Matrix = new Matrix();
     var tmp2:BitmapData;
     tmp = new BitmapData( src.width, src.height, true, 0x00000000);
     while ( ws &gt;= 1 &amp;&amp; hs &gt;= 1 )
     {                                
          tmp.draw(src, transform, null, null, null, true);    
          dest.uploadFromBitmapData(tmp, level);
          transform.scale(0.5, 0.5);
          level++;
          ws &gt;&gt;= 1;
          hs &gt;&gt;= 1;
          if (hs &amp;&amp; ws) 
          {
               tmp.dispose();
               tmp = new BitmapData(ws, hs, true, 0x00000000);
          }
     }
     tmp.dispose();
}
</code></pre><p>巨型实例，结束本章</p>
<pre><code>package
{
import com.adobe.utils.*;
import flash.display.*;
import flash.display3D.*;
import flash.display3D.textures.*;
import flash.events.*;
import flash.geom.*;
import flash.utils.*;
import flash.text.*;
[SWF(width=&quot;640&quot;, height=&quot;480&quot;, frameRate=&quot;60&quot;, backgroundColor=&quot;#FFFFFF&quot;)]    
public class Stage3dGame extends Sprite
{
// used by the GUI
private var fpsLast:uint = getTimer();
private var fpsTicks:uint = 0;
private var fpsTf:TextField;
private var scoreTf:TextField;
private var score:uint = 0;
// constants used during inits
private const swfWidth:int = 640;
private const swfHeight:int = 480;
// for this demo, ensure ALL textures are 512x512
private const textureSize:int = 512;
// the 3d graphics window on the stage
private var context3D:Context3D;
// the compiled shaders used to render our mesh
private var shaderProgram1:Program3D;
private var shaderProgram2:Program3D;
private var shaderProgram3:Program3D;
private var shaderProgram4:Program3D;
// matrices that affect the mesh location and camera angles
private var projectionmatrix:PerspectiveMatrix3D = new PerspectiveMatrix3D();
private var modelmatrix:Matrix3D = new Matrix3D();
private var viewmatrix:Matrix3D = new Matrix3D();
private var terrainviewmatrix:Matrix3D = new Matrix3D();
private var modelViewProjection:Matrix3D = new Matrix3D();
// a simple frame counter used for animation
private var t:Number = 0;
// a reusable loop counter
private var looptemp:int = 0;
/* TEXTURES: Pure AS3 and Flex version:
 * if you are using Adobe Flash CS5 
 * comment out the following: */
[Embed (source = &quot;art/spaceship_texture.jpg&quot;)] 
private var myTextureBitmap:Class;
private var myTextureData:Bitmap = new myTextureBitmap();
[Embed (source = &quot;art/terrain_texture.jpg&quot;)] 
private var terrainTextureBitmap:Class;
private var terrainTextureData:Bitmap = new terrainTextureBitmap();
/* TEXTURE: Flash CS5 version:
 * add the jpgs to your library (F11)
 * right click and edit the advanced properties
 * so it is exported for use in Actionscript 
 * and call them myTextureBitmap and terrainTextureBitmap
 * if you are using Flex/FlashBuilder/FlashDevelop/FDT
 * comment out the following: */
//private var myBitmapDataObject:myTextureBitmapData = 
//    new myTextureBitmapData(textureSize, textureSize);
//private var myTextureData:Bitmap = 
//    new Bitmap(myBitmapDataObject);
//private var terrainBitmapDataObject:terrainTextureBitmapData = 
//    new terrainTextureBitmapData(textureSize, textureSize);
//private var terrainTextureData:Bitmap = 
//    new Bitmap(terrainBitmapDataObject);
// The Stage3d Texture that uses the above myTextureData
private var myTexture:Texture;
private var terrainTexture:Texture;
// The spaceship mesh data
[Embed (source = &quot;art/spaceship.obj&quot;, mimeType = &quot;application/octet-stream&quot;)] 
private var myObjData:Class;
private var myMesh:Stage3dObjParser;
// The terrain mesh data
[Embed (source = &quot;art/terrain.obj&quot;, mimeType = &quot;application/octet-stream&quot;)] 
private var terrainObjData:Class;
private var terrainMesh:Stage3dObjParser;
public function Stage3dGame() 
{
    if (stage != null) 
        init();
    else 
        addEventListener(Event.ADDED_TO_STAGE, init);
}
private function init(e:Event = null):void 
{
    if (hasEventListener(Event.ADDED_TO_STAGE))
        removeEventListener(Event.ADDED_TO_STAGE, init);
    stage.scaleMode = StageScaleMode.NO_SCALE;
    stage.align = StageAlign.TOP_LEFT;
    // add some text labels
    initGUI();
    // and request a context3D from Stage3d
    stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, onContext3DCreate);
    stage.stage3Ds[0].requestContext3D();
}
private function updateScore():void
{
    // for now, you earn points over time
    score++;
    // padded with zeroes
    if (score &lt; 10) scoreTf.text = &#39;Score: 00000&#39; + score;
    else if (score &lt; 100) scoreTf.text = &#39;Score: 0000&#39; + score;
    else if (score &lt; 1000) scoreTf.text = &#39;Score: 000&#39; + score;
    else if (score &lt; 10000) scoreTf.text = &#39;Score: 00&#39; + score;
    else if (score &lt; 100000) scoreTf.text = &#39;Score: 0&#39; + score;
    else scoreTf.text = &#39;Score: &#39; + score;
}
private function initGUI():void
{
    // a text format descriptor used by all gui labels
    var myFormat:TextFormat = new TextFormat();  
    myFormat.color = 0xFFFFFF;
    myFormat.size = 13;
    // create an FPSCounter that displays the framerate on screen
    fpsTf = new TextField();
    fpsTf.x = 0;
    fpsTf.y = 0;
    fpsTf.selectable = false;
    fpsTf.autoSize = TextFieldAutoSize.LEFT;
    fpsTf.defaultTextFormat = myFormat;
    fpsTf.text = &quot;Initializing Stage3d...&quot;;
    addChild(fpsTf);
    // create a score display
    scoreTf = new TextField();
    scoreTf.x = 560;
    scoreTf.y = 0;
    scoreTf.selectable = false;
    scoreTf.autoSize = TextFieldAutoSize.LEFT;
    scoreTf.defaultTextFormat = myFormat;
    scoreTf.text = &quot;000000&quot;;
    addChild(scoreTf);
    // add some labels to describe each shader
    var label1:TextField = new TextField();
    label1.x = 100;
    label1.y = 180;
    label1.selectable = false;  
    label1.autoSize = TextFieldAutoSize.LEFT;  
    label1.defaultTextFormat = myFormat;
    label1.text = &quot;Shader 1: Textured&quot;;
    addChild(label1);
    var label2:TextField = new TextField();
    label2.x = 400;
    label2.y = 180;
    label2.selectable = false;  
    label2.autoSize = TextFieldAutoSize.LEFT;  
    label2.defaultTextFormat = myFormat;
    label2.text = &quot;Shader 2: Vertex RGB&quot;;
    addChild(label2);
    var label3:TextField = new TextField();
    label3.x = 80;
    label3.y = 440;
    label3.selectable = false;  
    label3.autoSize = TextFieldAutoSize.LEFT;  
    label3.defaultTextFormat = myFormat;
    label3.text = &quot;Shader 3: Vertex RGB + Textured&quot;;
    addChild(label3);
    var label4:TextField = new TextField();
    label4.x = 340;
    label4.y = 440;
    label4.selectable = false;  
    label4.autoSize = TextFieldAutoSize.LEFT;  
    label4.defaultTextFormat = myFormat;
    label4.text = &quot;Shader 4: Textured + setProgramConstants&quot;;
    addChild(label4);
}
public function uploadTextureWithMipmaps(dest:Texture, src:BitmapData):void
{
     var ws:int = src.width;
     var hs:int = src.height;
     var level:int = 0;
     var tmp:BitmapData;
     var transform:Matrix = new Matrix();
     var tmp2:BitmapData;
     tmp = new BitmapData( src.width, src.height, true, 0x00000000);
     while ( ws &gt;= 1 &amp;&amp; hs &gt;= 1 )
     {                                
          tmp.draw(src, transform, null, null, null, true);    
          dest.uploadFromBitmapData(tmp, level);
          transform.scale(0.5, 0.5);
          level++;
          ws &gt;&gt;= 1;
          hs &gt;&gt;= 1;
          if (hs &amp;&amp; ws) 
          {
               tmp.dispose();
               tmp = new BitmapData(ws, hs, true, 0x00000000);
          }
     }
     tmp.dispose();
}
private function onContext3DCreate(event:Event):void 
{
    // Remove existing frame handler. Note that a context
    // loss can occur at any time which will force you
    // to recreate all objects we create here.
    // A context loss occurs for instance if you hit
    // CTRL-ALT-DELETE on Windows.            
    // It takes a while before a new context is available
    // hence removing the enterFrame handler is important!
    if (hasEventListener(Event.ENTER_FRAME))
        removeEventListener(Event.ENTER_FRAME,enterFrame);
    // Obtain the current context
    var t:Stage3D = event.target as Stage3D;                    
    context3D = t.context3D;     
    if (context3D == null) 
    {
        // Currently no 3d context is available (error!)
        return;
    }
    // Disabling error checking will drastically improve performance.
    // If set to true, Flash sends helpful error messages regarding
    // AGAL compilation errors, uninitialized program constants, etc.
    context3D.enableErrorChecking = true;
    // Initialize our mesh data
    initData();
    // The 3d back buffer size is in pixels (2=antialiased)
    context3D.configureBackBuffer(swfWidth, swfHeight, 2, true);
    // assemble all the shaders we need
    initShaders();
    myTexture = context3D.createTexture(textureSize, textureSize, Context3DTextureFormat.BGRA, false);
    uploadTextureWithMipmaps(myTexture, myTextureData.bitmapData);
    terrainTexture = context3D.createTexture(textureSize, textureSize, Context3DTextureFormat.BGRA, false);
    uploadTextureWithMipmaps(terrainTexture, terrainTextureData.bitmapData);
    // create projection matrix for our 3D scene
    projectionmatrix.identity();
    // 45 degrees FOV, 640/480 aspect ratio, 0.1=near, 100=far
    projectionmatrix.perspectiveFieldOfViewRH(45.0, swfWidth / swfHeight, 0.01, 5000.0);
    // create a matrix that defines the camera location
    viewmatrix.identity();
    // move the camera back a little so we can see the mesh
    viewmatrix.appendTranslation(0,0,-3);
    // tilt the terrain a little so it is coming towards us
    terrainviewmatrix.identity();
    terrainviewmatrix.appendRotation(-60,Vector3D.X_AXIS);
    // start the render loop!
    addEventListener(Event.ENTER_FRAME,enterFrame);
}
// create four different shaders
private function initShaders():void
{
    // A simple vertex shader which does a 3D transformation
    // for simplicity, it is used by all four shaders
    var vertexShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
    vertexShaderAssembler.assemble
    ( 
        Context3DProgramType.VERTEX,
        // 4x4 matrix multiply to get camera angle    
        &quot;m44 op, va0, vc0\n&quot; +
        // tell fragment shader about XYZ
        &quot;mov v0, va0\n&quot; +
        // tell fragment shader about UV
        &quot;mov v1, va1\n&quot; +
        // tell fragment shader about RGBA
        &quot;mov v2, va2\n&quot;
    );            
    // textured using UV coordinates
    var fragmentShaderAssembler1:AGALMiniAssembler = new AGALMiniAssembler();
    fragmentShaderAssembler1.assemble
    ( 
        Context3DProgramType.FRAGMENT,    
        // grab the texture color from texture 0 
        // and uv coordinates from varying register 1
        // and store the interpolated value in ft0
        &quot;tex ft0, v1, fs0 &lt;2d,linear,repeat,miplinear&gt;\n&quot;+
        // move this value to the output color
        &quot;mov oc, ft0\n&quot;
    );
    // no texture, RGBA from the vertex buffer data
    var fragmentShaderAssembler2:AGALMiniAssembler = new AGALMiniAssembler();
    fragmentShaderAssembler2.assemble
    ( 
        Context3DProgramType.FRAGMENT,    
        // grab the color from the v2 register
        // which was set in the vertex program
        &quot;sub ft0, v2, fc1\n&quot; + ///这句应该删掉？
        &quot;mov oc, v2\n&quot;
    );
    // textured using UV coordinates AND colored by vertex RGB
    var fragmentShaderAssembler3:AGALMiniAssembler = new AGALMiniAssembler();
    fragmentShaderAssembler3.assemble
    ( 
        Context3DProgramType.FRAGMENT,    
        // grab the texture color from texture 0 
        // and uv coordinates from varying register 1
        &quot;tex ft0, v1, fs0 &lt;2d,linear,repeat,miplinear&gt;\n&quot; +    
        // multiply by the value stored in v2 (the vertex rgb)
        &quot;mul ft1, v2, ft0\n&quot; +
        // move this value to the output color
        &quot;mov oc, ft1\n&quot;
    );
    // textured using UV coordinates and 
    // tinted using a fragment constant
    var fragmentShaderAssembler4:AGALMiniAssembler = new AGALMiniAssembler();
    fragmentShaderAssembler4.assemble
    ( 
        Context3DProgramType.FRAGMENT,    
        // grab the texture color from texture 0 
        // and uv coordinates from varying register 1
        &quot;tex ft0, v1, fs0 &lt;2d,linear,repeat,miplinear&gt;\n&quot; +    
        // multiply by the value stored in fc0
        &quot;mul ft1, fc0, ft0\n&quot; +
        // move this value to the output color
        &quot;mov oc, ft1\n&quot;
    );
    // combine shaders into a program which we then upload to the GPU
    shaderProgram1 = context3D.createProgram();
    shaderProgram1.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler1.agalcode);
    shaderProgram2 = context3D.createProgram();
    shaderProgram2.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler2.agalcode);
    shaderProgram3 = context3D.createProgram();
    shaderProgram3.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler3.agalcode);
    shaderProgram4 = context3D.createProgram();
    shaderProgram4.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler4.agalcode);
}
private function initData():void 
{
    // parse the OBJ file and create buffers
    myMesh = new Stage3dObjParser(myObjData, context3D, 1, true, true);
    // parse the terrain mesh as well
    terrainMesh = new Stage3dObjParser(terrainObjData, context3D, 1, true, true);
}        
private function renderTerrain():void
{
    context3D.setTextureAt(0, terrainTexture);
    // simple textured shader
    context3D.setProgram ( shaderProgram1 );
    // position
    context3D.setVertexBufferAt(0, terrainMesh.positionsBuffer, 
        0, Context3DVertexBufferFormat.FLOAT_3);
    // tex coord
    context3D.setVertexBufferAt(1, terrainMesh.uvBuffer, 
        0, Context3DVertexBufferFormat.FLOAT_2);
    // vertex rgba
    context3D.setVertexBufferAt(2, terrainMesh.colorsBuffer, 
        0, Context3DVertexBufferFormat.FLOAT_4);
    // set up camera angle
    modelmatrix.identity();
    // make the terrain face the right way
    modelmatrix.appendRotation( -90, Vector3D.Y_AXIS);
    // slowly move the terrain around
    modelmatrix.appendTranslation(
        Math.cos(t/300)*1000,Math.cos(t/200)*1000 + 500,-130); 
    // clear the matrix and append new angles
    modelViewProjection.identity();
    modelViewProjection.append(modelmatrix);
    modelViewProjection.append(terrainviewmatrix);
    modelViewProjection.append(projectionmatrix);    
    // pass our matrix data to the shader program
    context3D.setProgramConstantsFromMatrix(
        Context3DProgramType.VERTEX, 
        0, modelViewProjection, true );
    context3D.drawTriangles(terrainMesh.indexBuffer, 
        0, terrainMesh.indexBufferCount);        
}
private function enterFrame(e:Event):void 
{
    // clear scene before rendering is mandatory
    context3D.clear(0,0,0); 
    // move or rotate more each frame
    t += 2.0;
    // scroll and render the terrain once
    renderTerrain();
    // how far apart each of the 4 spaceships is
    var dist:Number = 0.8; 
    // loop through each mesh we want to draw
    for (looptemp = 0; looptemp &lt; 4; looptemp++)
    {
        // clear the transformation matrix to 0,0,0
        modelmatrix.identity();
        // each mesh has a different texture, 
        // shader, position and spin speed
        switch(looptemp)
        {
            case 0:
                context3D.setTextureAt(0, myTexture);
                context3D.setProgram ( shaderProgram1 );
                modelmatrix.appendRotation(t*0.7, Vector3D.Y_AXIS);
                modelmatrix.appendRotation(t*0.6, Vector3D.X_AXIS);
                modelmatrix.appendRotation(t*1.0, Vector3D.Y_AXIS);
                modelmatrix.appendTranslation(-dist, dist, 0);
                break;
            case 1:
                context3D.setTextureAt(0, null);
                context3D.setProgram ( shaderProgram2 );
                modelmatrix.appendRotation(t*-0.2, Vector3D.Y_AXIS);
                modelmatrix.appendRotation(t*0.4, Vector3D.X_AXIS);
                modelmatrix.appendRotation(t*0.7, Vector3D.Y_AXIS);
                modelmatrix.appendTranslation(dist, dist, 0);
                break;
            case 2:
                context3D.setTextureAt(0, myTexture);
                context3D.setProgram ( shaderProgram3 );
                modelmatrix.appendRotation(t*1.0, Vector3D.Y_AXIS);
                modelmatrix.appendRotation(t*-0.2, Vector3D.X_AXIS);
                modelmatrix.appendRotation(t*0.3, Vector3D.Y_AXIS);
                modelmatrix.appendTranslation(-dist, -dist, 0);
                break;
            case 3:
                context3D.setProgramConstantsFromVector(
                    Context3DProgramType.FRAGMENT, 0, Vector.&lt;Number&gt;
                    ([ 1, Math.abs(Math.cos(t/50)), 0, 1 ]) );
                context3D.setTextureAt(0, myTexture);
                context3D.setProgram ( shaderProgram4 );
                modelmatrix.appendRotation(t*0.3, Vector3D.Y_AXIS);
                modelmatrix.appendRotation(t*0.3, Vector3D.X_AXIS);
                modelmatrix.appendRotation(t*-0.3, Vector3D.Y_AXIS);
                modelmatrix.appendTranslation(dist, -dist, 0);
                break;
        }
        // clear the matrix and append new angles
        modelViewProjection.identity();
        modelViewProjection.append(modelmatrix);
        modelViewProjection.append(viewmatrix);
        modelViewProjection.append(projectionmatrix);
        // pass our matrix data to the shader program
        context3D.setProgramConstantsFromMatrix(
            Context3DProgramType.VERTEX, 
            0, modelViewProjection, true );
        // draw a spaceship mesh
        // position
        context3D.setVertexBufferAt(0, myMesh.positionsBuffer, 
            0, Context3DVertexBufferFormat.FLOAT_3);
        // tex coord
        context3D.setVertexBufferAt(1, myMesh.uvBuffer, 
            0, Context3DVertexBufferFormat.FLOAT_2);
        // vertex rgba
        context3D.setVertexBufferAt(2, myMesh.colorsBuffer, 
            0, Context3DVertexBufferFormat.FLOAT_4);
        // render it
        context3D.drawTriangles(myMesh.indexBuffer, 
            0, myMesh.indexBufferCount);        
    }
    // present/flip back buffer
    // now that all meshes have been drawn
    context3D.present();
    // update the FPS display
    fpsTicks++;
    var now:uint = getTimer();
    var delta:uint = now - fpsLast;
    // only update the display once a second
    if (delta &gt;= 1000) 
    {
        var fps:Number = fpsTicks / delta * 1000;
        fpsTf.text = fps.toFixed(1) + &quot; fps&quot;;
        fpsTicks = 0;
        fpsLast = now;
    }
    // update the rest of the GUI
    updateScore();
}
} // end of class
} // end of package
</code></pre><h3 id="-6-textures-making-things-look-pretty">第6章，Textures: Making Things Look Pretty</h3>
<hr>
<p><strong>贴图必须满足2次方</strong></p>
<blockquote>
<p>textures must have a length and width that fall into these values: 2,4,8,16,32,64,128,256,512,1024 and so on.</p>
</blockquote>
<p><strong>UV坐标</strong></p>
<blockquote>
<p>The coordinate U is the left-right axis in a texture, while V represents the up-down axis. Therefore, the bottom of a texture has V of 1 and the far right would have U of 1.</p>
</blockquote>
<p><img src="/image/molehill_book04.jpg" alt=""></p>
<p><strong>透明Textures</strong></p>
<blockquote>
<p>You can also use a .PNG file, complete with variable transparency.</p>
</blockquote>
<p><strong>Animating UVs</strong></p>
<p>例如水的特效，可以让uv不断增加一点点，然后uv_offsets传到shader里</p>
<pre><code>// increment the x axis of a vector3D
uv_offsets.x += 0.01;
// send this vector to the AGAL variable vc4
context3D.setProgramConstantsFromVector(Context3DProgramType.VERTEX,4, uv_offsets, true );
</code></pre><p>在shader里把uv做加法</p>
<pre><code>add v1, va1, vc4
</code></pre><p><strong>Texture Atlases</strong></p>
<blockquote>
<p>A great technique to increase your game&#39;s framerate and allow more meshes to be rendered<br>using the same shader is to pack multiple textures into a large bitmap called a texture atlas. </p>
</blockquote>
<p>是提升效率的很重要手段，因为可以把很多不同贴图的模型，放在一次draw call 里。</p>
<blockquote>
<p>Using texture atlases is definitely the best practice for rendering fonts in your 3D world .</p>
</blockquote>
<p><img src="/image/molehill_book04.jpg" alt=""></p>
<p><strong>Animated Textures</strong></p>
<p>第一种方法：in your render loop you could switch the texture you send to context3D.setTextureAt() every few frames.</p>
<p>第2种方法：simple send a new offset in a setProgramConstantsFromVector() call to shift the texture coordinates over to the next frame</p>
<p>显然第一种方法是很慢很蠢的。</p>
<p><strong>Manipulating Texture Data</strong></p>
<p>可以每帧调用uploadFromBitmapData()，但这样效率是很低的，要避免这么做。<br>如果决定非要这么做了的话，还可以给bitmapdata加滤镜Anything AS3 code you have around that can generate bitmapdata can be used to as the source pixels for your textures。</p>
<h2 id="render-states-blend-modes-backface-culling-depth-testing">Render States：Blend modes, backface culling, depth testing</h2>
<p><strong>Backface Culling</strong></p>
<p>默认情况下，效率关系只显示mesh可以看见的那一面。如果想两面都显示要这样不做背面裁剪</p>
<pre><code>context3D.setCulling(Context3DTriangleFace.NONE);
</code></pre><p>可选的参数包括</p>
<pre><code>Context3DTriangleFace.NONE (不裁剪),
Context3DTriangleFace.BACK (默认情况，背面被裁剪),
Context3DTriangleFace.FRONT (与正常情况相反，正面被裁减)
Context3DTriangleFace.BOTH (没什么用，全裁剪，不渲染任何东西).
</code></pre><p><strong>Depth Testing</strong></p>
<p>stage3d在每个在屏幕上的像素都保存一个深度值叫做zbuffer，默认molehill只渲染离camera近的像素，但当你不想为某个mesh保存深度信息（比如爆炸特效或者透明区域例如窗户）就要设置 setDepthTest（）</p>
<blockquote>
<p>For example, if you are going to render a transparent mesh like a window that you don&#39;t want to draw on the zbuffer (so that other objects are always visible behind it) but you DO want it to be obscured by furniture in the room that is in front of it, simply use:</p>
</blockquote>
<pre><code>context3D.setDepthTest(false, Context3DCompareMode.LESS);
</code></pre><p>第1个boolean值为true表示下一个要渲染的mesh写入depth buffer，反之不写入。<br>第2个参数可以是</p>
<pre><code> Context3DCompareMode.ALWAYS
 Context3DCompareMode.EQUAL
 Context3DCompareMode.GREATER
 Context3DCompareMode.GREATER_EQUAL
 Context3DCompareMode.LESS
 Context3DCompareMode.LESS_EQUAL
 Context3DCompareMode.NEVER
 Context3DCompareMode.NOT_EQUAL
</code></pre><blockquote>
<p>The pixel in question will only be rendered when a comparison between it and the<br>destination pixel are TRUE based on the preceding criteria. The default in Stage3D is to only<br>render pixels that have a depth value that is LESS than what is already on the screen, closer<br>to the camera.<br>The preceding example is handy if you are going to render a transparent mesh like a window<br>that you don&#39;t want to draw on the zbuffer (so that other objects are always visible behind<br>it), but you DO want it to be obscured by furniture in the room that is in front of it.<br>Like with other render states, this will be in effect until you set it to something else. You only<br>need to call it once and that criteria will be used until you instruct Flash otherwise.</p>
</blockquote>
<p><strong>Blend Modes</strong><br>混合模式影响如何渲染texture</p>
<p>在画mesh之前调用Context3D.setBlendFactors()，传递两个乘数给flash，告诉molehill用什么颜色渲染texture。</p>
<p>可选参数：</p>
<pre><code>Context3DBlendFactor.DESTINATION_ALPHA
Context3DBlendFactor.DESTINATION_COLOR
Context3DBlendFactor.ONE
Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA
Context3DBlendFactor.ONE_MINUS_DESTINATION_COLOR
Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA
Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR
Context3DBlendFactor.SOURCE_ALPHA
Context3DBlendFactor.SOURCE_COLOR
Context3DBlendFactor.ZERO
</code></pre><p>渲染公式： framebuffercolor = (fragmentcolor <em> srcBlend) + (framebuffercolor </em> destBlend).</p>
<p>这是stage3d默认参数，完全不透明</p>
<pre><code>// this is the Molehill default: nice for opaque textures
// all of the color on screen comes from the fragment color
context3D.setBlendFactors(Context3DBlendFactor.ONE,Context3DBlendFactor.ZERO);
</code></pre><p>常见的使用透明贴图的方法：</p>
<pre><code>// this is the proper setting to use .png textures
// that have transparent regions
// perfect for foliage/fences/fonts
context3D.setBlendFactors(
Context3DBlendFactor.SOURCE_ALPHA,
Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);
</code></pre><p>加亮：</p>
<pre><code>// this setting makes it lighten the scene only
// good for particles stored as .jpg
// (only white sections add to the screen - black is not drawn)
context3D.setBlendFactors(
Context3DBlendFactor.SOURCE_COLOR,
Context3DBlendFactor.ONE);
</code></pre><blockquote>
<p>Blend modes, backface culling, and depth testing are all render states, meaning that you<br>only have to set them once and that behavior continues to be in effect until you set it to<br>something else.</p>
</blockquote>
<p>效率：</p>
<p>不透明的jpg贴图效率更高，避免overdraw，看不到的不draw，多用zbuffer，从近到远的顺序draw，避免statechange（backface culling ,depth testing,blendmodes），尽量短的shader，越少mesh越好，组合mesh让drawTriangles()调用次数越少越好，只渲染实际可见的mesh（这就要用到PVS算法，quad-trees, BSP trees, and portals了）</p>
<p>最后做了demo，具体看Stage3dGame.as代码了</p>
<p>本章总结</p>
<blockquote>
<p>In this chapter, we focused primarily upon three functions that affect how your meshes are<br>rendered: setBlendFactors, setCulling, and setDepthTest. Creative use of these<br>special render states open your game world up to all sorts of special effects.<br>In implementing this new functionality, we achieved a few milestones. Our game engine is<br>now using multiple textures and several meshes; we have code for rendering textures using<br>new blend modes which allow us to render special effects such as explosions and smoke.<br>We can change whether backfaces are culled on meshes, so that we can draw the insides of<br>transparent objects, we can ignore or use the zbuffer as desired, and we are now detecting<br>key presses for user control of the action.</p>
</blockquote>
<h3 id="-7-timers-inputs-and-entities-gameplay-goodness-">第7章，Timers, Inputs, and Entities: Gameplay Goodness!</h3>
<hr>
<p>前边介绍了两个3d不相关的类<br>GameTimer<br>GameInput</p>
<p>后面抽象出了一个Stage3dEntity基类.<br>介绍了一个技巧就是设置dirty flag，然后下一帧渲染的时候一起更新transform矩阵。</p>
<p>其他很多数学方法并没有详细介绍原理。</p>
<p>本章总结</p>
<blockquote>
<ul>
<li>We now have a class that measures time for use in animations</li>
<li>We also have a new class that detects the player keyboard and mouse input</li>
<li>We created a game entity class for use by all in-game objects</li>
<li>We programmed a simple chase camera with mouse-look</li>
<li>We upgraded our game to include a heads-up-display overlay and many new in-game models and effects</li>
</ul>
</blockquote>
<h3 id="-8-eye-candy-aplenty">第8章，Eye-Candy Aplenty</h3>
<hr>
<p>粒子是两个mesh型变做法不是很通用的粒子做法，可用性不高，略了，不过这种做法用AGAL做顶点动画的部分还是值得看一下的。</p>
<h3 id="-9-a-world-filled-with-action">第9章，A World Filled with Action</h3>
<hr>
<p>深入到游戏细节了，已经没有stage3d的内容了，碰撞检测和可视过滤都是算圆形距离的，不够深入。还有些ui什么的参杂在里边，代码细节太多实在没心情仔细看了。</p>
<h3 id="-10-chapter-10-3-2-1-action-">第10章，Chapter 10: 3... 2... 1... ACTION!</h3>
<hr>
<p>貌似是重构一些代码? 都是游戏逻辑，没有stage3d内容了，我就没看了。</p>
<h2 id="-">总结</h2>
<p>书还不错，我确实入门了，遗憾是数学部分没有专门讲解， 如果有本续集，深度一些就好了。</p>


              本文采用 <a rel="license" style="color:#0366d6;" href="https://creativecommons.org/licenses/by-nd/4.0/deed.zh">署名-禁止演绎 4.0 国际许可协议 (CC BY-ND 4.0)</a> 进行许可（保留链接可任意转载，禁止修改）。
            </div>
            <div class="article_row">
                 <a title="Flash" class="tag_button big_button" href="/tags/#Flash">Flash</a> <a title="读书" class="tag_button big_button" href="/tags/#读书">读书</a>
            </div>

            <div class="article_row" >
              <div class="social-share"></div>
            </div>

            <div class="article_row">
             <p>留言系统需要代理访问</p>
            </div>
            <div class="article_row">
              <div>
                <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                  <!-- 2017blogarticle -->
                  <ins class="adsbygoogle"
                  style="display:block"
                  data-ad-client="ca-pub-3527087615346771"
                  data-ad-slot="2049652650"
                  data-ad-format="auto"></ins>
                <script>
                (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
              </div>
            </div>

            <div>
             <div id="disqus_thread"></div>
              <script>

              /**
              *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
              *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
              
              var disqus_config = function () {
              this.page.url = "http://nshen.net/article/2013-07-28/stage3d-game-programming-beginner"
              this.page.identifier = "article-stage3d-game-programming-beginner"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
              };
              
              (function() { // DON'T EDIT BELOW THIS LINE
              var d = document, s = d.createElement('script');
              s.src = 'https://nshen-net.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
              })();
              </script>
              <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            </div>
            <div id="pre_and_next" class="markdown-body" >
              <div id="pre_link"> 
                    <a href="/article/2014-10-16/stage3d-projection-matrix" ><span>&laquo;&nbsp;Stage3D各种投影矩阵的推导</span></a>
              </div>
              <div id="next_link"> 
                    <a href="/project/2013-06-03/object-socket"><span>ObjectSocket-让Flash与Nodejs更方便的交互&nbsp;&raquo;</span></a>
              </div>
            </div>

          </div>

        </main>
    <footer id="footer">
        <div class="center">
            <p>&copy; 2004-2017 Nshen.net | <a href="/atom.xml" target="blank">Feed</a> | <a href="/sitemap.xml" target="blank">Sitemap</a> | <a href="/tags" target="blank">Tags</a> | <a href="/support">Support</a></p>
            <p>本站由 <a href="https://github.com/nshen/coding-blog" target="blank">CodingBlog</a> 强力构建，最后生成于 2021年12月24日上午9点21分 。</p>
            <p>「CloudBase Webify 提供网站托管服务」</p>
        </div>
    
        <script>
            var _hmt = _hmt || [];
            (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e1acab9c095adb812998c18d06d414ea";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
            })();
        </script>
    
        <script>
        (function(){
            //百度链接提交
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
        </script>
    </footer>
  </div>

  <script src="/assets/prism.js"></script>
  <script src="/assets/social-share.min.js"></script>

</body>

</html>